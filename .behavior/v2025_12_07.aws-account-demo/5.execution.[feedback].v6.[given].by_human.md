emit your response to the feedback into
- .behavior/v2025_12_07.aws-account-demo/5.execution.[feedback].v6.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---
---
---


# blocker.1

all the readonly attributes should default to null on read if aws does not provide the value; that's the point of null vs undefined (known nothing vs unknown nothing)

but! only if null is aavalid option. if we expect aws to always return a value, then we should fail fast instead

e.g., createdAt should always return a value -fail fast i f not

e.g., name should be null

it should be both optional and nullable! optional for readonlys, nullable for null on read

 readonlys should always be optionable; but only NULLable if its a valid choice for that domain attribute!


# blocker.2

castIntoDeclaredAwsSsoUser(user, instanceRef)

ordered inputs are FORBIDDEN

check ALL cases of ordered inputs

the first arg should ALWAYS be an object, with key value inputs

NEVER ordered inputs


# blocker.3


why is this destructured and restructured?

we should ALWAYS flow the FULLTYPE through


          by: {
            unique: {
              instance: input.instance,
              permissionSet: input.permissionSet,
              principalType: input.principalType,
              principal: input.principal,
              targetType: input.targetType,
              target: input.target,
            },
          },

          our types should FIT!

          we shouldn't need to operate onbags of words

          by:{ unique: input } is MUCH better in this case

          where else did this defect occur?


# blocker.4

why are you extracting a constant here?


    const instance = await getOneSsoInstance(
      { by: { ref: assignmentDesired.instance } },
      context,
    );
    if (!instance)
      UnexpectedCodePathError.throw('sso instance not found', {
        instanceRef: assignmentDesired.instance,
      });

    const instanceArn = instance.arn;


  why not just use instance.arn further down?

  why loose all thedtype information and loose the domain-entity info in favor of an adhoc variable?


# blocker.5


    const instanceRef: RefByUnique<typeof DeclaredAwsSsoInstance> = {
      ownerAccountId: instance.ownerAccountId,
    };


    why construct a ref adhoc instead of using the standard `refByUnique<typeof DeclaredAwsSsoInstance>(instance)` ?


also, why do  neeven need instanceRef? typeof instance will always satisfy typeof instanceRef, so why not just use it directly?

emit your response to the feedback into
- .behavior/v2025_12_07.aws-account-demo/5.execution.[feedback].v5.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---
---
---


# blocker.1


`instanceArn` => `arn`, to be more consistent with the rest of our declared Sso resourecs

it's clear that the DeclaredAwsSsoInstance.arn === instanceArn


---

# blocker.2


  const adminPermissionSet = new DeclaredAwsSsoPermissionSet({
    instance: { instanceArn: ssoInstance.instanceArn },


always RefByPrimary / RefByUnique

i.e.,

instance: RefByPrimary<typeof DeclaredAwsSsoInstance>


and usage = instance: refByUnique(ssoInstance)


always refByUnique or RefByUnique.as<typeof DeclaredAwsSsoInstance>(ssoInstance)

never adhoc { ... }

---

# blocker.3


  /**
   * .what = nominal primary key for type compatibility
   * .note = instance is not globally unique; byPrimary lookups are unsupported (dao throws)
   */
  public static primary = ['instance'] as const;


the primary of `DeclaredAwsSsoAccountAssignment` is surely not just `instance`

if there's no primary key, that's fine; just remove it

no need to lie and act like it is


---

# blocker.4


  /**
   * .what = reference to the target account, or raw account id
   */
  target: Ref<typeof DeclaredAwsOrganizationAccount> | string;


  rawAccountId goes INTO RefByPrimary<typeof DeclaredAwsOrganizationAccount>

  absolutely no need - and is forbidden - to allow it to be a string


---

# blocker.5

possible to make


  /**
   * .what = reference to the identity center instance
   */
  instance: Ref<typeof DeclaredAwsSsoInstance>;


  always RefByUnique or RefByPrimary instead? why do we need to support both?

seems like RefByUnique (i.e., ownerAccountId) would be the most composable option


then


  public static nested = {
    instance: DomainLiteral, // holds RefByPrimary or RefByUnique
  };

  becomes


  public static nested = {
    instance: RefByUnique<typeof DeclaredAwsSsoInstance>,
  };


# blocker.6


export const delSsoAccountAssignment = asProcedure(
  async (
    input: {
      instance: Ref<typeof DeclaredAwsSsoInstance>;
      permissionSet: Ref<typeof DeclaredAwsSsoPermissionSet>;
      principalType: 'USER' | 'GROUP';
      principal: Ref<typeof DeclaredAwsSsoUser>;
      targetType: 'AWS_ACCOUNT';
      target: Ref<typeof DeclaredAwsOrganizationAccount> | string;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<void> => {


no. look at how the inputs to all the other del operations

never bags of words; its always based on refs


# blocker.7



    // resolve instanceArn from instance ref
    const resolveInstanceArn = async (
      instanceRef: Ref<typeof DeclaredAwsSsoInstance>,
    ): Promise<string> => {
      const instance = await getOneSsoInstance(
        { by: { ref: instanceRef } },
        context,
      );
      if (!instance)
        UnexpectedCodePathError.throw('sso instance not found', { instanceRef });
      return instance.instanceArn;
    };

    const instanceArn = await resolveInstanceArn(input.instance);



    =>

    const instanceArn = (await getOneSsoInstance(
        { by: { ref: instanceRef } },
        context,
      ))?.arn ?? UnexpectedCodePathError.throw('sso instance not found', { instanceRef });


# blocker.8



export const getOneSsoAccountAssignment = asProcedure(
  async (
    input: {
      by: {
        instance: Ref<typeof DeclaredAwsSsoInstance>;
        permissionSet: Ref<typeof DeclaredAwsSsoPermissionSet>;
        principalType: 'USER' | 'GROUP';
        principal: Ref<typeof DeclaredAwsSsoUser>;
        targetType: 'AWS_ACCOUNT';
        target: Ref<typeof DeclaredAwsOrganizationAccount> | string;
      };
    },
    context: ContextAwsApi & VisualogicContext,
  ):


again, this is not the standard contract for getOne operations

same for getAll

look at the standard and conform


# blocker.9

never, ever, ever use ordered inputs


export const castIntoDeclaredAwsSsoPermissionSet = (
  response: PermissionSet,
  instance: Ref<typeof DeclaredAwsSsoInstance>,
  policy: DeclaredAwsIamPolicyBundle,
  tags?: Record<string, string>,
):


always = (input: { ... })

always use key:value input shape

look at your mechanics briefs if you dont know why


---

# blocker.10

within setSsoPermissionSet

decompose out the sub operations

i.e., setSsoPermissionSetX setSsoPermissionSetY, etc

for the updates specifically

that will make it easier to reason about; put them into their own files

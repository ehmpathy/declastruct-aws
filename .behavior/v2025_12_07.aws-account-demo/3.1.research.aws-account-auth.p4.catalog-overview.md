# aws sso auth vs access keys (human vs robot)

this brief explains how **aws sso authentication** differs from **access keys**, using your preferred actor model:

- **human** = you, provisioning, architecture, admin
- **robot** = ci/cd, github actions, automation

---

# ğŸ”‘ two different ways to authenticate to aws

aws exposes two major authentication modes:

1. **access keys** â€” legacy, static, risky
2. **aws sso (identity center)** â€” modern, session-based, secure

they operate in fundamentally different ways.

---

# ğŸ§â€â™‚ï¸ human: aws sso (modern)

### aws sso = â€œlog in as a person,â€ not â€œlog in as a credential.â€

you authenticate with:

- browser login
- mfa
- temporary credentials
- a permission set (e.g., `AdministratorAccess`)

after login:

\`\`\`
aws sso login
aws sts get-caller-identity
\`\`\`

you receive **ephemeral, auto-expiring session credentials**, not permanent keys.

---

## ğŸ”· key properties of sso vs access keys

| property | aws sso | access keys |
|---------|---------|-------------|
| persistent? | âŒ no | âœ… yes |
| expire automatically? | âœ” yes | âŒ no |
| requires mfa? | âœ” yes | âŒ not for api usage |
| tied to a human identity? | âœ” yes | âŒ no |
| safe to store? | âœ” yes (no secret stored) | âŒ high-risk |
| rotation? | automatic | manual |
| modern recommended use? | humans | robots (before oidc) |

---

## why sso exists

aws learned that:

- humans should **never** use access keys
- iam users were over-proliferated
- leaked keys caused massive breaches
- mfa requirements were weak
- access keys donâ€™t expire

so aws created **identity center** to fix all human authentication.

---

# ğŸ¤– robot: access keys (legacy)

robots canâ€™t open a browser â†’ historically, ci pipelines required **access keys**.

robots used:

- access key id
- secret access key

stored inside GitHub Secrets or environment variables.

### ğŸ’¥ big problems

- keys never expire
- keys leak easily
- keys are difficult to rotate
- easy to accidentally grant admin
- attacker gains full control if leaked
- violates modern ci/cd best practices

today, access keys for robots are considered **a last resort only**.

---

# ğŸ¤– modern robot auth: oidc (no access keys)

aws + github now support **oidc federation**, which replaces access keys entirely.

workflow:

1. robot requests an oidc token from github
2. aws verifies the token
3. aws issues temporary, scoped sts credentials

no secrets stored at all.

### oidc gives robots:

- **keyless** authentication
- short-lived session creds
- repo-scoped trust
- branch-scoped trust
- least-privilege permissions
- zero storage of long-lived secrets

this is why your recommended pattern is:

- **human uses sso**
- **robot uses oidc**
- **nobody uses access keys**

---

# ğŸ§  big picture mental model

### aws sso = *human identity layer*
expiring sessions, mfa, browser login.

### oidc = *robot identity layer*
github-issued attestation â†’ sts role assumption.

### access keys = *deprecated pain layer*
static, leakable, persistent, insecure.

---

# ğŸŸ¦ why sso is better for humans

1. **no static secrets**
2. **mfa enforced**
3. **automatic expiration**
4. **device-resident sessions**
5. **no iam user sprawl**
6. **clean audit trail tied to human identity**

---

# ğŸŸª why oidc is better for robots

1. **no long-lived keys in github**
2. **15â€“60 min session credentials**
3. **trust scoped to your repo**
4. **trust scoped to specific branches**
5. **least privilege enforcement**
6. **robot cannot escalate itself**

---

# ğŸŸ© practical consequences for your setup

### human
- uses SSO to authenticate
- provisions IAM roles, trust policies, and SCP guardrails
- performs all privileged actions
- no access keys ever

### robot
- authenticates via GitHub OIDC
- receives short-lived AWS credentials
- cannot alter IAM or escalate privileges
- operates only inside human-defined permission boundaries

### access keys
- unused
- unnecessary
- unsafe
- replaced entirely by SSO (for humans) and OIDC (for robots)

---

# âœ” summary

**aws sso is for humans.**
secure, ephemeral, mfa, browser-based, identity-driven.

**oidc is for robots.**
secure, ephemeral, attestation-based, least-privilege.

**access keys are legacy.**
persistent, leak-prone, insecure, should not be used except as an absolute last resort.

---

if you want, I can convert this into a `.brief.auth-model`, or produce a diagram version, or integrate it into your existing security docs.

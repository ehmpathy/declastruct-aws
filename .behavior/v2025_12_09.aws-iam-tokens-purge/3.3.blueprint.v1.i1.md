# Blueprint: IAM User Access Key Purge Implementation

## Overview

This blueprint describes how to implement the domain objects, operations, and DAOs needed to fulfill the wish:

```typescript
getAllIamUserAccessKeys({ by: { account: RefByPrimary<typeof DeclaredAwsOrganizationAccount> }})
// then mark them for deletion via del(key)
```

---

## Implementation Phases

### Phase 1: Domain Objects

#### 1.1 Create `DeclaredAwsIamUser.ts`

```
src/domain.objects/DeclaredAwsIamUser.ts
```

- Interface + class with primary=[id], unique=[account, username]
- Properties: id?, arn?, account, username, path?, createDate?
- Follow pattern from `DeclaredAwsOrganizationAccount.ts`

#### 1.2 Create `DeclaredAwsIamUserAccessKey.ts`

```
src/domain.objects/DeclaredAwsIamUserAccessKey.ts
```

- Interface + class with primary=[accessKeyId], no unique
- Properties: accessKeyId?, user, status, createDate?, lastUsedDate?, lastUsedService?, lastUsedRegion?
- Follow pattern from `DeclaredAwsLambdaAlias.ts`

---

### Phase 2: Domain Operations - IAM User

#### 2.1 Create `castIntoDeclaredAwsIamUser.ts`

```
src/domain.operations/iamUser/castIntoDeclaredAwsIamUser.ts
```

Cast AWS SDK `User` response into `DeclaredAwsIamUser`.

```typescript
export const castIntoDeclaredAwsIamUser = (input: {
  user: User; // from @aws-sdk/client-iam
  account: RefByPrimary<typeof DeclaredAwsOrganizationAccount>;
}): HasReadonly<typeof DeclaredAwsIamUser> => {
  return new DeclaredAwsIamUser({
    id: input.user.UserId,
    arn: input.user.Arn,
    account: input.account,
    username: input.user.UserName!,
    path: input.user.Path,
    createDate: input.user.CreateDate
      ? toUniDateTime(input.user.CreateDate)
      : undefined,
  });
};
```

#### 2.2 Create `getAllIamUsers.ts`

```
src/domain.operations/iamUser/getAllIamUsers.ts
```

- Use `IAMClient` + `ListUsersCommand`
- Paginate using `Marker`
- Cast each user via `castIntoDeclaredAwsIamUser`
- Follow pattern from `getAllLambdaAliases.ts`

```typescript
export const getAllIamUsers = asProcedure(
  async (
    input: {
      by: { account: RefByPrimary<typeof DeclaredAwsOrganizationAccount> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUser>[]> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    const users: User[] = [];
    let marker: string | undefined;

    do {
      const response = await iam.send(
        new ListUsersCommand({ Marker: marker }),
      );
      users.push(...(response.Users ?? []));
      marker = response.Marker;
    } while (marker);

    return users.map((user) =>
      castIntoDeclaredAwsIamUser({ user, account: input.by.account }),
    );
  },
);
```

#### 2.3 Create `getOneIamUser.ts`

```
src/domain.operations/iamUser/getOneIamUser.ts
```

- Use `GetUserCommand` for lookup by username
- Support `by: { primary | unique | ref }`
- Follow pattern from `getOneSsoPermissionSet.ts`

---

### Phase 3: Domain Operations - IAM User Access Key

#### 3.1 Create `castIntoDeclaredAwsIamUserAccessKey.ts`

```
src/domain.operations/iamUserAccessKey/castIntoDeclaredAwsIamUserAccessKey.ts
```

Cast AWS SDK `AccessKeyMetadata` + `AccessKeyLastUsed` into domain object.

```typescript
export const castIntoDeclaredAwsIamUserAccessKey = (input: {
  accessKey: AccessKeyMetadata;
  user: RefByUnique<typeof DeclaredAwsIamUser>;
  lastUsed?: AccessKeyLastUsed;
}): HasReadonly<typeof DeclaredAwsIamUserAccessKey> => {
  return new DeclaredAwsIamUserAccessKey({
    accessKeyId: input.accessKey.AccessKeyId,
    user: input.user,
    status: input.accessKey.Status as 'Active' | 'Inactive',
    createDate: input.accessKey.CreateDate
      ? toUniDateTime(input.accessKey.CreateDate)
      : undefined,
    lastUsedDate: input.lastUsed?.LastUsedDate
      ? toUniDateTime(input.lastUsed.LastUsedDate)
      : null,
    lastUsedService: input.lastUsed?.ServiceName ?? null,
    lastUsedRegion: input.lastUsed?.Region ?? null,
  });
};
```

#### 3.2 Create `getAllIamUserAccessKeys.ts`

```
src/domain.operations/iamUserAccessKey/getAllIamUserAccessKeys.ts
```

Main operation for the wish. Supports two modes:
- `by: { user }` - list keys for one user
- `by: { account }` - list keys for ALL users in account

```typescript
export const getAllIamUserAccessKeys = asProcedure(
  async (
    input: {
      by: PickOne<{
        user: RefByUnique<typeof DeclaredAwsIamUser>;
        account: RefByPrimary<typeof DeclaredAwsOrganizationAccount>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey>[]> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    // Determine which users to fetch keys for
    const users: RefByUnique<typeof DeclaredAwsIamUser>[] = input.by.user
      ? [input.by.user]
      : (await getAllIamUsers({ by: { account: input.by.account! } }, context))
          .map((u) => ({ account: u.account, username: u.username }));

    // Fetch access keys for each user
    const accessKeys: HasReadonly<typeof DeclaredAwsIamUserAccessKey>[] = [];

    for (const userRef of users) {
      // List access keys for this user
      const response = await iam.send(
        new ListAccessKeysCommand({ UserName: userRef.username }),
      );

      // Enrich each key with last-used info
      for (const keyMeta of response.AccessKeyMetadata ?? []) {
        const lastUsedResponse = await iam.send(
          new GetAccessKeyLastUsedCommand({
            AccessKeyId: keyMeta.AccessKeyId,
          }),
        );

        accessKeys.push(
          castIntoDeclaredAwsIamUserAccessKey({
            accessKey: keyMeta,
            user: userRef,
            lastUsed: lastUsedResponse.AccessKeyLastUsed,
          }),
        );
      }
    }

    return accessKeys;
  },
);
```

#### 3.3 Create `getOneIamUserAccessKey.ts`

```
src/domain.operations/iamUserAccessKey/getOneIamUserAccessKey.ts
```

- Lookup by primary (accessKeyId) requires knowing the user
- Since there's no unique key, primary lookup needs special handling
- Follow pattern from `getOneLambdaAlias.ts`

**Challenge**: AWS `ListAccessKeys` requires `UserName`, but we only have `accessKeyId`.

**Solution**:
- If caller provides `accessKeyId` only, we need to search all users (expensive)
- Better: require user ref in the input for efficient lookup
- Or: accept that getOne by primary alone is not supported

```typescript
export const getOneIamUserAccessKey = asProcedure(
  async (
    input: {
      by: {
        accessKeyId: string;
        user: RefByUnique<typeof DeclaredAwsIamUser>;
      };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey> | null> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    // List keys for the user and find the matching one
    const response = await iam.send(
      new ListAccessKeysCommand({ UserName: input.by.user.username }),
    );

    const keyMeta = response.AccessKeyMetadata?.find(
      (k) => k.AccessKeyId === input.by.accessKeyId,
    );

    if (!keyMeta) return null;

    // Enrich with last-used info
    const lastUsedResponse = await iam.send(
      new GetAccessKeyLastUsedCommand({ AccessKeyId: input.by.accessKeyId }),
    );

    return castIntoDeclaredAwsIamUserAccessKey({
      accessKey: keyMeta,
      user: input.by.user,
      lastUsed: lastUsedResponse.AccessKeyLastUsed,
    });
  },
);
```

#### 3.4 Create `delIamUserAccessKey.ts`

```
src/domain.operations/iamUserAccessKey/delIamUserAccessKey.ts
```

Delete an access key. Idempotent.

```typescript
export const delIamUserAccessKey = asProcedure(
  async (
    input: {
      by: {
        accessKeyId: string;
        user: RefByUnique<typeof DeclaredAwsIamUser>;
      };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<{ deleted: true }> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    try {
      await iam.send(
        new DeleteAccessKeyCommand({
          UserName: input.by.user.username,
          AccessKeyId: input.by.accessKeyId,
        }),
      );
    } catch (error) {
      // Idempotent: ignore if already deleted
      if (error instanceof Error && error.name === 'NoSuchEntityException')
        return { deleted: true };
      throw error;
    }

    return { deleted: true };
  },
);
```

#### 3.5 Create `setIamUserAccessKey.ts` (Optional)

```
src/domain.operations/iamUserAccessKey/setIamUserAccessKey.ts
```

Only supports updating status (Active/Inactive). No finsert.

```typescript
export const setIamUserAccessKey = asProcedure(
  async (
    input: {
      upsert: DeclaredAwsIamUserAccessKey;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey>> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    // Update the status
    await iam.send(
      new UpdateAccessKeyCommand({
        UserName: input.upsert.user.username,
        AccessKeyId: input.upsert.accessKeyId,
        Status: input.upsert.status,
      }),
    );

    // Return updated state
    return (
      (await getOneIamUserAccessKey(
        {
          by: {
            accessKeyId: input.upsert.accessKeyId!,
            user: input.upsert.user,
          },
        },
        context,
      )) ?? UnexpectedCodePathError.throw('key not found after update')
    );
  },
);
```

---

### Phase 4: Access DAOs

#### 4.1 Create `DeclaredAwsIamUserDao.ts`

```
src/access/daos/DeclaredAwsIamUserDao.ts
```

Standard DAO pattern. Follow `DeclaredAwsSsoPermissionSetDao.ts`.

#### 4.2 Create `DeclaredAwsIamUserAccessKeyDao.ts`

```
src/access/daos/DeclaredAwsIamUserAccessKeyDao.ts
```

```typescript
export const DeclaredAwsIamUserAccessKeyDao = new DeclastructDao<
  DeclaredAwsIamUserAccessKey,
  typeof DeclaredAwsIamUserAccessKey,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      // Note: requires user ref to be included in the primary ref
      // This is a limitation of the AWS API
      return getOneIamUserAccessKey(
        { by: { accessKeyId: input.accessKeyId!, user: input.user } },
        context,
      );
    },
    byRef: async (input, context) => {
      return getOneIamUserAccessKey(
        { by: { accessKeyId: input.accessKeyId!, user: input.user } },
        context,
      );
    },
  },
  set: {
    upsert: async (input, context) => {
      return setIamUserAccessKey({ upsert: input }, context);
    },
    delete: async (input, context) => {
      await delIamUserAccessKey(
        { by: { accessKeyId: input.accessKeyId!, user: input.user } },
        context,
      );
    },
  },
});
```

---

### Phase 5: Tests

For each domain operation, create corresponding test files:

```
src/domain.operations/iamUser/getAllIamUsers.test.ts
src/domain.operations/iamUser/getOneIamUser.test.ts
src/domain.operations/iamUser/castIntoDeclaredAwsIamUser.test.ts
src/domain.operations/iamUserAccessKey/getAllIamUserAccessKeys.test.ts
src/domain.operations/iamUserAccessKey/getOneIamUserAccessKey.test.ts
src/domain.operations/iamUserAccessKey/delIamUserAccessKey.test.ts
src/domain.operations/iamUserAccessKey/setIamUserAccessKey.test.ts
src/domain.operations/iamUserAccessKey/castIntoDeclaredAwsIamUserAccessKey.test.ts
```

Follow testing patterns from existing tests like `delLambdaAlias.test.ts`.

---

## Implementation Order

1. **Domain Objects** (can be done in parallel)
   - [ ] `DeclaredAwsIamUser.ts`
   - [ ] `DeclaredAwsIamUserAccessKey.ts`

2. **Cast Functions** (depends on domain objects)
   - [ ] `castIntoDeclaredAwsIamUser.ts`
   - [ ] `castIntoDeclaredAwsIamUserAccessKey.ts`

3. **IAM User Operations** (depends on cast functions)
   - [ ] `getAllIamUsers.ts`
   - [ ] `getOneIamUser.ts` (optional for wish)

4. **IAM Access Key Operations** (depends on IAM user operations)
   - [ ] `getAllIamUserAccessKeys.ts` ← **Core for wish**
   - [ ] `getOneIamUserAccessKey.ts`
   - [ ] `delIamUserAccessKey.ts` ← **Core for wish**
   - [ ] `setIamUserAccessKey.ts` (optional)

5. **DAOs** (depends on operations)
   - [ ] `DeclaredAwsIamUserDao.ts` (optional)
   - [ ] `DeclaredAwsIamUserAccessKeyDao.ts` ← **Core for wish**

6. **Tests** (in parallel with implementation)

---

## AWS SDK Dependencies

Add to `package.json` if not present:

```json
{
  "dependencies": {
    "@aws-sdk/client-iam": "^3.x.x"
  }
}
```

Key imports:
```typescript
import {
  IAMClient,
  ListUsersCommand,
  GetUserCommand,
  ListAccessKeysCommand,
  GetAccessKeyLastUsedCommand,
  DeleteAccessKeyCommand,
  UpdateAccessKeyCommand,
} from '@aws-sdk/client-iam';
```

---

## Wish Fulfillment Usage

After implementation, the wish can be fulfilled:

```typescript
import { del } from 'declastruct';
import { getAllIamUserAccessKeys } from './domain.operations/iamUserAccessKey/getAllIamUserAccessKeys';

// 1. Get all access keys in the account
const accessKeys = await getAllIamUserAccessKeys(
  { by: { account: { id: '123456789012' } } },
  context,
);

// 2. Mark each for deletion
const toDelete = accessKeys.map((key) => del(key));

// 3. Apply via declastruct (invokes dao.delete for each)
await declastruct.apply(toDelete, context);
```

---

## Considerations

### Cross-Account Access
- To list users in a different account, the context must have credentials that can assume a role in that account
- The `account` ref in input tells which account to target
- May need to use `STSClient.assumeRole` before creating `IAMClient`

### Rate Limiting
- AWS IAM has rate limits
- `GetAccessKeyLastUsed` is called per-key, which could be many calls
- Consider batching or adding delays for large accounts

### Error Handling
- Handle `NoSuchEntityException` for idempotent deletes
- Handle `AccessDeniedException` if permissions are insufficient
- Consider retry logic for throttling errors

# Blueprint: IAM User Access Key Purge Implementation

## Overview

This blueprint describes how to implement the domain objects, operations, and DAOs needed to fulfill the wish:

```typescript
getAllIamUserAccessKeys({ by: { account: RefByPrimary<typeof DeclaredAwsOrganizationAccount> }})
// then mark them for deletion via del(key)
```

---

## Implementation Phases

### Phase 1: Domain Objects

#### 1.1 Create `DeclaredAwsIamUser.ts`

```
src/domain.objects/DeclaredAwsIamUser.ts
```

- Interface + class with primary=[id], unique=[account, username]
- Properties: id?, arn?, account, username, path?, createDate?
- Follow pattern from `DeclaredAwsOrganizationAccount.ts`

#### 1.2 Create `DeclaredAwsIamUserAccessKey.ts`

```
src/domain.objects/DeclaredAwsIamUserAccessKey.ts
```

- Interface + class with primary=[accessKeyId], no unique
- Properties: accessKeyId?, user, status, createDate?, lastUsedDate?, lastUsedService?, lastUsedRegion?
- Follow pattern from `DeclaredAwsLambdaAlias.ts`

---

### Phase 2: Domain Operations - IAM User

#### 2.1 Create `castIntoDeclaredAwsIamUser.ts`

```
src/domain.operations/iamUser/castIntoDeclaredAwsIamUser.ts
```

Cast AWS SDK `User` response into `DeclaredAwsIamUser`.

```typescript
import type { User } from '@aws-sdk/client-iam';
import { type HasReadonly, hasReadonly, type RefByPrimary } from 'domain-objects';
import { assure, isPresent } from 'type-fns';

export const castIntoDeclaredAwsIamUser = (input: {
  user: User; // from @aws-sdk/client-iam
  account: RefByPrimary<typeof DeclaredAwsOrganizationAccount>;
}): HasReadonly<typeof DeclaredAwsIamUser> => {
  // parse createDate (required readonly)
  const createDate = isUniDateTime.assure(
    assure(input.user.CreateDate, isPresent).toISOString(),
  );

  // cast and assure readonly fields are present
  return assure(
    DeclaredAwsIamUser.as({
      id: assure(input.user.UserId, isPresent),
      arn: assure(input.user.Arn, isPresent),
      account: input.account,
      username: assure(input.user.UserName, isPresent),
      path: input.user.Path,
      createDate,
    }),
    hasReadonly({ of: DeclaredAwsIamUser }),
  );
};
```

#### 2.2 Create `getAllIamUsers.ts`

```
src/domain.operations/iamUser/getAllIamUsers.ts
```

- Use `IAMClient` + `ListUsersCommand`
- Paginate using `Marker`
- Cast each user via `castIntoDeclaredAwsIamUser`
- Follow pattern from `getAllLambdaAliases.ts`

```typescript
export const getAllIamUsers = asProcedure(
  async (
    input: {
      by: { account: RefByPrimary<typeof DeclaredAwsOrganizationAccount> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUser>[]> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    const users: User[] = [];
    let marker: string | undefined;

    do {
      const response = await iam.send(
        new ListUsersCommand({ Marker: marker }),
      );
      users.push(...(response.Users ?? []));
      marker = response.Marker;
    } while (marker);

    return users.map((user) =>
      castIntoDeclaredAwsIamUser({ user, account: input.by.account }),
    );
  },
);
```

#### 2.3 Create `getOneIamUser.ts`

```
src/domain.operations/iamUser/getOneIamUser.ts
```

- Use `GetUserCommand` for lookup by username
- Support `by: { primary | unique | ref }`
- Follow pattern from `getOneSsoPermissionSet.ts`

---

### Phase 3: Domain Operations - IAM User Access Key

#### 3.1 Create `castIntoDeclaredAwsIamUserAccessKey.ts`

```
src/domain.operations/iamUserAccessKey/castIntoDeclaredAwsIamUserAccessKey.ts
```

Cast AWS SDK `AccessKeyMetadata` + `AccessKeyLastUsed` into domain object.

```typescript
import type { AccessKeyMetadata, AccessKeyLastUsed } from '@aws-sdk/client-iam';
import { isUniDateTime } from '@ehmpathy/uni-time';
import { type HasReadonly, hasReadonly, type RefByUnique } from 'domain-objects';
import { assure, isPresent } from 'type-fns';

export const castIntoDeclaredAwsIamUserAccessKey = (input: {
  accessKey: AccessKeyMetadata;
  user: RefByUnique<typeof DeclaredAwsIamUser>;
  lastUsed?: AccessKeyLastUsed;
}): HasReadonly<typeof DeclaredAwsIamUserAccessKey> => {
  // parse createDate (required readonly)
  const createDate = isUniDateTime.assure(
    assure(input.accessKey.CreateDate, isPresent).toISOString(),
  );

  // parse lastUsedDate (nullable readonly - key may never have been used)
  const lastUsedDate = input.lastUsed?.LastUsedDate
    ? isUniDateTime.assure(input.lastUsed.LastUsedDate.toISOString())
    : null;

  // cast and assure readonly fields are present
  return assure(
    DeclaredAwsIamUserAccessKey.as({
      accessKeyId: assure(input.accessKey.AccessKeyId, isPresent),
      user: input.user,
      status: assure(input.accessKey.Status, isPresent) as 'Active' | 'Inactive',
      createDate,
      lastUsedDate,
      lastUsedService: input.lastUsed?.ServiceName ?? null,
      lastUsedRegion: input.lastUsed?.Region ?? null,
    }),
    hasReadonly({ of: DeclaredAwsIamUserAccessKey }),
  );
};
```

#### 3.2 Create `getAllIamUserAccessKeys.ts`

```
src/domain.operations/iamUserAccessKey/getAllIamUserAccessKeys.ts
```

Main operation for the wish. Supports two modes:
- `by: { user }` - list keys for one user
- `by: { account }` - list keys for ALL users in account

```typescript
export const getAllIamUserAccessKeys = asProcedure(
  async (
    input: {
      by: PickOne<{
        user: RefByUnique<typeof DeclaredAwsIamUser>;
        account: RefByPrimary<typeof DeclaredAwsOrganizationAccount>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey>[]> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    // Determine which users to fetch keys for
    const users: RefByUnique<typeof DeclaredAwsIamUser>[] = input.by.user
      ? [input.by.user]
      : (await getAllIamUsers({ by: { account: input.by.account! } }, context))
          .map((u) => ({ account: u.account, username: u.username }));

    // Fetch access keys for each user
    const accessKeys: HasReadonly<typeof DeclaredAwsIamUserAccessKey>[] = [];

    for (const userRef of users) {
      // List access keys for this user
      const response = await iam.send(
        new ListAccessKeysCommand({ UserName: userRef.username }),
      );

      // Enrich each key with last-used info
      for (const keyMeta of response.AccessKeyMetadata ?? []) {
        const lastUsedResponse = await iam.send(
          new GetAccessKeyLastUsedCommand({
            AccessKeyId: keyMeta.AccessKeyId,
          }),
        );

        accessKeys.push(
          castIntoDeclaredAwsIamUserAccessKey({
            accessKey: keyMeta,
            user: userRef,
            lastUsed: lastUsedResponse.AccessKeyLastUsed,
          }),
        );
      }
    }

    return accessKeys;
  },
);
```

#### 3.3 Create `getOneIamUserAccessKey.ts`

```
src/domain.operations/iamUserAccessKey/getOneIamUserAccessKey.ts
```

- Lookup by primary (accessKeyId) or ref
- Since there's no unique key, only primary and ref are supported
- Follow pattern from `getOneLambdaAlias.ts`

**Challenge**: AWS `ListAccessKeys` requires `UserName`, but `RefByPrimary` only has `accessKeyId`.

**Solution**: Use `GetAccessKeyLastUsed` which returns `UserName` from just `accessKeyId`, then fetch full key details.

```typescript
export const getOneIamUserAccessKey = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsIamUserAccessKey>;
        ref: Ref<typeof DeclaredAwsIamUserAccessKey>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey> | null> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    // normalize to accessKeyId
    const accessKeyId = input.by.primary?.accessKeyId ?? input.by.ref?.accessKeyId;
    if (!accessKeyId) UnexpectedCodePathError.throw('accessKeyId required', { input });

    // get last used info (also returns UserName)
    const lastUsedResponse = await iam.send(
      new GetAccessKeyLastUsedCommand({ AccessKeyId: accessKeyId }),
    );

    // extract username from response
    const username = lastUsedResponse.UserName;
    if (!username) return null; // key doesn't exist

    // list keys for user to get full metadata
    const listResponse = await iam.send(
      new ListAccessKeysCommand({ UserName: username }),
    );

    const keyMeta = listResponse.AccessKeyMetadata?.find(
      (k) => k.AccessKeyId === accessKeyId,
    );
    if (!keyMeta) return null;

    // build user ref (need account from context or derive from ARN)
    const userRef: RefByUnique<typeof DeclaredAwsIamUser> = {
      account: context.aws.account,
      username,
    };

    return castIntoDeclaredAwsIamUserAccessKey({
      accessKey: keyMeta,
      user: userRef,
      lastUsed: lastUsedResponse.AccessKeyLastUsed,
    });
  },
);
```

#### 3.4 Create `delIamUserAccessKey.ts`

```
src/domain.operations/iamUserAccessKey/delIamUserAccessKey.ts
```

Delete an access key. Idempotent.

**Note**: AWS `DeleteAccessKey` requires `UserName`, so we first call `GetAccessKeyLastUsed` to resolve it from `accessKeyId`.

```typescript
export const delIamUserAccessKey = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsIamUserAccessKey>;
        ref: Ref<typeof DeclaredAwsIamUserAccessKey>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<{ deleted: true }> => {
    const iam = new IAMClient({ region: context.aws.credentials.region });

    // normalize to accessKeyId
    const accessKeyId = input.by.primary?.accessKeyId ?? input.by.ref?.accessKeyId;
    if (!accessKeyId) UnexpectedCodePathError.throw('accessKeyId required', { input });

    // resolve username from accessKeyId
    const lastUsedResponse = await iam.send(
      new GetAccessKeyLastUsedCommand({ AccessKeyId: accessKeyId }),
    );
    const username = lastUsedResponse.UserName;

    // idempotent: if key doesn't exist, return success
    if (!username) return { deleted: true };

    // delete the key
    try {
      await iam.send(
        new DeleteAccessKeyCommand({
          UserName: username,
          AccessKeyId: accessKeyId,
        }),
      );
    } catch (error) {
      // idempotent: ignore if already deleted
      if (error instanceof Error && error.name === 'NoSuchEntityException')
        return { deleted: true };
      throw error;
    }

    return { deleted: true };
  },
);
```

#### 3.5 `setIamUserAccessKey.ts` - NOT SUPPORTED

```
src/domain.operations/iamUserAccessKey/setIamUserAccessKey.ts
```

**Not supported.** Access keys don't support tags, so we can't persist an `exid` for unique key lookups. The only use case is auditing and purging existing keys via `getAll` + `del`.

```typescript
/**
 * .what = fails fast - set operations not supported for access keys
 * .why = IAM user access keys have been superseded by SSO and OIDC federation.
 *        they don't support tags, so we can't persist an exid for unique lookups.
 *        this library focuses on auditing and purging existing keys, not managing them.
 *
 * .ref = https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html
 */
export const setIamUserAccessKey = asProcedure(
  async (
    _input: PickOne<{
      finsert: DeclaredAwsIamUserAccessKey;
      upsert: DeclaredAwsIamUserAccessKey;
    }>,
    _context: ContextAwsApi & VisualogicContext,
  ): Promise<never> => {
    BadRequestError.throw(
      'setIamUserAccessKey is not supported. IAM user access keys have been superseded by SSO and OIDC federation and are no longer recommended for new use. use getAllIamUserAccessKeys + delIamUserAccessKey to audit and purge existing keys.',
    );
  },
);
```

---

### Phase 4: Access DAOs

#### 4.1 Create `DeclaredAwsIamUserDao.ts`

```
src/access/daos/DeclaredAwsIamUserDao.ts
```

Standard DAO pattern. Follow `DeclaredAwsSsoPermissionSetDao.ts`.

#### 4.2 Create `DeclaredAwsIamUserAccessKeyDao.ts`

```
src/access/daos/DeclaredAwsIamUserAccessKeyDao.ts
```

```typescript
/**
 * .what = declastruct DAO for AWS IAM user access keys
 * .why = enables declarative management (audit and purge) of access keys
 */
export const DeclaredAwsIamUserAccessKeyDao = new DeclastructDao<
  DeclaredAwsIamUserAccessKey,
  typeof DeclaredAwsIamUserAccessKey,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      return getOneIamUserAccessKey({ by: { primary: input } }, context);
    },
    byRef: async (input, context) => {
      return getOneIamUserAccessKey({ by: { ref: input } }, context);
    },
  },
  set: {
    finsert: async (input, context) => {
      return setIamUserAccessKey({ finsert: input }, context); // fails fast, since keys have been superceeded by oidc and sso
    },
    delete: async (input, context) => {
      await delIamUserAccessKey({ by: { ref: input } }, context);
    },
  },
});
```

---

### Phase 5: Tests

For each domain operation, create corresponding test files:

```
src/domain.operations/iamUser/getAllIamUsers.test.ts
src/domain.operations/iamUser/getOneIamUser.test.ts
src/domain.operations/iamUser/castIntoDeclaredAwsIamUser.test.ts
src/domain.operations/iamUserAccessKey/getAllIamUserAccessKeys.test.ts
src/domain.operations/iamUserAccessKey/getOneIamUserAccessKey.test.ts
src/domain.operations/iamUserAccessKey/delIamUserAccessKey.test.ts
src/domain.operations/iamUserAccessKey/setIamUserAccessKey.test.ts
src/domain.operations/iamUserAccessKey/castIntoDeclaredAwsIamUserAccessKey.test.ts
```

Follow testing patterns from existing tests like `delLambdaAlias.test.ts`.

---

## Implementation Order

1. **Domain Objects** (can be done in parallel)
   - [ ] `DeclaredAwsIamUser.ts`
   - [ ] `DeclaredAwsIamUserAccessKey.ts`

2. **Cast Functions** (depends on domain objects)
   - [ ] `castIntoDeclaredAwsIamUser.ts`
   - [ ] `castIntoDeclaredAwsIamUserAccessKey.ts`

3. **IAM User Operations** (depends on cast functions)
   - [ ] `getAllIamUsers.ts`
   - [ ] `getOneIamUser.ts` (optional for wish)

4. **IAM Access Key Operations** (depends on IAM user operations)
   - [ ] `getAllIamUserAccessKeys.ts` ← **Core for wish**
   - [ ] `getOneIamUserAccessKey.ts`
   - [ ] `delIamUserAccessKey.ts` ← **Core for wish**
   - [ ] `setIamUserAccessKey.ts` (optional)

5. **DAOs** (depends on operations)
   - [ ] `DeclaredAwsIamUserDao.ts` (optional)
   - [ ] `DeclaredAwsIamUserAccessKeyDao.ts` ← **Core for wish**

6. **Tests** (in parallel with implementation)

---

## AWS SDK Dependencies

Add to `package.json` if not present:

```json
{
  "dependencies": {
    "@aws-sdk/client-iam": "^3.x.x"
  }
}
```

Key imports:
```typescript
import {
  IAMClient,
  ListUsersCommand,
  GetUserCommand,
  ListAccessKeysCommand,
  GetAccessKeyLastUsedCommand,
  DeleteAccessKeyCommand,
  UpdateAccessKeyCommand,
} from '@aws-sdk/client-iam';
```

---

## Wish Fulfillment Usage

After implementation, the wish can be fulfilled:

```typescript
import { del } from 'declastruct';
import { getAllIamUserAccessKeys } from './domain.operations/iamUserAccessKey/getAllIamUserAccessKeys';

// 1. Get all access keys in the account
const accessKeys = await getAllIamUserAccessKeys(
  { by: { account: { id: '123456789012' } } },
  context,
);

// 2. Mark each for deletion
const toDelete = accessKeys.map((key) => del(key));

// 3. Apply via declastruct (invokes dao.delete for each)
await declastruct.apply(toDelete, context);
```

---

## Considerations

### Cross-Account Access
- To list users in a different account, the context must have credentials that can assume a role in that account
- The `account` ref in input tells which account to target
- May need to use `STSClient.assumeRole` before creating `IAMClient`

### Rate Limiting
- AWS IAM has rate limits
- `GetAccessKeyLastUsed` is called per-key, which could be many calls
- Consider batching or adding delays for large accounts

### Error Handling
- Handle `NoSuchEntityException` for idempotent deletes
- Handle `AccessDeniedException` if permissions are insufficient
- Consider retry logic for throttling errors

# Distillation: AwsIamUserAccessKey Domain Design

## Naming Consideration

**AwsIamAccessKey vs AwsIamUserAccessKey**

Recommendation: **`DeclaredAwsIamUserAccessKey`**

Rationale:
- Access keys are owned by IAM Users (or the root user)
- The naming pattern `AwsIamUserAccessKey` clarifies the parent relationship
- Consistent with AWS SDK naming (e.g., `ListAccessKeys` takes `UserName`)
- Disambiguates from STS session tokens (which are temporary credentials)
- Follows this repo's pattern: `DeclaredAwsLambdaAlias` (alias belongs to lambda)

---

## Use Cases

### UC1: Get all access keys for all users in an account
```typescript
getAllIamUserAccessKeys({
  by: { account: RefByPrimary<typeof DeclaredAwsOrganizationAccount> }
}): Promise<DeclaredAwsIamUserAccessKey[]>
```

### UC2: Delete an access key
```typescript
delIamUserAccessKey({
  by: { primary: RefByPrimary<typeof DeclaredAwsIamUserAccessKey> }
}): Promise<{ deleted: true }>
```

### UC3: List access keys for a specific user
```typescript
getAllIamUserAccessKeys({
  by: { user: RefByUnique<typeof DeclaredAwsIamUser> }
}): Promise<DeclaredAwsIamUserAccessKey[]>
```

---

## Domain Objects

### DeclaredAwsIamUser (Supporting Entity)

```typescript
/**
 * .what = a declarative structure representing an AWS IAM User
 * .why = enables referencing the owner of access keys
 *
 * .identity
 *   - @primary = [id] — unique user id assigned by aws (e.g., AIDAIOSFODNN7EXAMPLE)
 *   - @unique = [account, username] — username is unique per account
 */
export interface DeclaredAwsIamUser {
  /**
   * .what = the unique identifier (ID) of the user
   * .note = is @metadata — assigned by AWS on creation
   */
  id?: string;

  /**
   * .what = the Amazon Resource Name (ARN) of the user
   * .note = is @metadata — assigned by AWS on creation
   */
  arn?: string;

  /**
   * .what = the account this user belongs to
   */
  account: RefByPrimary<typeof DeclaredAwsOrganizationAccount>;

  /**
   * .what = the friendly name identifying the user
   * .constraint = 1-64 chars
   */
  username: string;

  /**
   * .what = the path to the user
   * .default = '/'
   */
  path?: string;

  /**
   * .what = when the user was created
   * .note = is @readonly — derived from AWS source of truth
   */
  createDate?: UniDateTime;
}

export class DeclaredAwsIamUser
  extends DomainEntity<DeclaredAwsIamUser>
  implements DeclaredAwsIamUser
{
  public static primary = ['id'] as const;
  public static unique = ['account', 'username'] as const;
  public static metadata = ['id', 'arn'] as const;
  public static readonly = ['createDate'] as const;
  public static nested = {
    account: RefByPrimary<typeof DeclaredAwsOrganizationAccount>,
  };
}
```

---

### DeclaredAwsIamUserAccessKey (Primary Entity)

```typescript
/**
 * .what = a declarative structure representing an AWS IAM User Access Key
 * .why = enables declarative management and cleanup of long-term credentials
 *
 * .identity
 *   - @primary = [accessKeyId] — unique key id assigned by aws (e.g., AKIAIOSFODNN7EXAMPLE)
 *   - @unique = n/a — no unique key, accessKeyId is the only identifier
 *
 * .note
 *   - max 2 access keys per user
 *   - secretAccessKey is only available at creation time (not retrievable)
 *   - status can be toggled between Active/Inactive
 *   - this domain object focuses on get/delete operations (not create)
 *
 * .ref = https://docs.aws.amazon.com/IAM/latest/APIReference/API_AccessKeyMetadata.html
 */
export interface DeclaredAwsIamUserAccessKey {
  /**
   * .what = the access key ID
   * .note = @primary @metadata — assigned by AWS on creation
   * .constraint = 16-128 chars, prefix AKIA for permanent keys
   */
  accessKeyId?: string;

  /**
   * .what = reference to the IAM user who owns this key
   */
  user: RefByUnique<typeof DeclaredAwsIamUser>;

  /**
   * .what = the status of the access key
   * .note = can be toggled between Active/Inactive via UpdateAccessKey
   */
  status: 'Active' | 'Inactive';

  /**
   * .what = when the access key was created
   * .note = is @readonly — derived from AWS source of truth
   */
  createDate?: UniDateTime;

  /**
   * .what = when the access key was last used
   * .note = is @readonly — derived from GetAccessKeyLastUsed
   */
  lastUsedDate?: UniDateTime | null;

  /**
   * .what = the AWS service that was last accessed with this key
   * .note = is @readonly — derived from GetAccessKeyLastUsed
   */
  lastUsedService?: string | null;

  /**
   * .what = the AWS region where the key was last used
   * .note = is @readonly — derived from GetAccessKeyLastUsed
   */
  lastUsedRegion?: string | null;
}

export class DeclaredAwsIamUserAccessKey
  extends DomainEntity<DeclaredAwsIamUserAccessKey>
  implements DeclaredAwsIamUserAccessKey
{
  public static primary = ['accessKeyId'] as const;
  // public static unique = [] as const; // no unique key — accessKeyId is the only identifier
  public static metadata = ['accessKeyId'] as const;
  public static readonly = ['createDate', 'lastUsedDate', 'lastUsedService', 'lastUsedRegion'] as const;
  public static nested = {
    user: RefByUnique<typeof DeclaredAwsIamUser>,
  };
}
```

---

### Literals

```typescript
/**
 * .what = the status of an IAM access key
 */
export type IamAccessKeyStatus = 'Active' | 'Inactive';
```

---

## Domain Operations

### iamUser/getAllIamUsers.ts

```typescript
/**
 * .what = retrieves all IAM users in an account
 * .why = enables listing users to then fetch their access keys
 *
 * .maps-to = IAM.ListUsers API
 */
export const getAllIamUsers = asProcedure(
  async (
    input: {
      by: { account: RefByPrimary<typeof DeclaredAwsOrganizationAccount> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUser>[]>
);
```

### iamUserAccessKey/getAllIamUserAccessKeys.ts

```typescript
/**
 * .what = retrieves all access keys for a user or all users in an account
 * .why = enables bulk listing for cleanup/audit purposes
 *
 * .maps-to
 *   - IAM.ListUsers (if by account)
 *   - IAM.ListAccessKeys (per user)
 *   - IAM.GetAccessKeyLastUsed (per key, for usage info)
 */
export const getAllIamUserAccessKeys = asProcedure(
  async (
    input: {
      by: PickOne<{
        user: RefByUnique<typeof DeclaredAwsIamUser>;
        account: RefByPrimary<typeof DeclaredAwsOrganizationAccount>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey>[]>
);
```

### iamUserAccessKey/getOneIamUserAccessKey.ts

```typescript
/**
 * .what = retrieves a single access key by primary or unique
 * .why = enables lookup before delete, and for enriching with lastUsed info
 *
 * .maps-to
 *   - IAM.ListAccessKeys (filtered to one)
 *   - IAM.GetAccessKeyLastUsed
 */
export const getOneIamUserAccessKey = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsIamUserAccessKey>;
        unique: RefByUnique<typeof DeclaredAwsIamUserAccessKey>;
        ref: Ref<typeof DeclaredAwsIamUserAccessKey>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey> | null>
);
```

### iamUserAccessKey/setIamUserAccessKey.ts

```typescript
/**
 * .what = updates the status of an access key (Active/Inactive)
 * .why = enables deactivating keys as part of rotation workflow
 *
 * .note
 *   - does NOT support creation (secretAccessKey not retrievable after create)
 *   - only supports status toggle via upsert
 *
 * .maps-to = IAM.UpdateAccessKey
 */
export const setIamUserAccessKey = asProcedure(
  async (
    input: PickOne<{
      upsert: DeclaredAwsIamUserAccessKey;
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamUserAccessKey>>
);
```

### iamUserAccessKey/delIamUserAccessKey.ts

```typescript
/**
 * .what = deletes an access key
 * .why = enables cleanup of old/compromised keys
 *
 * .note = idempotent: returns success if key already deleted
 *
 * .maps-to = IAM.DeleteAccessKey
 */
export const delIamUserAccessKey = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsIamUserAccessKey>;
        unique: RefByUnique<typeof DeclaredAwsIamUserAccessKey>;
        ref: Ref<typeof DeclaredAwsIamUserAccessKey>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<{ deleted: true }>
);
```

---

## Access DAO

### DeclaredAwsIamUserAccessKeyDao.ts

```typescript
/**
 * .what = declastruct DAO for AWS IAM user access key resources
 * .why = wraps access key operations to conform to declastruct interface
 */
export const DeclaredAwsIamUserAccessKeyDao = new DeclastructDao<
  DeclaredAwsIamUserAccessKey,
  typeof DeclaredAwsIamUserAccessKey,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      return getOneIamUserAccessKey({ by: { primary: input } }, context);
    },
    byUnique: async (input, context) => {
      return getOneIamUserAccessKey({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsIamUserAccessKey })(input))
        return getOneIamUserAccessKey({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsIamUserAccessKey })(input))
        return getOneIamUserAccessKey({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    // finsert not supported - secretAccessKey not retrievable
    upsert: async (input, context) => {
      return setIamUserAccessKey({ upsert: input }, context);
    },
    delete: async (input, context) => {
      await delIamUserAccessKey({ by: { ref: input } }, context);
    },
  },
});
```

---

## File Structure

```
src/
├── domain.objects/
│   ├── DeclaredAwsIamUser.ts
│   ├── DeclaredAwsIamUser.test.ts
│   ├── DeclaredAwsIamUserAccessKey.ts
│   └── DeclaredAwsIamUserAccessKey.test.ts
├── domain.operations/
│   ├── iamUser/
│   │   ├── getAllIamUsers.ts
│   │   ├── getAllIamUsers.test.ts
│   │   ├── getOneIamUser.ts
│   │   ├── getOneIamUser.test.ts
│   │   └── castIntoDeclaredAwsIamUser.ts
│   └── iamUserAccessKey/
│       ├── getAllIamUserAccessKeys.ts
│       ├── getAllIamUserAccessKeys.test.ts
│       ├── getOneIamUserAccessKey.ts
│       ├── getOneIamUserAccessKey.test.ts
│       ├── setIamUserAccessKey.ts
│       ├── setIamUserAccessKey.test.ts
│       ├── delIamUserAccessKey.ts
│       ├── delIamUserAccessKey.test.ts
│       └── castIntoDeclaredAwsIamUserAccessKey.ts
└── access/
    └── daos/
        ├── DeclaredAwsIamUserDao.ts
        └── DeclaredAwsIamUserAccessKeyDao.ts
```

---

## Wish Fulfillment Example

```typescript
// Get all access keys in an account and mark for deletion
const accessKeys = await getAllIamUserAccessKeys(
  { by: { account: { id: '123456789012' } } },
  context,
);

// Mark each for deletion using declastruct's del() pattern
const toDelete = accessKeys.map((key) => del(key));

// Declastruct will invoke dao.delete for each
await declastruct.apply(toDelete, context);
```

---

## AWS SDK Mapping

| Domain Operation | AWS API |
|------------------|---------|
| `getAllIamUsers` | `ListUsers` |
| `getOneIamUser` | `GetUser` |
| `getAllIamUserAccessKeys` | `ListAccessKeys` + `GetAccessKeyLastUsed` |
| `getOneIamUserAccessKey` | `ListAccessKeys` (filtered) + `GetAccessKeyLastUsed` |
| `setIamUserAccessKey` | `UpdateAccessKey` |
| `delIamUserAccessKey` | `DeleteAccessKey` |

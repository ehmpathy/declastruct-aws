# Blueprint: Log Retention Policies Implementation

> **Wish**: Set log retention policies for all log groups that currently exist

---

## Overview

This blueprint describes the implementation plan for enabling declarative log group management with retention policies, following the patterns established in this repository.

---

## Phase 1: Domain Object Changes

### 1.1 Update `DeclaredAwsLogGroup`

**File**: `src/domain.objects/DeclaredAwsLogGroup.ts`

**Change**: Remove `retentionInDays` from the `readonly` array to make it settable.

```diff
  public static readonly = [
    'storedBytes',
    'createdAt',
-   'retentionInDays',
  ] as const;
```

**Why**: Currently `retentionInDays` is marked as readonly, meaning declastruct will not consider changes to this field when diffing desired vs actual state. To enable retention policy management, this field must be settable.

---

## Phase 2: Domain Operation

### 2.1 Create `setLogGroup`

**File**: `src/domain.operations/logGroup/setLogGroup.ts`

**Pattern Reference**: `src/domain.operations/iamRole/setIamRole.ts`

**Implementation**:

```ts
import {
  CloudWatchLogsClient,
  CreateLogGroupCommand,
  PutRetentionPolicyCommand,
  DeleteRetentionPolicyCommand,
} from '@aws-sdk/client-cloudwatch-logs';
import { asProcedure } from 'as-procedure';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { HasReadonly } from 'domain-objects';
import type { PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import type { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import type { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';
import { getOneLogGroup } from './getOneLogGroup';

/**
 * .what = creates or updates a log group
 * .why = enables declarative log group management with retention policies
 *
 * .note
 *   - findsert: creates if not found, returns foundBefore if found
 *   - upsert: creates if not found, updates retention if found
 *   - CreateLogGroupCommand for new log groups
 *   - PutRetentionPolicyCommand / DeleteRetentionPolicyCommand for retention
 *   - logGroupClass cannot be changed after creation (AWS limitation)
 */
export const setLogGroup = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredAwsLogGroup;
      upsert: DeclaredAwsLogGroup;
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogGroup>> => {
    const logGroupDesired = input.findsert ?? input.upsert;

    // create client
    const logs = new CloudWatchLogsClient({
      region: context.aws.credentials.region,
    });

    // check if log group already exists
    const foundBefore = await getOneLogGroup(
      { by: { unique: { name: logGroupDesired.name } } },
      context,
    );

    // handle findsert: if found, return it
    if (foundBefore && input.findsert) return foundBefore;

    // create log group if not found
    if (!foundBefore) {
      await logs.send(
        new CreateLogGroupCommand({
          logGroupName: logGroupDesired.name,
          logGroupClass: logGroupDesired.class,
          kmsKeyId: logGroupDesired.kmsKeyId ?? undefined,
        }),
      );
    }

    // set or delete retention policy (for both new and found)
    if (logGroupDesired.retentionInDays !== undefined) {
      // skip if retention hasn't changed (optimization for upsert)
      const retentionChanged =
        !foundBefore ||
        foundBefore.retentionInDays !== logGroupDesired.retentionInDays;

      if (retentionChanged) {
        if (logGroupDesired.retentionInDays !== null) {
          // set retention
          await logs.send(
            new PutRetentionPolicyCommand({
              logGroupName: logGroupDesired.name,
              retentionInDays: logGroupDesired.retentionInDays,
            }),
          );
        } else {
          // delete retention (never expire)
          await logs.send(
            new DeleteRetentionPolicyCommand({
              logGroupName: logGroupDesired.name,
            }),
          );
        }
      }
    }

    // fetch and return the log group
    const foundAfter = await getOneLogGroup(
      { by: { unique: { name: logGroupDesired.name } } },
      context,
    );

    if (!foundAfter)
      UnexpectedCodePathError.throw('log group not found after set', {
        logGroupDesired,
      });

    return foundAfter;
  },
);
```

### 2.2 Create `setLogGroup.test.ts`

**File**: `src/domain.operations/logGroup/setLogGroup.test.ts`

**Pattern Reference**: `src/domain.operations/iamRole/setIamRole.test.ts`

**Test Cases**:

```ts
import {
  CloudWatchLogsClient,
  CreateLogGroupCommand,
  PutRetentionPolicyCommand,
  DeleteRetentionPolicyCommand,
} from '@aws-sdk/client-cloudwatch-logs';
import { given, then, when } from 'test-fns';

import { getSampleAwsApiContext } from '../../.test/getSampleAwsApiContext';
import type { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';
import * as getOneLogGroupModule from './getOneLogGroup';
import { setLogGroup } from './setLogGroup';

jest.mock('@aws-sdk/client-cloudwatch-logs');
jest.mock('./getOneLogGroup');

const mockSend = jest.fn();
(CloudWatchLogsClient as jest.Mock).mockImplementation(() => ({
  send: mockSend,
}));

const context = getSampleAwsApiContext();

const logGroupSample: DeclaredAwsLogGroup = {
  name: '/aws/lambda/test-function',
  class: 'STANDARD',
  kmsKeyId: null,
  retentionInDays: 30,
};

describe('setLogGroup', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  given('a log group that does not exist', () => {
    when('findsert is called', () => {
      then('it should create the log group and set retention', async () => {
        (getOneLogGroupModule.getOneLogGroup as jest.Mock)
          .mockResolvedValueOnce(null) // foundBefore
          .mockResolvedValueOnce({
            ...logGroupSample,
            arn: 'arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/test-function',
          }); // foundAfter

        mockSend.mockResolvedValue({});

        const result = await setLogGroup({ findsert: logGroupSample }, context);

        expect(result.name).toBe('/aws/lambda/test-function');
        expect(mockSend).toHaveBeenCalledWith(expect.any(CreateLogGroupCommand));
        expect(mockSend).toHaveBeenCalledWith(expect.any(PutRetentionPolicyCommand));
      });
    });

    when('upsert is called', () => {
      then('it should create the log group and set retention', async () => {
        (getOneLogGroupModule.getOneLogGroup as jest.Mock)
          .mockResolvedValueOnce(null) // foundBefore
          .mockResolvedValueOnce({
            ...logGroupSample,
            arn: 'arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/test-function',
          }); // foundAfter

        mockSend.mockResolvedValue({});

        const result = await setLogGroup({ upsert: logGroupSample }, context);

        expect(result.name).toBe('/aws/lambda/test-function');
        expect(mockSend).toHaveBeenCalledWith(expect.any(CreateLogGroupCommand));
        expect(mockSend).toHaveBeenCalledWith(expect.any(PutRetentionPolicyCommand));
      });
    });
  });

  given('a log group that already exists', () => {
    when('findsert is called', () => {
      then('it should return the found log group (idempotent)', async () => {
        const foundLogGroup = {
          ...logGroupSample,
          arn: 'arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/test-function',
        };
        (getOneLogGroupModule.getOneLogGroup as jest.Mock).mockResolvedValue(foundLogGroup);

        const result = await setLogGroup({ findsert: logGroupSample }, context);

        expect(result).toBe(foundLogGroup);
        expect(mockSend).not.toHaveBeenCalled();
      });
    });

    when('upsert is called with different retention', () => {
      then('it should update the retention policy', async () => {
        const foundLogGroup = {
          ...logGroupSample,
          retentionInDays: 14, // different from desired 30
          arn: 'arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/test-function',
        };
        (getOneLogGroupModule.getOneLogGroup as jest.Mock)
          .mockResolvedValueOnce(foundLogGroup) // foundBefore
          .mockResolvedValueOnce({ ...foundLogGroup, retentionInDays: 30 }); // foundAfter

        mockSend.mockResolvedValue({});

        const result = await setLogGroup({ upsert: logGroupSample }, context);

        expect(result.retentionInDays).toBe(30);
        expect(mockSend).not.toHaveBeenCalledWith(expect.any(CreateLogGroupCommand));
        expect(mockSend).toHaveBeenCalledWith(expect.any(PutRetentionPolicyCommand));
      });
    });

    when('upsert is called with null retention', () => {
      then('it should delete the retention policy', async () => {
        const foundLogGroup = {
          ...logGroupSample,
          retentionInDays: 30,
          arn: 'arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/test-function',
        };
        (getOneLogGroupModule.getOneLogGroup as jest.Mock)
          .mockResolvedValueOnce(foundLogGroup) // foundBefore
          .mockResolvedValueOnce({ ...foundLogGroup, retentionInDays: null }); // foundAfter

        mockSend.mockResolvedValue({});

        const result = await setLogGroup(
          { upsert: { ...logGroupSample, retentionInDays: null } },
          context,
        );

        expect(result.retentionInDays).toBe(null);
        expect(mockSend).toHaveBeenCalledWith(expect.any(DeleteRetentionPolicyCommand));
      });
    });

    when('upsert is called with same retention', () => {
      then('it should skip updating retention (no-op)', async () => {
        const foundLogGroup = {
          ...logGroupSample,
          arn: 'arn:aws:logs:us-east-1:123456789012:log-group:/aws/lambda/test-function',
        };
        (getOneLogGroupModule.getOneLogGroup as jest.Mock)
          .mockResolvedValueOnce(foundLogGroup) // foundBefore
          .mockResolvedValueOnce(foundLogGroup); // foundAfter

        const result = await setLogGroup({ upsert: logGroupSample }, context);

        expect(result.retentionInDays).toBe(30);
        expect(mockSend).not.toHaveBeenCalled();
      });
    });
  });
});
```

---

## Phase 3: DAO Update

### 3.1 Update `DeclaredAwsLogGroupDao`

**File**: `src/access/daos/DeclaredAwsLogGroupDao.ts`

**Change**: Replace the throwing `set.findsert` with actual implementations using `setLogGroup`.

```ts
import { DeclastructDao } from 'declastruct';
import { isRefByPrimary, isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';
import { getOneLogGroup } from '../../domain.operations/logGroup/getOneLogGroup';
import { setLogGroup } from '../../domain.operations/logGroup/setLogGroup';

export const DeclaredAwsLogGroupDao = new DeclastructDao<
  DeclaredAwsLogGroup,
  typeof DeclaredAwsLogGroup,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      return getOneLogGroup({ by: { primary: input } }, context);
    },
    byUnique: async (input, context) => {
      return getOneLogGroup({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    findsert: async (input, context) => {
      return setLogGroup({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setLogGroup({ upsert: input }, context);
    },
  },
});
```

---

## Phase 4: SDK Exports

### 4.1 Update `src/contract/sdks/index.ts`

**Change**: Add export for `setLogGroup`.

```diff
  // aws log group operations
  export { getOneLogGroup } from '../../domain.operations/logGroup/getOneLogGroup';
  export { getAllLogGroups } from '../../domain.operations/logGroup/getAllLogGroups';
+ export { setLogGroup } from '../../domain.operations/logGroup/setLogGroup';
```

---

## Phase 5: Integration Testing

### 5.1 Create `setLogGroup.integration.test.ts`

**File**: `src/domain.operations/logGroup/setLogGroup.integration.test.ts`

**Pattern Reference**: `src/domain.operations/iamRole/setIamRole.integration.test.ts`

**Test Cases**:
1. Create a new log group with retention
2. Update retention on an existing log group
3. Remove retention (set to null)
4. Verify findsert idempotency
5. Verify class cannot be changed after creation

---

## Phase 6: Acceptance Testing

### 6.1 Update `resources.acceptance.ts`

**File**: `src/contract/sdks/.test/assets/resources.acceptance.ts`

**Change**: Add a log group with retention policy to the resources.

```diff
  import {
    calcCodeSha256,
    calcConfigSha256,
    DeclaredAwsIamRole,
    DeclaredAwsIamRolePolicy,
    DeclaredAwsLambda,
    DeclaredAwsLambdaAlias,
    DeclaredAwsLambdaVersion,
    DeclaredAwsLogGroup,
    DeclaredAwsLogGroupReportCostOfIngestion,
    DeclaredAwsLogGroupReportDistOfPattern,
    DeclaredAwsVpcTunnel,
    getDeclastructAwsProvider,
  } from '../../../../../dist/contract/sdks';

  // ... existing code ...

  export const getResources = async () => {
    // ... existing resources ...

+   // declare log group with retention policy
+   const logGroupWithRetention = DeclaredAwsLogGroup.as({
+     name: '/declastruct/acceptance-test/with-retention',
+     class: 'STANDARD',
+     kmsKeyId: null,
+     retentionInDays: 14,
+   });

    return [
      tunnel,
      lambdaRole,
      lambdaRolePolicy,
      lambda,
      lambdaVersion,
      lambdaAlias,
+     logGroupWithRetention,
      logGroupReportDistOfPattern,
      logGroupReportCostOfIngestion,
    ];
  };
```

### 6.2 Update `declastruct.acceptance.test.ts`

**File**: `src/contract/sdks/declastruct.acceptance.test.ts`

**Change**: Add test cases for log group with retention.

```ts
// Add to 'when generating a plan via declastruct CLI' block
then('plan includes log group with retention resource', () => {
  /**
   * .what = validates plan includes log group with retention declaration
   * .why = ensures log group retention management is captured in plan
   */
  const logGroupChange = prep.plan.changes.find(
    (r: DeclastructChange) =>
      r.forResource.class === 'DeclaredAwsLogGroup' &&
      r.forResource.slug.includes('with-retention'),
  );
  expect(logGroupChange).toBeDefined();
});

// Add to 'when applying a plan via declastruct CLI' block
then('creates log group with retention policy', () => {
  /**
   * .what = validates log group is created with retention via declastruct
   * .why = ensures setLogGroup operation works through declastruct workflow
   */
  const logGroupChange = prep.plan.changes.find(
    (r: DeclastructChange) =>
      r.forResource.class === 'DeclaredAwsLogGroup' &&
      r.forResource.slug.includes('with-retention'),
  );
  expect(logGroupChange).toBeDefined();
});

// Add new 'when' block after 'when applying a plan via declastruct CLI'
// This block re-plans after apply to verify all resources show KEEP
when('re-planning after apply to verify idempotency', () => {
  const verifyPlanFile = join(testDir, 'plan-verify.json');

  const prep = useBeforeAll(async () => {
    // generate a fresh plan after apply — if everything was applied correctly,
    // all resources should show "KEEP" (no changes needed)
    execSync(
      `npx declastruct plan --wish ${resourcesFile} --into ${verifyPlanFile}`,
      { stdio: 'inherit', env: process.env },
    );

    return {
      plan: JSON.parse(readFileSync(verifyPlanFile, 'utf-8')) as {
        changes: DeclastructChange[];
      },
    };
  });

  then('all resources show KEEP after apply', () => {
    /**
     * .what = validates all resources were applied correctly
     * .why = ensures idempotency — applying same plan twice results in no changes
     */
    const nonKeepChanges = prep.plan.changes.filter(
      (r: DeclastructChange) => r.willDo !== 'KEEP',
    );
    expect(nonKeepChanges).toHaveLength(0);
  });

  then('log group with retention shows KEEP', () => {
    /**
     * .what = validates log group was applied correctly by checking re-plan shows KEEP
     * .why = proves the resource matches desired state after apply
     */
    const logGroupChange = prep.plan.changes.find(
      (r: DeclastructChange) =>
        r.forResource.class === 'DeclaredAwsLogGroup' &&
        r.forResource.slug.includes('with-retention'),
    );
    expect(logGroupChange).toBeDefined();
    expect(logGroupChange!.willDo).toBe('KEEP');
  });
});
```

### 6.3 Running Acceptance Tests

```sh
# Source AWS profile
source .agent/repo=.this/skills/use.demo.awsprofile.sh

# Build the project (acceptance tests use dist/)
npm run build

# Run acceptance tests
npm run test:acceptance
```

---

## Implementation Order

| Step | File                                                             | Action                                          |
| ---- | ---------------------------------------------------------------- | ----------------------------------------------- |
| 1    | `src/domain.objects/DeclaredAwsLogGroup.ts`                      | Remove `retentionInDays` from `readonly`        |
| 2    | `src/domain.operations/logGroup/setLogGroup.ts`                  | Create new operation                            |
| 3    | `src/domain.operations/logGroup/setLogGroup.test.ts`             | Create unit tests                               |
| 4    | `src/access/daos/DeclaredAwsLogGroupDao.ts`                      | Update DAO with `set.findsert` and `set.upsert` |
| 5    | `src/contract/sdks/index.ts`                                     | Export `setLogGroup`                            |
| 6    | `src/domain.operations/logGroup/setLogGroup.integration.test.ts` | Create integration tests                        |
| 7    | `src/contract/sdks/.test/assets/resources.acceptance.ts`         | Add log group with retention                    |
| 8    | `src/contract/sdks/declastruct.acceptance.test.ts`               | Add acceptance test cases                       |

---

## Verification Checklist

- [ ] `DeclaredAwsLogGroup.readonly` no longer includes `retentionInDays`
- [ ] `setLogGroup` handles findsert (create if not found, return foundBefore if found)
- [ ] `setLogGroup` handles upsert (create if not found, update retention if found)
- [ ] `setLogGroup` correctly calls `CreateLogGroupCommand` for new log groups
- [ ] `setLogGroup` correctly calls `PutRetentionPolicyCommand` to set retention
- [ ] `setLogGroup` correctly calls `DeleteRetentionPolicyCommand` to remove retention
- [ ] `setLogGroup` skips retention update when value unchanged (optimization)
- [ ] `DeclaredAwsLogGroupDao.set.findsert` delegates to `setLogGroup`
- [ ] `DeclaredAwsLogGroupDao.set.upsert` delegates to `setLogGroup`
- [ ] `setLogGroup` is exported from `contract/sdks/index.ts`
- [ ] All unit tests pass
- [ ] Integration tests pass against real AWS (optional)
- [ ] Acceptance test resources include log group with retention
- [ ] Acceptance test plan includes `DeclaredAwsLogGroup` resource
- [ ] Acceptance test apply creates log group with retention
- [ ] Acceptance test re-plan shows `KEEP` for log group (proves apply worked)
- [ ] Acceptance test re-plan shows `KEEP` for all resources (idempotency)

---

## Notes

### AWS Limitations
- `logGroupClass` cannot be changed after creation — the operation should not attempt to update it
- Retention changes may take up to 72 hours to take effect on log deletion
- Valid `retentionInDays` values: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, 3653

### Patterns Followed
- `setLogGroup` follows the same pattern as `setIamRole` and `setLambda`
- Uses `foundBefore` / `foundAfter` naming convention
- Uses `asProcedure` wrapper for operation
- Uses `PickOne<{ findsert, upsert }>` input pattern
- Returns `HasReadonly<typeof DeclaredAwsLogGroup>`

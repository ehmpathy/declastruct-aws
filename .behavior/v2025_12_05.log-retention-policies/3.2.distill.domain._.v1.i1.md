# Domain Distillation: Log Retention Policies

> **Wish**: Set log retention policies for all log groups that currently exist

---

## 1. Usecases & Contract Envisioned

### Usecase 1: Set retention policy on existing log groups

```ts
// contract envisioned
export const getResources = async () => {
  // get all lambda log groups
  const logGroupsFound = await getAllLogGroups({ by: { prefix: '/aws/lambda/' }});

  // set retention policy for each — update the log group's retentionInDays attribute
  const logGroupsWithRetention = logGroupsFound.map((logGroup) =>
    new DeclaredAwsLogGroup({
      ...logGroup,
      retentionInDays: 30, // desired retention
    })
  );

  return [...logGroupsWithRetention];
};
```

### Usecase 2: Create new log groups with retention policy

```ts
// contract envisioned
export const getResources = async () => {
  // declare a new log group with retention
  const customLogGroup = new DeclaredAwsLogGroup({
    name: '/custom/my-app/logs',
    class: 'STANDARD',
    kmsKeyId: null,
    retentionInDays: 14,
  });

  return [customLogGroup];
};
```

### Usecase 3: Remove retention policy (set to never expire)

```ts
// contract envisioned
export const getResources = async () => {
  const logGroupsFound = await getAllLogGroups({ by: { prefix: '/aws/lambda/' }});

  // set retention to null = never expire
  const logGroupsNeverExpire = logGroupsFound.map((logGroup) =>
    new DeclaredAwsLogGroup({
      ...logGroup,
      retentionInDays: null, // never expire
    })
  );

  return [...logGroupsNeverExpire];
};
```

### Key Insight from Research

AWS exposes these operations for log groups:
- `CreateLogGroup` — creates a new log group with optional kmsKeyId, logGroupClass, tags
- `PutRetentionPolicy` — sets retentionInDays on an existing log group
- `DeleteRetentionPolicy` — removes retention (logs never expire)

This means:
- **No new domain object needed** — `DeclaredAwsLogGroup` already has all required fields
- **Change required**: Move `retentionInDays` from `readonly` to a settable attribute
- **New operation needed**: `setLogGroup` to handle both creation and retention updates

---

## 2. Domain Objects

### Existing: `DeclaredAwsLogGroup`

**Current state** (`src/domain.objects/DeclaredAwsLogGroup.ts`):
```ts
export interface DeclaredAwsLogGroup {
  arn?: string;                              // @metadata
  name: string;                              // @unique
  class: 'STANDARD' | 'INFREQUENT_ACCESS' | 'DELIVERY';
  kmsKeyId: string | null;
  retentionInDays?: number | null;           // @readonly (currently)
  createdAt?: UniDateTime;                   // @readonly
  storedBytes?: number;                      // @readonly
}

export class DeclaredAwsLogGroup extends DomainEntity<DeclaredAwsLogGroup> {
  public static primary = ['arn'] as const;
  public static unique = ['name'] as const;
  public static metadata = ['arn'] as const;
  public static readonly = ['storedBytes', 'createdAt', 'retentionInDays'] as const;
  //                                                    ^^^^^^^^^^^^^^^^ REMOVE
}
```

**Required change**: Remove `retentionInDays` from `readonly` array to make it settable.

```ts
// AFTER
public static readonly = ['storedBytes', 'createdAt'] as const;
```

### New Literal: `RetentionInDays`

Define the valid values as a type for compile-time safety:

```ts
// src/domain.objects/literals/RetentionInDays.ts
/**
 * .what = valid retention period values for CloudWatch Log Groups
 * .why = AWS only accepts specific values, not arbitrary numbers
 * .ref = https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html
 */
export type RetentionInDays =
  | 1 | 3 | 5 | 7           // days
  | 14                       // 2 weeks
  | 30 | 60 | 90             // 1-3 months
  | 120 | 150 | 180          // 4-6 months
  | 365                      // 1 year
  | 400 | 545                // ~13-18 months
  | 731                      // 2 years
  | 1096                     // 3 years
  | 1827                     // 5 years
  | 2192 | 2557 | 2922 | 3288 // 6-9 years
  | 3653;                    // 10 years

export const RETENTION_IN_DAYS_VALUES = [
  1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180,
  365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, 3653,
] as const;
```

---

## 3. Domain Operations

### Existing Operations (no changes needed)

| Operation         | File                                                | Purpose                                     |
| ----------------- | --------------------------------------------------- | ------------------------------------------- |
| `getOneLogGroup`  | `src/domain.operations/logGroup/getOneLogGroup.ts`  | Get single log group by ARN or name         |
| `getAllLogGroups` | `src/domain.operations/logGroup/getAllLogGroups.ts` | List log groups with optional prefix filter |

### New Operation: `setLogGroup`

Handles both creation (findsert) and updates (upsert) including retention policy.

```ts
// src/domain.operations/logGroup/setLogGroup.ts

import {
  CloudWatchLogsClient,
  CreateLogGroupCommand,
  PutRetentionPolicyCommand,
  DeleteRetentionPolicyCommand,
} from '@aws-sdk/client-cloudwatch-logs';
import { asProcedure } from 'as-procedure';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { HasReadonly } from 'domain-objects';
import type { PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import type { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import type { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';
import { getOneLogGroup } from './getOneLogGroup';

/**
 * .what = creates or updates a log group
 * .why = enables declarative log group management with retention policies
 *
 * .note
 *   - findsert: creates if not exists, returns existing if found
 *   - upsert: creates if not exists, updates retention if found
 *   - CreateLogGroupCommand for new log groups
 *   - PutRetentionPolicyCommand / DeleteRetentionPolicyCommand for retention
 *   - logGroupClass cannot be changed after creation (AWS limitation)
 */
export const setLogGroup = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredAwsLogGroup;
      upsert: DeclaredAwsLogGroup;
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogGroup>> => {
    const logGroupDesired = input.findsert ?? input.upsert;

    // create client
    const logs = new CloudWatchLogsClient({
      region: context.aws.credentials.region,
    });

    // check if log group already exists
    const foundBefore = await getOneLogGroup(
      { by: { unique: { name: logGroupDesired.name } } },
      context,
    );

    // handle findsert: if found, return it
    if (foundBefore && input.findsert) return foundBefore;

    // create log group if not found
    if (!foundBefore) {
      await logs.send(
        new CreateLogGroupCommand({
          logGroupName: logGroupDesired.name,
          logGroupClass: logGroupDesired.class,
          kmsKeyId: logGroupDesired.kmsKeyId ?? undefined,
        }),
      );
    }

    // set or delete retention policy (for both new and existing)
    if (logGroupDesired.retentionInDays !== undefined) {
      if (logGroupDesired.retentionInDays !== null) {
        // set retention
        await logs.send(
          new PutRetentionPolicyCommand({
            logGroupName: logGroupDesired.name,
            retentionInDays: logGroupDesired.retentionInDays,
          }),
        );
      } else {
        // delete retention (never expire)
        await logs.send(
          new DeleteRetentionPolicyCommand({
            logGroupName: logGroupDesired.name,
          }),
        );
      }
    }

    // fetch and return the log group
    const foundAfter = await getOneLogGroup(
      { by: { unique: { name: logGroupDesired.name } } },
      context,
    );

    if (!foundAfter)
      UnexpectedCodePathError.throw('log group not found after set', {
        logGroupDesired,
      });

    return foundAfter;
  },
);
```

---

## 4. Access DAOs

### Update: `DeclaredAwsLogGroupDao`

**Current state** (`src/access/daos/DeclaredAwsLogGroupDao.ts`):
- Has `get.byPrimary`, `get.byUnique`, `get.byRef`
- Has `set.findsert` that throws (log groups are auto-created)

**Required change**: Implement `set.findsert` and `set.upsert` using `setLogGroup`:

```ts
// src/access/daos/DeclaredAwsLogGroupDao.ts

import { DeclastructDao } from 'declastruct';
import { isRefByPrimary, isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';
import { getOneLogGroup } from '../../domain.operations/logGroup/getOneLogGroup';
import { setLogGroup } from '../../domain.operations/logGroup/setLogGroup';

export const DeclaredAwsLogGroupDao = new DeclastructDao<
  DeclaredAwsLogGroup,
  typeof DeclaredAwsLogGroup,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      return getOneLogGroup({ by: { primary: input } }, context);
    },
    byUnique: async (input, context) => {
      return getOneLogGroup({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    findsert: async (input, context) => {
      return setLogGroup({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setLogGroup({ upsert: input }, context);
    },
  },
});
```

---

## 5. SDK Exports

Add the new operation to `src/contract/sdks/index.ts`:

```ts
// aws log group operations
export { getOneLogGroup } from '../../domain.operations/logGroup/getOneLogGroup';
export { getAllLogGroups } from '../../domain.operations/logGroup/getAllLogGroups';
export { setLogGroup } from '../../domain.operations/logGroup/setLogGroup'; // NEW
```

---

## 6. Summary of Changes

| Type                 | File                          | Change                                                        |
| -------------------- | ----------------------------- | ------------------------------------------------------------- |
| **domain.object**    | `DeclaredAwsLogGroup.ts`      | Remove `retentionInDays` from `readonly` array                |
| **literal**          | `literals/RetentionInDays.ts` | **NEW** — type-safe retention values                          |
| **domain.operation** | `logGroup/setLogGroup.ts`     | **NEW** — create/update log groups with retention             |
| **access.dao**       | `DeclaredAwsLogGroupDao.ts`   | Implement `set.findsert` and `set.upsert` using `setLogGroup` |
| **sdk**              | `contract/sdks/index.ts`      | Export `setLogGroup`                                          |

---

## 7. Final Contract Examples

### Example 1: Update retention on existing log groups

```ts
import {
  getAllLogGroups,
  DeclaredAwsLogGroup,
} from 'declastruct-aws';

export const getResources = async () => {
  // get all lambda log groups
  const logGroupsFound = await getAllLogGroups({ by: { prefix: '/aws/lambda/' } });

  // declare desired state with 30-day retention
  const logGroupsWithRetention = logGroupsFound.map(
    (logGroup) =>
      new DeclaredAwsLogGroup({
        ...logGroup,
        retentionInDays: 30,
      }),
  );

  return [...logGroupsWithRetention];
};

// declastruct will diff current vs desired and call upsert for changes
```

### Example 2: Create new log group with retention

```ts
import { DeclaredAwsLogGroup } from 'declastruct-aws';

export const getResources = async () => {
  // declare a new log group
  const customLogGroup = new DeclaredAwsLogGroup({
    name: '/custom/my-app/logs',
    class: 'STANDARD',
    kmsKeyId: null,
    retentionInDays: 14,
  });

  return [customLogGroup];
};

// declastruct will call findsert to create if not exists
```

---

## 8. AWS API Reference

### CreateLogGroup

- Creates a new log group
- Parameters: `logGroupName` (required), `logGroupClass`, `kmsKeyId`, `tags`
- Note: `logGroupClass` cannot be changed after creation
- Ref: https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CreateLogGroup.html

### PutRetentionPolicy

- Sets retention on an existing log group
- Parameters: `logGroupName` (required), `retentionInDays` (required)
- Valid values: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, 3653
- Ref: https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html

### DeleteRetentionPolicy

- Removes retention policy (logs never expire)
- Parameters: `logGroupName` (required)
- Ref: https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html

---

This fulfills the wish: users can now declaratively create log groups and set retention policies via the declastruct pattern.

# blueprint: simplified getOneAccount

## design principles

1. **narrative flow** - flat, no nested if/else, early returns only
2. **try first, handle errors** - don't pre-check org; just try the operation
3. **single responsibility** - main function routes, helpers do work
4. **graceful degradation** - return what we can, null org for standalone

---

## simplified approach

### by.auth

```
1. get account id from context.aws.credentials.account
2. call getAccountById(accountId)
```

### by.id (primary)

```
1. try DescribeAccount
   - success → cast and return full account
   - AccessDeniedException → return minimal account (standalone)
   - AccountNotFoundException → return minimal account
   - AWSOrganizationsNotInUseException → return minimal account (standalone)

2. try ListTagsForResource (if we got full account)
   - success → attach tags
   - error → tags = null
```

### by.email (unique)

```
1. try ListAccounts (paginated)
   - find account where Email === email
   - found → try DescribeAccount to get full details + tags
   - not found → return null

2. handle errors
   - AccessDeniedException → return null (can't search without org access)
   - AWSOrganizationsNotInUseException → return null (standalone, no email search)
```

### by.ref

```
1. if ref has 'id' → route to by.id
2. if ref has 'email' → route to by.email
3. else → throw UnexpectedCodePathError
```

---

## narrative flow for getOneAccount

```ts
export const getOneAccount = async (input, context) => {
  // route by.ref to appropriate handler
  if (input.by.ref) {
    if (isRefByPrimary(...)) return getOneAccount({ by: { primary: input.by.ref } }, context);
    if (isRefByUnique(...)) return getOneAccount({ by: { unique: input.by.ref } }, context);
    throw UnexpectedCodePathError(...);
  }

  // by.unique requires search
  if (input.by.unique) return findAccountByEmail(input.by.unique.email, context);

  // by.auth or by.primary - resolve to account id
  const accountId = input.by.auth
    ? context.aws.credentials.account
    : input.by.primary?.id;
  if (!accountId) return null;

  // get account by id
  return getAccountById(accountId, context);
};
```

---

## helper: getAccountById

```ts
const getAccountById = async (accountId, context) => {
  const client = new OrganizationsClient({ region: context.aws.credentials.region });

  // try to get full account details
  try {
    const response = await client.send(new DescribeAccountCommand({ AccountId: accountId }));
    if (!response.Account) return createMinimalAccount(accountId);

    // try to get tags
    const tags = await getTagsForAccount(accountId, client);

    // get organization info
    const organization = await getOneOrganization({ by: { auth: true } }, context);

    return castIntoDeclaredAwsAccount({
      account: response.Account,
      organization,
      tags,
    });
  } catch (error) {
    if (!(error instanceof Error)) throw error;

    // standalone or no access - return minimal
    if (error.name === 'AccessDeniedException') return createMinimalAccount(accountId);
    if (error.name === 'AccountNotFoundException') return createMinimalAccount(accountId);
    if (error.name === 'AWSOrganizationsNotInUseException') return createMinimalAccount(accountId);

    throw new HelpfulError('getAccountById error', { cause: error });
  }
};
```

---

## helper: findAccountByEmail

```ts
const findAccountByEmail = async (email, context) => {
  const client = new OrganizationsClient({ region: context.aws.credentials.region });

  try {
    let nextToken: string | undefined;
    do {
      const response = await client.send(new ListAccountsCommand({ NextToken: nextToken }));

      const found = response.Accounts?.find((acc) => acc.Email === email);
      if (found) {
        // get full details via getAccountById
        return found.Id ? getAccountById(found.Id, context) : null;
      }

      nextToken = response.NextToken;
    } while (nextToken);

    return null;
  } catch (error) {
    if (!(error instanceof Error)) throw error;

    // no org access - can't search by email
    if (error.name === 'AccessDeniedException') return null;
    if (error.name === 'AWSOrganizationsNotInUseException') return null;

    throw new HelpfulError('findAccountByEmail error', { cause: error });
  }
};
```

---

## helper: createMinimalAccount

```ts
const createMinimalAccount = (accountId: string) => {
  return castIntoDeclaredAwsAccount({
    account: {
      Id: accountId,
      Arn: `arn:aws:iam::${accountId}:root`,
      Name: accountId,
      Email: `${accountId}@unknown`,
      Status: 'ACTIVE',
    },
    organization: null,
    tags: null,
  });
};
```

---

## key simplifications

1. **removed getOneOrganization pre-check**
   - old: check org first, then decide path
   - new: just try the operation, handle errors

2. **unified error handling**
   - all "no org" errors → return minimal account (for by.id) or null (for by.email)

3. **reuse getAccountById in findAccountByEmail**
   - after finding by email, delegate to getAccountById for full hydration
   - avoids duplicate logic

4. **flatter structure**
   - main function just routes
   - helpers do the actual work
   - no nested conditionals

emit your response to the feedback into
- .behavior/v2025_12_05.aws-account-provision/5.1.execution.phase0_to_phaseN.v1.i1.md.[feedback].v1.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---
---
---


# blocker.1

where are the unit tests?

# blocker.2

where is the acceptance test, that proves the usecase works?

# blocker.3


export const setOrganization = asProcedure(
  async (
    input: PickOne<{
      findsert: Pick<DeclaredAwsOrganization, 'featureSet'>;
      // Note: upsert not supported â€” organizations cannot be updated
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsOrganization>> => {
    // check if already exists (idempotent findsert)
    const existing = await getOneOrganization({}, context);
    if (existing) return existing;


NEVER USE TERM `existing`! always `foundBefore` or `foundAfter`. never `existing`


# blocker.4

setOrganization should verify that the desired DeclaredAwsOrganization.managementAccount === the currently authed account

also, it should not Pick<DeclaredAwsOrganization, 'featureSet'>;

it should be given a full DeclaredAwsOrganization

# blocker.5

getOneOrganization should operate based on findByUnique or findByPrimary just like every other `get` in this repo; dont makeup new patterns. be consistent


# blocker.6

delOrganization should validate that the desired organization to delete (byUnique or byPrimary, exactly the same input that the dao requires as input)

is the aws account that the request will be issued under

and fail fast if not

because the request is inconsistent and impossible => maximize safety

right now you're issuing dangerous mutations blindly without any double checks


export const delOrganization = asProcedure(
  async (
    _input: Record<string, never>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<{ deleted: true }> => {
    // check if exists (idempotent)
    const existing = await getOneOrganization({}, context);
    if (!existing) return { deleted: true };

    // declare the client (Organizations API is global, always use us-east-1)
    const client = new OrganizationsClient({ region: 'us-east-1' });


input should be, just like every other del


      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsOrganization>;
        unique: RefByUnique<typeof DeclaredAwsOrganization>;
        ref: Ref<typeof DeclaredAwsOrganization>;
      }>;


# blocker.7


    // declare the client (Organizations API is global, always use us-east-1)
    const client = new OrganizationsClient({ region: 'us-east-1' });

  client region should be pulled from context

  find or reuse a generic getAwsClient procedure which fetches the client given a context object


# blocker.8

setOrganizationAccount must validate that the orgnization of the current account matches the organization that the account was asked to be created in

dont just blindly issue mutations that may not match the intent of the request

always sanity check your callers and failfast to produce a pit of success

# research: tracking active VPC tunnels per machine

## context

we spawn an `aws ssm start-session` subprocess to create the tunnel. we need to:
1. detect if a reusable tunnel already exists (same target, same local port)
2. check if that tunnel is still alive
3. avoid spawning duplicate tunnels

---

## approaches

### 1. local port check (recommended primary)

check if the local port is already bound. if bound, tunnel is likely active.

**pros**
- simple, fast, deterministic
- no external dependencies
- works regardless of how tunnel was created

**cons**
- doesn't tell us *which* tunnel owns the port
- another process could be using the port (collision)

**implementation options**

| method | notes |
|--------|-------|
| `detect-port` | npm library, returns next free port if specified is busy |
| `tcp-port-used` | npm library, has `check()`, `waitUntilFree()`, `waitUntilUsed()` |
| native `net.Server` | try to listen, catch `EADDRINUSE` |
| `lsof -i :PORT` | shell out, parse output |
| `netstat -tln \| grep :PORT` | shell out, parse output |

**recommended**: use native `net` module for simplicity:

```typescript
import * as net from 'net';

const isPortInUse = async ({ port }: { port: number }): Promise<boolean> => {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.once('error', (err: NodeJS.ErrnoException) => {
      resolve(err.code === 'EADDRINUSE');
    });
    server.once('listening', () => {
      server.close();
      resolve(false);
    });
    server.listen(port, '127.0.0.1');
  });
};
```

sources:
- [detect-port npm](https://www.npmjs.com/package/detect-port)
- [Stack Overflow: check if port is busy in NodeJS](https://stackoverflow.com/questions/19129570/how-can-i-check-if-port-is-busy-in-nodejs)

---

### 2. pidfile + process check

store the tunnel subprocess pid in a file, then verify the process is still running.

**pidfile path convention**
```
~/.declastruct/tunnels/{tunnelId}.pid
```

where `tunnelId` = deterministic hash of `{ instanceId, remoteHost, remotePort, localPort }`

**check process alive**
```typescript
const isProcessAlive = ({ pid }: { pid: number }): boolean => {
  try {
    process.kill(pid, 0); // signal 0 = check existence only
    return true;
  } catch {
    return false;
  }
};
```

**pros**
- tracks exactly which tunnel owns the port
- can store metadata (target, start time, etc.)

**cons**
- stale pidfiles if process crashes without cleanup
- requires file system coordination
- pid can be recycled by OS (unlikely but possible)

sources:
- [Stack Overflow: SSH tunnel PID management](https://unix.stackexchange.com/questions/389014/getting-a-pid-for-an-ssh-process-that-backgrounded-itself)

---

### 3. lock file (atomic coordination)

use a lock file with `flock` semantics to coordinate tunnel ownership.

**how it works**
1. before spawning tunnel, try to acquire lock on `~/.declastruct/tunnels/{tunnelId}.lock`
2. if lock fails → another tunnel owns this slot
3. if lock succeeds → safe to spawn tunnel
4. kernel releases lock automatically on process exit/crash

**implementation**
```typescript
import * as fs from 'fs';

const acquireLock = async ({ lockPath }: { lockPath: string }): Promise<number | null> => {
  const fd = fs.openSync(lockPath, 'w');
  try {
    // node doesn't have native flock, use proper-lockfile or similar
    // or shell out: flock -n $fd || exit 1
  } catch {
    fs.closeSync(fd);
    return null;
  }
  return fd;
};
```

**pros**
- kernel-guaranteed cleanup on crash
- no stale state issues
- atomic coordination

**cons**
- more complex implementation
- cross-platform concerns (flock behavior varies)
- requires npm package like `proper-lockfile`

sources:
- [Reusing UNIX domain socket (SO_REUSEADDR for AF_UNIX)](https://gavv.net/articles/unix-socket-reuse/)
- [Stack Overflow: Unix domain socket process detection](https://stackoverflow.com/questions/7405932/how-to-know-whether-any-process-is-bound-to-a-unix-domain-socket)

---

### 4. AWS SSM describe-sessions (remote check)

query AWS for active sessions to the target instance.

```typescript
import { SSMClient, DescribeSessionsCommand } from "@aws-sdk/client-ssm";

const getActiveSessions = async ({ instanceId }: { instanceId: string }) => {
  const client = new SSMClient({ region: "us-east-1" });
  const response = await client.send(new DescribeSessionsCommand({
    State: "Active",
    Filters: [{ key: "Target", value: instanceId }]
  }));
  return response.Sessions ?? [];
};
```

**pros**
- authoritative source of truth
- shows all sessions (even from other machines)

**cons**
- network latency
- doesn't tell us which local port is bound
- can't distinguish our tunnel from other users' sessions
- logging limitation: port forwarding sessions are not logged with details

sources:
- [AWS CLI describe-sessions reference](https://docs.aws.amazon.com/cli/latest/reference/ssm/describe-sessions.html)
- [AWS SSM describe_sessions boto3](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ssm/client/describe_sessions.html)

---

### 5. SSH ControlMaster pattern (not applicable)

SSH has a ControlMaster feature for reusing connections:
```bash
ssh -o ControlMaster=yes -o ControlPath=/tmp/ssh-%r@%h:%p -O check user@host
```

**not applicable** because:
- we use `aws ssm start-session`, not native SSH
- SSM doesn't support ControlMaster semantics

sources:
- [Stack Overflow: SSH tunnel alive check](https://stackoverflow.com/questions/1998297/ssh-check-if-a-tunnel-is-alive)

---

## recommended strategy

combine approaches 1 + 2 for robust detection:

```
1. check if local port is in use (fast fail)
   - if free → spawn new tunnel
   - if busy → continue to step 2

2. check pidfile for this tunnel configuration
   - if pidfile exists and process alive → reuse existing tunnel
   - if pidfile exists but process dead → clean up, spawn new
   - if no pidfile → another process owns port, fail gracefully
```

**tunnel identity formula**
```typescript
const getTunnelHash = ({ instanceId, remoteHost, remotePort, localPort }) => {
  return crypto
    .createHash('sha256')
    .update(`${instanceId}:${remoteHost}:${remotePort}:${localPort}`)
    .digest('hex')
    .slice(0, 16);
};
```

**file structure**
```
~/.declastruct/tunnels/
├── a1b2c3d4e5f6g7h8.pid      # contains: PID
├── a1b2c3d4e5f6g7h8.meta     # contains: serialize(DeclaredAwsVpcTunnel)
```

---

## edge cases to handle

| case | resolution |
|------|------------|
| process crashes mid-tunnel | pidfile remains, but `process.kill(pid, 0)` fails → cleanup and respawn |
| port collision with non-tunnel process | pidfile doesn't exist → fail with clear error |
| multiple users on same machine | each user has own `~/.declastruct/` directory |
| OS pid recycling | rare, but could check process name/args via `ps` if paranoid |
| tunnel connected but not forwarding | could probe localhost:port with TCP connect to verify |

---

## verification: is tunnel actually forwarding?

port bound ≠ tunnel working. to verify the tunnel is functional:

```typescript
const isTunnelHealthy = async ({ port }: { port: number }): Promise<boolean> => {
  return new Promise((resolve) => {
    const socket = new net.Socket();
    socket.setTimeout(2000);
    socket.once('connect', () => {
      socket.destroy();
      resolve(true);
    });
    socket.once('error', () => resolve(false));
    socket.once('timeout', () => {
      socket.destroy();
      resolve(false);
    });
    socket.connect(port, '127.0.0.1');
  });
};
```

this confirms something is listening and accepting connections.

---

## summary

| approach | speed | reliability | complexity |
|----------|-------|-------------|------------|
| port check | fast | medium | low |
| pidfile | fast | high | medium |
| lock file | fast | very high | high |
| AWS describe-sessions | slow | low (for our use case) | low |
| health probe | medium | high | low |

**recommendation**: use **port check + pidfile + health probe** for the best balance of simplicity and reliability.

sources:
- [List open SSH tunnels](https://superuser.com/questions/248389/list-open-ssh-tunnels)
- [Server Fault: get list of open SSH tunnels](https://serverfault.com/questions/246031/how-can-i-get-list-of-open-ssh-tunnels)
- [AWS SSM Session Manager docs](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager.html)

# execution: phase 6 - tunnel operations

## status: complete ✅

## summary

created tunnel operation functions for VPC tunnel lifecycle management:

- `getVpcTunnel` - checks tunnel status by reading cache file, verifying process alive, and TCP health probe
- `setVpcTunnel` - opens/closes VPC tunnels via SSM port forwarding

## files created

### operations

1. `src/domain.operations/vpcTunnel/getVpcTunnel.ts`
   - computes cache file path from tunnel hash
   - checks if cache file exists
   - verifies process is alive via `process.kill(pid, 0)`
   - verifies tunnel is healthy via TCP connect
   - returns CLOSED if any check fails, OPEN if all pass

2. `src/domain.operations/vpcTunnel/setVpcTunnel.ts`
   - handles CLOSED status: kills process, deletes cache file
   - handles OPEN status:
     - resolves bastion and cluster from AWS
     - checks port availability
     - handles idempotency (existing healthy tunnel returns early)
     - starts bastion if stopped
     - spawns `aws ssm start-session` subprocess
     - persists cache file for recovery
     - waits for "Waiting for connections" output
     - verifies tunnel health via TCP probe

### unit tests

1. `getVpcTunnel.test.ts` - 4 tests
   - no cache file → CLOSED
   - dead process → CLOSED
   - alive process, unhealthy tunnel → CLOSED with pid
   - alive process, healthy tunnel → OPEN with pid

2. `setVpcTunnel.test.ts` - 3 tests
   - CLOSED status, no cache → CLOSED
   - CLOSED status, dead process → cleanup and CLOSED
   - OPEN status requires integration test (spawns real SSM)

## key patterns

- IIFE+early-returns for status branching
- `refByUnique<typeof DeclaredAwsVpcTunnel>(new DeclaredAwsVpcTunnel(input))` for cache serialization
- detached subprocess (`detached: true`, `unref()`) for tunnel persistence
- cache file written immediately for recovery on crash
- TCP health probe with 5s timeout

## verification

```
npm run test:types  # passes
npm run test:unit --testPathPattern="vpcTunnel"  # 37 tests pass
```

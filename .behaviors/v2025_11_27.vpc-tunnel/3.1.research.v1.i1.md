# research: AWS APIs and SDKs for VPC tunnel wish

## summary

the wish requires interfacing with **AWS** (not GitHub) to:
1. start/stop an EC2 bastion instance
2. create an SSM tunnel to reach an RDS database
3. wait for resources to be available

## AWS SDK v3 packages required

| package | purpose |
|---------|---------|
| `@aws-sdk/client-ec2` | start/stop bastion, describe instances, wait for running |
| `@aws-sdk/client-ssm` | start SSM session for port forwarding |
| `@aws-sdk/client-rds` | describe RDS clusters to get endpoints |

---

## 1. EC2 operations (bastion start/stop)

### package
```bash
npm install @aws-sdk/client-ec2
```

### find bastion by tag
```typescript
import { EC2Client, DescribeInstancesCommand } from "@aws-sdk/client-ec2";

const client = new EC2Client({ region: "us-east-1" });

const command = new DescribeInstancesCommand({
  Filters: [
    { Name: "tag:Name", Values: ["vpc-main-bastion"] },
    // or custom tag: { Name: "tag:exid", Values: ["vpc-main-bastion"] }
  ]
});

const response = await client.send(command);
const instance = response.Reservations?.[0]?.Instances?.[0];
const instanceId = instance?.InstanceId;
```

### start instance
```typescript
import { EC2Client, StartInstancesCommand } from "@aws-sdk/client-ec2";

const startCommand = new StartInstancesCommand({
  InstanceIds: [instanceId]
});
await client.send(startCommand);
```

### stop instance
```typescript
import { EC2Client, StopInstancesCommand } from "@aws-sdk/client-ec2";

const stopCommand = new StopInstancesCommand({
  InstanceIds: [instanceId]
});
await client.send(stopCommand);
```

### wait for instance running
```typescript
import { EC2Client, waitUntilInstanceRunning } from "@aws-sdk/client-ec2";

await waitUntilInstanceRunning(
  { client, maxWaitTime: 300 }, // 5 min timeout
  { InstanceIds: [instanceId] }
);
```

sources:
- [AWS SDK v3 EC2 docs](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/ec2/)
- [EC2 examples using SDK v3](https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/javascript_ec2_code_examples.html)
- [waitUntilInstanceRunning usage](https://repost.aws/questions/QUUTuUyLHLQzyALzqPbG3Y7Q/how-do-i-correctly-use-waituntilinstancerunning-in-the-js-sdk)

---

## 2. RDS operations (get cluster endpoint)

### package
```bash
npm install @aws-sdk/client-rds
```

### get cluster endpoint
```typescript
import { RDSClient, DescribeDBClustersCommand } from "@aws-sdk/client-rds";

const rdsClient = new RDSClient({ region: "us-east-1" });

const command = new DescribeDBClustersCommand({
  DBClusterIdentifier: "ahbodedb"
});

const response = await rdsClient.send(command);
const cluster = response.DBClusters?.[0];
const endpoint = cluster?.Endpoint;       // writer endpoint
const port = cluster?.Port;               // typically 5432 for postgres
```

sources:
- [DescribeDBClusters docs](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/example_aurora_DescribeDBClusters_section.html)
- [RDS SDK v3 docs](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-rds/globals.html)

---

## 3. SSM port forwarding (the tunnel)

### package
```bash
npm install @aws-sdk/client-ssm
```

### important caveat ⚠️

the `StartSessionCommand` API **only returns session metadata** (StreamUrl + TokenValue). it does **not** open the actual tunnel. to create a functioning port forward, you must either:

1. **use the AWS CLI** (recommended for simplicity)
2. **implement the WebSocket protocol** yourself using the session's StreamUrl and TokenValue

### option A: shell out to AWS CLI (recommended)

```typescript
import { spawn } from "child_process";

const tunnel = spawn("aws", [
  "ssm", "start-session",
  "--target", instanceId,
  "--document-name", "AWS-StartPortForwardingSessionToRemoteHost",
  "--parameters", JSON.stringify({
    host: [rdsEndpoint],
    portNumber: [String(rdsPort)],
    localPortNumber: [String(localPort)]
  })
]);

// tunnel.kill() to close
```

### option B: use ssm-session library (pure JS WebSocket)

```bash
npm install ssm-session
```

the [ssm-session](https://www.npmjs.com/package/ssm-session) library by bertrandmartel implements the WebSocket protocol for SSM sessions, compatible with browser and NodeJS.

```typescript
import { SSMClient, StartSessionCommand } from "@aws-sdk/client-ssm";

const ssmClient = new SSMClient({ region: "us-east-1" });

const startSessionCommand = new StartSessionCommand({
  Target: instanceId,
  DocumentName: "AWS-StartPortForwardingSessionToRemoteHost",
  Parameters: {
    host: [rdsEndpoint],
    portNumber: [String(rdsPort)],
    localPortNumber: [String(localPort)]
  }
});

const sessionResponse = await ssmClient.send(startSessionCommand);
// sessionResponse.StreamUrl -> WebSocket URL
// sessionResponse.TokenValue -> auth token

// then use ssm-session library to handle WebSocket protocol
```

sources:
- [ssm-session npm](https://www.npmjs.com/package/ssm-session)
- [ssm-session GitHub](https://github.com/bertrandmartel/aws-ssm-session)
- [AWS re:Post on SDK port forwarding](https://repost.aws/questions/QU5pDJCPALRlGKtGyuHjMJaw/aws-ssm-port-forwarding-session-using-aws-sdk)
- [AWS port forwarding blog](https://aws.amazon.com/blogs/mt/use-port-forwarding-in-aws-systems-manager-session-manager-to-connect-to-remote-hosts/)

---

## 4. alternative: CDK construct for bastion forwarding

the [@moia-oss/bastion-host-forward](https://www.npmjs.com/package/@moia-oss/bastion-host-forward) package provides a CDK construct for creating a bastion host that forwards connections to RDS/Redis.

this is useful for **provisioning** the infrastructure, but not for the runtime tunnel operation.

sources:
- [@moia-oss/bastion-host-forward npm](https://www.npmjs.com/package/@moia-oss/bastion-host-forward)
- [GitHub repo](https://github.com/moia-oss/bastion-host-forward)

---

## recommended approach for the wish

given the wish contract:

```typescript
const tunnel = RefByUnique<typeof DeclaredAwsVpcTunnel>.as({
  via: { bastion },
  into: { cluster },
  from: { host: 'localhost', port: 777_5432 },
})
```

the implementation should:

1. **resolve bastion** → use `DescribeInstancesCommand` with tag filter
2. **resolve cluster** → use `DescribeDBClustersCommand` to get endpoint
3. **start bastion** → use `StartInstancesCommand` + `waitUntilInstanceRunning`
4. **open tunnel** → spawn `aws ssm start-session` subprocess (simplest reliable approach)
5. **close tunnel** → kill subprocess + optionally `StopInstancesCommand` for bastion

### why spawn CLI vs pure SDK?

- the AWS SDK `StartSessionCommand` returns WebSocket metadata but doesn't handle the protocol
- implementing WebSocket protocol is complex (ssm-session library does this but adds dependency)
- spawning the CLI is battle-tested and what AWS recommends for programmatic port forwarding
- the CLI handles reconnection, protocol negotiation, and local port binding

---

## SSM agent requirements

for SSM port forwarding to work:
- bastion must have SSM agent >= 3.1.1374.0
- bastion must have IAM role with `AmazonSSMManagedInstanceCore` policy
- no inbound security group rules needed (SSM uses outbound TLS)

sources:
- [SSM Session Manager docs](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager.html)
- [Port forwarding to remote hosts](https://aws.amazon.com/blogs/mt/use-port-forwarding-in-aws-systems-manager-session-manager-to-connect-to-remote-hosts/)

# roadmap: VPC tunnel implementation

execution roadmap for blueprint v5 with ordered dependencies and acceptance criteria.

---

## phase 1: foundation

### 1.1 install dependencies

- [ ] **task**: add AWS SDK packages
  ```bash
  npm install @aws-sdk/client-ec2 @aws-sdk/client-rds
  ```

- **acceptance**: `npm ls @aws-sdk/client-ec2 @aws-sdk/client-rds` shows installed versions
- **verification**: `npm run build` passes (no import errors)

---

### 1.2 update `ContextAwsApi`

- [ ] **task**: update `src/domain.objects/ContextAwsApi.ts` with new shape
  - add `credentials: { account?, region? }`
  - add `cache.DeclaredAwsVpcTunnel.processes.dir`

- **depends on**: nothing
- **acceptance**: interface exports with required `cache.DeclaredAwsVpcTunnel.processes.dir` field
- **verification**: `npm run test:types` passes

---

## phase 2: domain objects

### 2.1 create `DeclaredAwsEc2Instance`

- [ ] **task**: create `src/domain.objects/DeclaredAwsEc2Instance.ts`
  - interface with `id?`, `exid`, `status?`, `privateIp?`
  - class extending `DomainEntity`
  - `primary = ['id']`, `unique = ['exid']`

- **depends on**: 1.2 (ContextAwsApi)
- **acceptance**: can instantiate `new DeclaredAwsEc2Instance({ exid: 'test' })`
- **verification**:
  ```typescript
  const instance = new DeclaredAwsEc2Instance({ exid: 'test' });
  expect(instance.exid).toBe('test');
  ```

---

### 2.2 create `DeclaredAwsRdsCluster`

- [ ] **task**: create `src/domain.objects/DeclaredAwsRdsCluster.ts`
  - interface with `name`, `arn?`, `host?: { writer, reader }`, `port?`, `status?`
  - class extending `DomainEntity`
  - `unique = ['name']`

- **depends on**: 1.2 (ContextAwsApi)
- **acceptance**: can instantiate `new DeclaredAwsRdsCluster({ name: 'test-db' })`
- **verification**:
  ```typescript
  const cluster = new DeclaredAwsRdsCluster({ name: 'test-db' });
  expect(cluster.name).toBe('test-db');
  ```

---

### 2.3 create `DeclaredAwsVpcTunnel`

- [ ] **task**: create `src/domain.objects/DeclaredAwsVpcTunnel.ts`
  - interface with `via`, `into`, `from`, `status?`, `pid?`
  - class extending `DomainEntity`
  - `unique = ['via', 'into', 'from']`

- **depends on**: 2.1 (DeclaredAwsEc2Instance), 2.2 (DeclaredAwsRdsCluster)
- **acceptance**: can instantiate with bastion and cluster refs
- **verification**:
  ```typescript
  const tunnel = new DeclaredAwsVpcTunnel({
    via: { mechanism: 'aws.ssm', bastion: { exid: 'bastion' } },
    into: { cluster: { name: 'db' } },
    from: { host: 'localhost', port: 5432 },
  });
  expect(tunnel.from.port).toBe(5432);
  ```

---

### 2.4 create `DeclastructAwsProvider` type

- [ ] **task**: create `src/domain.objects/DeclastructAwsProvider.ts`
  - type alias for `DeclastructProvider<...>`
  - includes DAOs for EC2, RDS, VpcTunnel

- **depends on**: 2.1, 2.2, 2.3 (all domain objects)
- **acceptance**: type compiles without errors
- **verification**: `npm run test:types` passes

---

## phase 3: EC2 operations

### 3.1 create `castToDeclaredAwsEc2Instance`

- [ ] **task**: create `src/domain.operations/ec2Instance/castToDeclaredAwsEc2Instance.ts`
  - cast AWS SDK `Instance` type to `DeclaredAwsEc2Instance`
  - extract `id`, `exid` (from tags), `status`, `privateIp`

- **depends on**: 2.1 (DeclaredAwsEc2Instance)
- **acceptance**: correctly maps AWS response to domain object
- **verification**:
  ```typescript
  const awsInstance = { InstanceId: 'i-123', Tags: [{ Key: 'exid', Value: 'bastion' }] };
  const result = castToDeclaredAwsEc2Instance(awsInstance);
  expect(result.id).toBe('i-123');
  expect(result.exid).toBe('bastion');
  ```

---

### 3.2 create `getEc2Instance`

- [ ] **task**: create `src/domain.operations/ec2Instance/getEc2Instance.ts`
  - lookup by primary (id) or unique (exid tag)
  - failfast if multiple instances found
  - return `null` if not found

- **depends on**: 3.1 (castToDeclaredAwsEc2Instance)
- **acceptance**: retrieves EC2 instance by exid tag
- **verification** (integration):
  ```typescript
  const instance = await getEc2Instance(
    { by: { unique: { exid: 'vpc-main-bastion' } } },
    context,
  );
  expect(instance?.exid).toBe('vpc-main-bastion');
  ```

---

### 3.3 create `setEc2InstanceStatus`

- [ ] **task**: create `src/domain.operations/ec2Instance/setEc2InstanceStatus.ts`
  - start or stop instance
  - wait for status transition
  - idempotent (skip if already in desired status)

- **depends on**: 3.2 (getEc2Instance)
- **acceptance**: starts stopped instance, returns running status
- **verification** (integration):
  ```typescript
  const before = await getEc2Instance({ by: { unique: { exid: 'bastion' } } }, context);
  expect(before?.status).toBe('stopped');

  const after = await setEc2InstanceStatus(
    { by: { instance: { exid: 'bastion' } }, to: { status: 'running' } },
    context,
  );
  expect(after.status).toBe('running');
  ```

---

## phase 4: RDS operations

### 4.1 create `castToDeclaredAwsRdsCluster`

- [ ] **task**: create `src/domain.operations/rdsCluster/castToDeclaredAwsRdsCluster.ts`
  - cast AWS SDK `DBCluster` type to `DeclaredAwsRdsCluster`
  - extract `name`, `arn`, `host.writer`, `host.reader`, `port`, `status`

- **depends on**: 2.2 (DeclaredAwsRdsCluster)
- **acceptance**: correctly maps AWS response to domain object
- **verification**:
  ```typescript
  const awsCluster = {
    DBClusterIdentifier: 'mydb',
    Endpoint: 'mydb.cluster-xxx.us-east-1.rds.amazonaws.com',
    ReaderEndpoint: 'mydb.cluster-ro-xxx.us-east-1.rds.amazonaws.com',
    Port: 5432,
  };
  const result = castToDeclaredAwsRdsCluster(awsCluster);
  expect(result.name).toBe('mydb');
  expect(result.host?.writer).toContain('mydb');
  ```

---

### 4.2 create `getRdsCluster`

- [ ] **task**: create `src/domain.operations/rdsCluster/getRdsCluster.ts`
  - lookup by cluster name
  - return `null` if not found (handle `DBClusterNotFoundFault`)

- **depends on**: 4.1 (castToDeclaredAwsRdsCluster)
- **acceptance**: retrieves RDS cluster by name
- **verification** (integration):
  ```typescript
  const cluster = await getRdsCluster(
    { by: { unique: { name: 'ahbodedb' } } },
    context,
  );
  expect(cluster?.name).toBe('ahbodedb');
  expect(cluster?.host?.writer).toBeDefined();
  ```

---

## phase 5: tunnel utilities

### 5.1 create `isPortInUse`

- [ ] **task**: create `src/domain.operations/vpcTunnel/utils/isPortInUse.ts`
  - check if local port is bound
  - reject on unexpected errors (not EADDRINUSE)

- **depends on**: nothing
- **acceptance**: returns `true` for bound port, `false` for free port
- **verification**:
  ```typescript
  const server = net.createServer().listen(9999);
  expect(await isPortInUse({ port: 9999 })).toBe(true);
  server.close();
  expect(await isPortInUse({ port: 9999 })).toBe(false);
  ```

---

### 5.2 create `isTunnelHealthy`

- [ ] **task**: create `src/domain.operations/vpcTunnel/utils/isTunnelHealthy.ts`
  - TCP connect to verify tunnel is forwarding
  - timeout after 5 seconds

- **depends on**: nothing
- **acceptance**: returns `true` if TCP connect succeeds
- **verification**:
  ```typescript
  const server = net.createServer().listen(9998);
  expect(await isTunnelHealthy({ port: 9998 })).toBe(true);
  server.close();
  expect(await isTunnelHealthy({ port: 9998 })).toBe(false);
  ```

---

### 5.3 create `isProcessAlive`

- [ ] **task**: create `src/domain.operations/vpcTunnel/utils/isProcessAlive.ts`
  - check if process with pid exists (signal 0)

- **depends on**: nothing
- **acceptance**: returns `true` for current process, `false` for invalid pid
- **verification**:
  ```typescript
  expect(isProcessAlive({ pid: process.pid })).toBe(true);
  expect(isProcessAlive({ pid: 999999999 })).toBe(false);
  ```

---

### 5.4 create `isFilePresent`

- [ ] **task**: create `src/domain.operations/vpcTunnel/utils/isFilePresent.ts`
  - check if file exists at path
  - failfast on non-ENOENT errors

- **depends on**: nothing
- **acceptance**: returns `true` for existing file, `false` for missing
- **verification**:
  ```typescript
  await fs.writeFile('/tmp/test-file', 'test');
  expect(await isFilePresent({ path: '/tmp/test-file' })).toBe(true);
  expect(await isFilePresent({ path: '/tmp/nonexistent' })).toBe(false);
  ```

---

### 5.5 create `getTunnelHash`

- [ ] **task**: create `src/domain.operations/vpcTunnel/utils/getTunnelHash.ts`
  - deterministic hash from tunnel ref
  - use `serialize()` from domain-objects

- **depends on**: 2.3 (DeclaredAwsVpcTunnel)
- **acceptance**: same input produces same hash
- **verification**:
  ```typescript
  const ref = { via: {...}, into: {...}, from: {...} };
  const hash1 = getTunnelHash({ for: { tunnel: ref } });
  const hash2 = getTunnelHash({ for: { tunnel: ref } });
  expect(hash1).toBe(hash2);
  expect(hash1).toHaveLength(16);
  ```

---

### 5.6 create `TunnelCacheFile` interface

- [ ] **task**: create `src/domain.operations/vpcTunnel/utils/TunnelCacheFile.ts`
  - interface with `pid` and `tunnel: RefByUnique<...>`

- **depends on**: 2.3 (DeclaredAwsVpcTunnel)
- **acceptance**: type compiles
- **verification**: `npm run test:types` passes

---

## phase 6: tunnel operations

### 6.1 create `getVpcTunnel`

- [ ] **task**: create `src/domain.operations/vpcTunnel/getVpcTunnel.ts`
  - check cache file exists
  - verify process alive
  - verify tunnel healthy
  - return status OPEN or CLOSED

- **depends on**: 5.1-5.6 (all tunnel utilities)
- **acceptance**: returns CLOSED when no tunnel exists
- **verification**:
  ```typescript
  const tunnel = await getVpcTunnel({ by: { unique: tunnelRef } }, context);
  expect(tunnel.status).toBe('CLOSED');
  ```

---

### 6.2 create `setVpcTunnel`

- [ ] **task**: create `src/domain.operations/vpcTunnel/setVpcTunnel.ts`
  - CLOSED: kill process, delete cache
  - OPEN: start bastion, spawn SSM tunnel, persist cache, verify health

- **depends on**: 3.3 (setEc2InstanceStatus), 4.2 (getRdsCluster), 6.1 (getVpcTunnel)
- **acceptance**: opens tunnel and returns OPEN status with pid
- **verification** (integration):
  ```typescript
  const result = await setVpcTunnel({ ...tunnel, status: 'OPEN' }, context);
  expect(result.status).toBe('OPEN');
  expect(result.pid).toBeDefined();

  // verify port is bound
  expect(await isPortInUse({ port: tunnel.from.port })).toBe(true);
  ```

---

## phase 7: DAOs

### 7.1 create `DeclaredAwsEc2InstanceDao`

- [ ] **task**: create `src/access/daos/DeclaredAwsEc2InstanceDao.ts`
  - implement `DeclastructDao` interface
  - wire `get` to `getEc2Instance`

- **depends on**: 3.2 (getEc2Instance)
- **acceptance**: DAO can retrieve instances
- **verification**: `provider.daos.DeclaredAwsEc2Instance.get({ by: {...} })` works

---

### 7.2 create `DeclaredAwsRdsClusterDao`

- [ ] **task**: create `src/access/daos/DeclaredAwsRdsClusterDao.ts`
  - implement `DeclastructDao` interface
  - wire `get` to `getRdsCluster`

- **depends on**: 4.2 (getRdsCluster)
- **acceptance**: DAO can retrieve clusters
- **verification**: `provider.daos.DeclaredAwsRdsCluster.get({ by: {...} })` works

---

### 7.3 create `DeclaredAwsVpcTunnelDao`

- [ ] **task**: create `src/access/daos/DeclaredAwsVpcTunnelDao.ts`
  - implement `DeclastructDao` interface
  - wire `get` to `getVpcTunnel`, `set` to `setVpcTunnel`

- **depends on**: 6.1 (getVpcTunnel), 6.2 (setVpcTunnel)
- **acceptance**: DAO can get/set tunnels
- **verification**: `provider.daos.DeclaredAwsVpcTunnel.set({ ...tunnel, status: 'OPEN' })` works

---

## phase 8: provider factory

### 8.1 create `getDeclastructAwsProvider`

- [ ] **task**: create `src/domain.operations/provider/getDeclastructAwsProvider.ts`
  - instantiate context with defaults (~/.declastruct/tunnels)
  - assemble DAOs
  - return `DeclastructProvider`

- **depends on**: 7.1, 7.2, 7.3 (all DAOs)
- **acceptance**: factory returns working provider
- **verification**:
  ```typescript
  const provider = getDeclastructAwsProvider(
    { credentials: { region: 'us-east-1' } },
    { log: console },
  );
  expect(provider.context.aws.cache.DeclaredAwsVpcTunnel.processes.dir).toContain('.declastruct');
  ```

---

## phase 9: exports

### 9.1 update `src/contract/sdks/index.ts`

- [ ] **task**: export all new domain objects and operations
  - `DeclaredAwsEc2Instance`
  - `DeclaredAwsRdsCluster`
  - `DeclaredAwsVpcTunnel`
  - `DeclastructAwsProvider`
  - `getDeclastructAwsProvider`
  - `getEc2Instance`, `setEc2InstanceStatus`
  - `getRdsCluster`
  - `setVpcTunnel`, `getVpcTunnel`

- **depends on**: all previous phases
- **acceptance**: all exports accessible from package
- **verification**:
  ```typescript
  import {
    DeclaredAwsVpcTunnel,
    getDeclastructAwsProvider,
    setVpcTunnel,
  } from 'declastruct-aws';
  ```

---

## phase 10: acceptance testing

### 10.1 end-to-end tunnel lifecycle

- [ ] **task**: create acceptance test for full tunnel lifecycle
  - create provider
  - open tunnel (starts bastion, creates SSM session)
  - verify database reachable via tunnel
  - close tunnel
  - verify tunnel closed

- **depends on**: 9.1 (exports)
- **acceptance**: full cycle completes without errors
- **verification** (acceptance test):
  ```typescript
  // open
  await setVpcTunnel({ ...tunnel, status: 'OPEN' }, provider.context);

  // verify database connection works
  const client = new Client({ host: 'localhost', port: 7775432, ... });
  await client.connect();
  await client.query('SELECT 1');
  await client.end();

  // close
  await setVpcTunnel({ ...tunnel, status: 'CLOSED' }, provider.context);

  // verify port released
  expect(await isPortInUse({ port: 7775432 })).toBe(false);
  ```

---

### 10.2 idempotency test

- [ ] **task**: verify tunnel operations are idempotent
  - open tunnel twice → same result
  - close tunnel twice → no error

- **depends on**: 10.1
- **acceptance**: repeated calls produce consistent results
- **verification**:
  ```typescript
  const first = await setVpcTunnel({ ...tunnel, status: 'OPEN' }, context);
  const second = await setVpcTunnel({ ...tunnel, status: 'OPEN' }, context);
  expect(first.pid).toBe(second.pid);
  ```

---

### 10.3 recovery test

- [ ] **task**: verify tunnel recovery after process crash
  - open tunnel
  - kill tunnel process externally
  - open tunnel again → should respawn

- **depends on**: 10.1
- **acceptance**: tunnel recovers from crashed state
- **verification**:
  ```typescript
  const first = await setVpcTunnel({ ...tunnel, status: 'OPEN' }, context);
  process.kill(first.pid!, 'SIGKILL');

  const recovered = await setVpcTunnel({ ...tunnel, status: 'OPEN' }, context);
  expect(recovered.status).toBe('OPEN');
  expect(recovered.pid).not.toBe(first.pid);
  ```

---

## execution order summary

```
1.1 → 1.2 → 2.1 → 2.2 → 2.3 → 2.4
                ↓
            3.1 → 3.2 → 3.3
                ↓
            4.1 → 4.2
                ↓
5.1, 5.2, 5.3, 5.4 → 5.5 → 5.6
                        ↓
                    6.1 → 6.2
                        ↓
                7.1, 7.2, 7.3
                        ↓
                       8.1
                        ↓
                       9.1
                        ↓
              10.1 → 10.2 → 10.3
```

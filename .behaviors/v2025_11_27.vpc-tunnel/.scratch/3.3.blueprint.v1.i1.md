# blueprint: VPC tunnel implementation

## overview

implement a declarative VPC tunnel system following existing repo patterns, enabling:
1. declarative references to EC2 bastions and RDS clusters
2. `setVpcTunnel({ status: 'OPEN' | 'CLOSED' })` to manage tunnel lifecycle
3. automatic bastion start/stop and SSM port forwarding

---

## directory structure

```
src/
├── domain.objects/
│   ├── DeclaredAwsEc2Instance.ts      # bastion instance domain object
│   ├── DeclaredAwsRdsCluster.ts       # rds cluster domain object
│   └── DeclaredAwsVpcTunnel.ts        # tunnel domain object (composite)
│
├── domain.operations/
│   ├── ec2Instance/
│   │   ├── getEc2Instance.ts          # find by tag or id
│   │   ├── setEc2Instance.ts          # start/stop instance
│   │   ├── castToDeclaredAwsEc2Instance.ts
│   │   └── *.test.ts
│   │
│   ├── rdsCluster/
│   │   ├── getRdsCluster.ts           # get cluster endpoint
│   │   ├── castToDeclaredAwsRdsCluster.ts
│   │   └── *.test.ts
│   │
│   └── vpcTunnel/
│       ├── setVpcTunnel.ts            # open/close tunnel orchestrator
│       ├── getVpcTunnel.ts            # check tunnel status
│       └── *.test.ts
│
└── contract/sdks/
    └── index.ts                        # export new domain objects + operations
```

---

## domain objects

### 1. `DeclaredAwsEc2Instance`

```typescript
// src/domain.objects/DeclaredAwsEc2Instance.ts

import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure which represents an AWS EC2 instance
 * .why = enables declarative reference to bastion hosts for VPC tunneling
 */
export interface DeclaredAwsEc2Instance {
  /**
   * .what = the instance id
   * .note = is @metadata when looked up by tag
   */
  instanceId?: string;

  /**
   * .what = the external id tag for declarative reference
   * .note = used for RefByUnique lookup
   */
  exid: string;

  /**
   * .what = the current state of the instance
   * .note = is @metadata -> may be undefined
   */
  state?: 'pending' | 'running' | 'stopping' | 'stopped' | 'shutting-down' | 'terminated';

  /**
   * .what = the private IP address
   * .note = is @metadata -> may be undefined
   */
  privateIp?: string;
}

export class DeclaredAwsEc2Instance
  extends DomainEntity<DeclaredAwsEc2Instance>
  implements DeclaredAwsEc2Instance
{
  public static primary = ['instanceId'] as const;
  public static unique = ['exid'] as const;
}
```

### 2. `DeclaredAwsRdsCluster`

```typescript
// src/domain.objects/DeclaredAwsRdsCluster.ts

import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure which represents an AWS RDS cluster
 * .why = enables declarative reference to databases for VPC tunneling
 */
export interface DeclaredAwsRdsCluster {
  /**
   * .what = the cluster identifier
   */
  name: string;

  /**
   * .what = the cluster ARN
   * .note = is @metadata -> may be undefined
   */
  arn?: string;

  /**
   * .what = the writer endpoint hostname
   * .note = is @metadata -> resolved from AWS
   */
  endpoint?: string;

  /**
   * .what = the reader endpoint hostname
   * .note = is @metadata -> resolved from AWS
   */
  readerEndpoint?: string;

  /**
   * .what = the database port
   * .note = is @metadata -> typically 5432 for postgres
   */
  port?: number;

  /**
   * .what = the cluster status
   * .note = is @metadata
   */
  status?: string;
}

export class DeclaredAwsRdsCluster
  extends DomainEntity<DeclaredAwsRdsCluster>
  implements DeclaredAwsRdsCluster
{
  public static unique = ['name'] as const;
}
```

### 3. `DeclaredAwsVpcTunnel`

```typescript
// src/domain.objects/DeclaredAwsVpcTunnel.ts

import { DomainEntity, RefByUnique } from 'domain-objects';
import { DeclaredAwsEc2Instance } from './DeclaredAwsEc2Instance';
import { DeclaredAwsRdsCluster } from './DeclaredAwsRdsCluster';

/**
 * .what = a declarative structure representing a VPC tunnel
 * .why = enables declarative management of SSM port-forwarding tunnels to private resources
 */
export interface DeclaredAwsVpcTunnel {
  /**
   * .what = the bastion instance to tunnel through
   */
  via: {
    bastion: RefByUnique<typeof DeclaredAwsEc2Instance>;
  };

  /**
   * .what = the target resource to tunnel into
   */
  into: {
    cluster: RefByUnique<typeof DeclaredAwsRdsCluster>;
  };

  /**
   * .what = the local binding for the tunnel
   */
  from: {
    host: string;  // typically 'localhost'
    port: number;  // local port to bind
  };

  /**
   * .what = the current tunnel status
   * .note = 'OPEN' when tunnel is active, 'CLOSED' when not
   */
  status?: 'OPEN' | 'CLOSED';

  /**
   * .what = the process id of the tunnel subprocess
   * .note = is @metadata -> only present when tunnel is OPEN
   */
  pid?: number;
}

export class DeclaredAwsVpcTunnel
  extends DomainEntity<DeclaredAwsVpcTunnel>
  implements DeclaredAwsVpcTunnel
{
  public static unique = ['via', 'into', 'from'] as const;
}
```

---

## domain operations

### 1. `getEc2Instance`

```typescript
// src/domain.operations/ec2Instance/getEc2Instance.ts

import {
  EC2Client,
  DescribeInstancesCommand,
} from '@aws-sdk/client-ec2';
import { asProcedure } from 'as-procedure';
import { RefByUnique } from 'domain-objects';
import { HasMetadata, PickOne } from 'type-fns';
import { VisualogicContext } from 'visualogic';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsEc2Instance } from '../../domain.objects/DeclaredAwsEc2Instance';
import { castToDeclaredAwsEc2Instance } from './castToDeclaredAwsEc2Instance';

/**
 * .what = gets an EC2 instance from AWS by exid tag or instance id
 * .why = enables lookup of bastion hosts for VPC tunneling
 */
export const getEc2Instance = asProcedure(
  async (
    input: {
      by: PickOne<{
        instanceId: string;
        unique: RefByUnique<typeof DeclaredAwsEc2Instance>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance> | null> => {
    const ec2 = new EC2Client({ region: context.aws.region });

    // build filters based on lookup method
    const filters = input.by.instanceId
      ? [{ Name: 'instance-id', Values: [input.by.instanceId] }]
      : [{ Name: 'tag:exid', Values: [input.by.unique.exid] }];

    const command = new DescribeInstancesCommand({ Filters: filters });
    const response = await ec2.send(command);

    // extract instance from response
    const instance = response.Reservations?.[0]?.Instances?.[0];
    if (!instance) return null;

    return castToDeclaredAwsEc2Instance(instance);
  },
);
```

### 2. `setEc2Instance`

```typescript
// src/domain.operations/ec2Instance/setEc2Instance.ts

import {
  EC2Client,
  StartInstancesCommand,
  StopInstancesCommand,
  waitUntilInstanceRunning,
  waitUntilInstanceStopped,
} from '@aws-sdk/client-ec2';
import { asProcedure } from 'as-procedure';
import { RefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata } from 'type-fns';
import { VisualogicContext } from 'visualogic';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsEc2Instance } from '../../domain.objects/DeclaredAwsEc2Instance';
import { getEc2Instance } from './getEc2Instance';

/**
 * .what = sets an EC2 instance state (start/stop)
 * .why = enables starting/stopping bastion hosts for VPC tunneling
 */
export const setEc2Instance = asProcedure(
  async (
    input: {
      ref: RefByUnique<typeof DeclaredAwsEc2Instance>;
      state: 'running' | 'stopped';
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance>> => {
    const ec2 = new EC2Client({ region: context.aws.region });

    // resolve the instance
    const instance = await getEc2Instance({ by: { unique: input.ref } }, context);
    if (!instance?.instanceId)
      throw new UnexpectedCodePathError('ec2 instance not found', { input });

    // skip if already in desired state
    if (instance.state === input.state) return instance;

    // start or stop based on desired state
    if (input.state === 'running') {
      await ec2.send(new StartInstancesCommand({ InstanceIds: [instance.instanceId] }));
      await waitUntilInstanceRunning(
        { client: ec2, maxWaitTime: 300 },
        { InstanceIds: [instance.instanceId] },
      );
    } else {
      await ec2.send(new StopInstancesCommand({ InstanceIds: [instance.instanceId] }));
      await waitUntilInstanceStopped(
        { client: ec2, maxWaitTime: 300 },
        { InstanceIds: [instance.instanceId] },
      );
    }

    // return updated instance
    return getEc2Instance({ by: { unique: input.ref } }, context) as Promise<HasMetadata<DeclaredAwsEc2Instance>>;
  },
);
```

### 3. `getRdsCluster`

```typescript
// src/domain.operations/rdsCluster/getRdsCluster.ts

import {
  RDSClient,
  DescribeDBClustersCommand,
} from '@aws-sdk/client-rds';
import { asProcedure } from 'as-procedure';
import { RefByUnique } from 'domain-objects';
import { HasMetadata } from 'type-fns';
import { VisualogicContext } from 'visualogic';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsRdsCluster } from '../../domain.objects/DeclaredAwsRdsCluster';
import { castToDeclaredAwsRdsCluster } from './castToDeclaredAwsRdsCluster';

/**
 * .what = gets an RDS cluster from AWS
 * .why = enables lookup of database endpoints for VPC tunneling
 */
export const getRdsCluster = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsRdsCluster> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredAwsRdsCluster> | null> => {
    const rds = new RDSClient({ region: context.aws.region });

    const command = new DescribeDBClustersCommand({
      DBClusterIdentifier: input.by.unique.name,
    });

    try {
      const response = await rds.send(command);
      const cluster = response.DBClusters?.[0];
      if (!cluster) return null;
      return castToDeclaredAwsRdsCluster(cluster);
    } catch (error) {
      if (error instanceof Error && error.name === 'DBClusterNotFoundFault')
        return null;
      throw error;
    }
  },
);
```

### 4. `setVpcTunnel` (the main orchestrator)

```typescript
// src/domain.operations/vpcTunnel/setVpcTunnel.ts

import { spawn, ChildProcess } from 'child_process';
import { asProcedure } from 'as-procedure';
import { UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata } from 'type-fns';
import { VisualogicContext } from 'visualogic';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsVpcTunnel } from '../../domain.objects/DeclaredAwsVpcTunnel';
import { getEc2Instance } from '../ec2Instance/getEc2Instance';
import { setEc2Instance } from '../ec2Instance/setEc2Instance';
import { getRdsCluster } from '../rdsCluster/getRdsCluster';

// track active tunnel processes
const activeTunnels = new Map<string, ChildProcess>();

/**
 * .what = opens or closes a VPC tunnel
 * .why = enables declarative management of SSM port-forwarding tunnels
 */
export const setVpcTunnel = asProcedure(
  async (
    input: DeclaredAwsVpcTunnel & { status: 'OPEN' | 'CLOSED' },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredAwsVpcTunnel>> => {
    const tunnelKey = `${input.via.bastion.exid}:${input.into.cluster.name}:${input.from.port}`;

    // handle CLOSED status
    if (input.status === 'CLOSED') {
      const existing = activeTunnels.get(tunnelKey);
      if (existing) {
        existing.kill();
        activeTunnels.delete(tunnelKey);
      }
      return new DeclaredAwsVpcTunnel({ ...input, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;
    }

    // handle OPEN status

    // 1. resolve the bastion instance
    const bastion = await getEc2Instance({ by: { unique: input.via.bastion } }, context);
    if (!bastion) throw new UnexpectedCodePathError('bastion not found', { input });

    // 2. start bastion if not running
    if (bastion.state !== 'running') {
      await setEc2Instance({ ref: input.via.bastion, state: 'running' }, context);
    }

    // 3. resolve the RDS cluster endpoint
    const cluster = await getRdsCluster({ by: { unique: input.into.cluster } }, context);
    if (!cluster?.endpoint || !cluster.port)
      throw new UnexpectedCodePathError('cluster endpoint not found', { input });

    // 4. spawn SSM tunnel subprocess
    const tunnelProcess = spawn('aws', [
      'ssm', 'start-session',
      '--target', bastion.instanceId!,
      '--document-name', 'AWS-StartPortForwardingSessionToRemoteHost',
      '--parameters', JSON.stringify({
        host: [cluster.endpoint],
        portNumber: [String(cluster.port)],
        localPortNumber: [String(input.from.port)],
      }),
      ...(context.aws.region ? ['--region', context.aws.region] : []),
    ], {
      stdio: 'pipe',
      detached: false,
    });

    // 5. wait for tunnel to be ready (parse stdout for "Waiting for connections")
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('tunnel startup timeout')), 30_000);

      tunnelProcess.stdout?.on('data', (data: Buffer) => {
        if (data.toString().includes('Waiting for connections')) {
          clearTimeout(timeout);
          resolve();
        }
      });

      tunnelProcess.on('error', (err) => {
        clearTimeout(timeout);
        reject(err);
      });

      tunnelProcess.on('exit', (code) => {
        if (code !== 0) {
          clearTimeout(timeout);
          reject(new Error(`tunnel exited with code ${code}`));
        }
      });
    });

    // 6. track the tunnel
    activeTunnels.set(tunnelKey, tunnelProcess);

    return new DeclaredAwsVpcTunnel({
      ...input,
      status: 'OPEN',
      pid: tunnelProcess.pid,
    }) as HasMetadata<DeclaredAwsVpcTunnel>;
  },
);
```

---

## dependencies to add

```bash
npm install @aws-sdk/client-ec2 @aws-sdk/client-rds
```

note: `@aws-sdk/client-ssm` is **not needed** since we spawn the AWS CLI directly (per research findings)

---

## usage example

```typescript
import { RefByUnique } from 'domain-objects';
import { DeclaredAwsEc2Instance } from 'declastruct-aws';
import { DeclaredAwsRdsCluster } from 'declastruct-aws';
import { DeclaredAwsVpcTunnel, setVpcTunnel } from 'declastruct-aws';

// declare references
const bastion = RefByUnique<typeof DeclaredAwsEc2Instance>.as({
  exid: 'vpc-main-bastion',
});

const cluster = RefByUnique<typeof DeclaredAwsRdsCluster>.as({
  name: 'ahbodedb',
});

const tunnel = new DeclaredAwsVpcTunnel({
  via: { bastion },
  into: { cluster },
  from: { host: 'localhost', port: 7775432 },
});

// open the tunnel
await setVpcTunnel({ ...tunnel, status: 'OPEN' }, { aws: { region: 'us-east-1' } });

// ... use database at localhost:7775432 ...

// close the tunnel
await setVpcTunnel({ ...tunnel, status: 'CLOSED' }, { aws: { region: 'us-east-1' } });
```

---

## implementation notes

### why spawn AWS CLI vs pure SDK?

per research (see `3.1.research.v1.i1.md`):
- AWS SDK `StartSessionCommand` returns WebSocket metadata but doesn't establish the tunnel
- implementing WebSocket protocol is complex
- spawning CLI is battle-tested and AWS-recommended for programmatic port forwarding
- CLI handles reconnection, protocol negotiation, and local port binding

### idempotency

- `setVpcTunnel({ status: 'OPEN' })` is idempotent — if tunnel already open, returns existing
- `setVpcTunnel({ status: 'CLOSED' })` is idempotent — if tunnel not open, no-op
- bastion start is idempotent — skips if already running

### tunnel tracking

- active tunnels tracked in-memory via `Map<tunnelKey, ChildProcess>`
- tunnelKey = `${bastion.exid}:${cluster.name}:${localPort}`
- on `CLOSED`, kills subprocess and removes from map

### future enhancements (per wish)

1. **host alias management** (`DeclaredUnixHostAlias`) — update `/etc/hosts` for friendly DNS
2. **declastruct CLI integration** — `TUNNEL_AS=OPEN npx declastruct apply --wish provision/vpc.tunnel.ts`

---

## files to create

| file | purpose |
|------|---------|
| `src/domain.objects/DeclaredAwsEc2Instance.ts` | EC2 instance domain object |
| `src/domain.objects/DeclaredAwsRdsCluster.ts` | RDS cluster domain object |
| `src/domain.objects/DeclaredAwsVpcTunnel.ts` | VPC tunnel domain object |
| `src/domain.operations/ec2Instance/getEc2Instance.ts` | get EC2 by tag/id |
| `src/domain.operations/ec2Instance/setEc2Instance.ts` | start/stop EC2 |
| `src/domain.operations/ec2Instance/castToDeclaredAwsEc2Instance.ts` | AWS → domain cast |
| `src/domain.operations/rdsCluster/getRdsCluster.ts` | get RDS cluster |
| `src/domain.operations/rdsCluster/castToDeclaredAwsRdsCluster.ts` | AWS → domain cast |
| `src/domain.operations/vpcTunnel/setVpcTunnel.ts` | tunnel orchestrator |
| `src/domain.operations/vpcTunnel/getVpcTunnel.ts` | check tunnel status |
| `src/contract/sdks/index.ts` | update exports |

---

## test strategy

- **unit tests**: mock AWS SDK clients, verify correct commands sent
- **integration tests**: require real AWS credentials, test against actual bastion/RDS
- **acceptance tests**: end-to-end tunnel open/close with database connectivity verification

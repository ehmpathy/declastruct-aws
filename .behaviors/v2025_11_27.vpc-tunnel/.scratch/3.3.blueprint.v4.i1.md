# blueprint: VPC tunnel implementation (v4)

## overview

implement a declarative VPC tunnel system following existing repo patterns, enabling:
1. declarative references to EC2 bastions and RDS clusters
2. `setVpcTunnel({ status: 'OPEN' | 'CLOSED' })` to manage tunnel lifecycle
3. persistent tunnel tracking via cache files
4. automatic bastion start/stop and SSM port forwarding

---

## directory structure

```
src/
├── domain.objects/
│   ├── DeclaredAwsEc2Instance.ts      # EC2 instance domain object
│   ├── DeclaredAwsRdsCluster.ts       # RDS cluster domain object
│   ├── DeclaredAwsVpcTunnel.ts        # tunnel domain object (composite)
│   └── ContextAwsApi.ts               # context with required cache config
│
├── domain.operations/
│   ├── ec2Instance/
│   │   ├── getEc2Instance.ts          # find by tag or id
│   │   ├── setEc2InstanceStatus.ts    # start/stop instance
│   │   ├── castToDeclaredAwsEc2Instance.ts
│   │   └── *.test.ts
│   │
│   ├── rdsCluster/
│   │   ├── getRdsCluster.ts           # get cluster endpoint
│   │   ├── castToDeclaredAwsRdsCluster.ts
│   │   └── *.test.ts
│   │
│   └── vpcTunnel/
│       ├── setVpcTunnel.ts            # open/close tunnel orchestrator
│       ├── getVpcTunnel.ts            # check tunnel status
│       ├── utils/
│       │   ├── getTunnelHash.ts       # deterministic tunnel identity
│       │   ├── isPortInUse.ts         # local port check
│       │   ├── isTunnelHealthy.ts     # TCP health probe
│       │   ├── isProcessAlive.ts      # process existence check
│       │   └── isFilePresent.ts       # file existence check
│       └── *.test.ts
│
└── contract/sdks/
    └── index.ts                        # export new domain objects + operations
```

---

## domain objects

### 1. `DeclaredAwsEc2Instance`

```typescript
// src/domain.objects/DeclaredAwsEc2Instance.ts

import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure which represents an AWS EC2 instance
 * .why = enables declarative control of AWS EC2 instances
 */
export interface DeclaredAwsEc2Instance {
  /**
   * .what = the instance id
   * .note = is @metadata -> only known after AWS lookup
   */
  id?: string;

  /**
   * .what = the external id tag for declarative reference
   * .note = used for RefByUnique lookup
   */
  exid: string;

  /**
   * .what = the current status of the instance
   * .note = is @metadata -> may be undefined
   */
  status?: 'pending' | 'running' | 'stopping' | 'stopped' | 'shutting-down' | 'terminated';

  /**
   * .what = the private IP address
   * .note = is @metadata -> may be undefined
   */
  privateIp?: string;
}

export class DeclaredAwsEc2Instance
  extends DomainEntity<DeclaredAwsEc2Instance>
  implements DeclaredAwsEc2Instance
{
  public static primary = ['id'] as const;
  public static unique = ['exid'] as const;
}
```

### 2. `DeclaredAwsRdsCluster`

```typescript
// src/domain.objects/DeclaredAwsRdsCluster.ts

import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure which represents an AWS RDS cluster
 * .why = enables declarative control of AWS RDS clusters
 */
export interface DeclaredAwsRdsCluster {
  /**
   * .what = the cluster identifier
   */
  name: string;

  /**
   * .what = the cluster ARN
   * .note = is @metadata -> may be undefined
   */
  arn?: string;

  /**
   * .what = the cluster hostnames
   * .note = is @metadata -> resolved from AWS
   */
  host?: {
    writer: string;
    reader: string;
  };

  /**
   * .what = the database port
   * .note = is @metadata -> typically 5432 for postgres
   */
  port?: number;

  /**
   * .what = the cluster status
   * .note = is @metadata
   */
  status?: string;
}

export class DeclaredAwsRdsCluster
  extends DomainEntity<DeclaredAwsRdsCluster>
  implements DeclaredAwsRdsCluster
{
  public static unique = ['name'] as const;
}
```

### 3. `DeclaredAwsVpcTunnel`

```typescript
// src/domain.objects/DeclaredAwsVpcTunnel.ts

import { DomainEntity, RefByUnique } from 'domain-objects';
import { DeclaredAwsEc2Instance } from './DeclaredAwsEc2Instance';
import { DeclaredAwsRdsCluster } from './DeclaredAwsRdsCluster';

/**
 * .what = a declarative structure representing a VPC tunnel
 * .why = enables declarative control of SSM port-forwarding tunnels to private resources
 */
export interface DeclaredAwsVpcTunnel {
  /**
   * .what = the bastion instance to tunnel through and the mechanism
   */
  via: {
    mechanism: 'aws.ssm';
    bastion: RefByUnique<typeof DeclaredAwsEc2Instance>;
  };

  /**
   * .what = the target resource to tunnel into
   */
  into: {
    cluster: RefByUnique<typeof DeclaredAwsRdsCluster>;
  };

  /**
   * .what = the local binding for the tunnel
   */
  from: {
    host: string;  // typically 'localhost'
    port: number;  // local port to bind
  };

  /**
   * .what = the current tunnel status
   * .note = 'OPEN' when tunnel is active, 'CLOSED' when not
   */
  status?: 'OPEN' | 'CLOSED';

  /**
   * .what = the process id of the tunnel subprocess
   * .note = is @metadata -> only present when tunnel is OPEN
   */
  pid?: number;
}

export class DeclaredAwsVpcTunnel
  extends DomainEntity<DeclaredAwsVpcTunnel>
  implements DeclaredAwsVpcTunnel
{
  public static unique = ['via', 'into', 'from'] as const;
}
```

### 4. `ContextAwsApi` (updated)

```typescript
// src/domain.objects/ContextAwsApi.ts

/**
 * .what = context interface for AWS API operations
 * .why = provides AWS configuration and cache paths to operations
 * .note = cache paths are required; defaults should be set in getContext factory
 */
export interface ContextAwsApi {
  aws: {
    account?: string;
    region?: string;
    cache: {
      DeclaredAwsVpcTunnel: {
        processes: {
          dir: string; // e.g., ~/.declastruct/tunnels — set default in getContext
        };
      };
    };
  };
}
```

---

## domain operations

### 1. `getEc2Instance`

```typescript
// src/domain.operations/ec2Instance/getEc2Instance.ts

import {
  EC2Client,
  DescribeInstancesCommand,
} from '@aws-sdk/client-ec2';
import { asProcedure } from 'as-procedure';
import { isUniqueKeyRef, Ref, RefByPrimary, RefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata, PickOne } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsEc2Instance } from '../../domain.objects/DeclaredAwsEc2Instance';
import { castToDeclaredAwsEc2Instance } from './castToDeclaredAwsEc2Instance';

/**
 * .what = gets an EC2 instance from AWS
 * .why = enables lookup of EC2 instances by tag or instance id
 */
export const getEc2Instance = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsEc2Instance>;
        unique: RefByUnique<typeof DeclaredAwsEc2Instance>;
        ref: Ref<typeof DeclaredAwsEc2Instance>;
      }>;
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance> | null> => {
    // handle by ref
    if (input.by.ref)
      return isUniqueKeyRef({ of: DeclaredAwsEc2Instance })(input.by.ref)
        ? getEc2Instance({ by: { unique: input.by.ref } }, context)
        : getEc2Instance({ by: { primary: input.by.ref } }, context);

    const ec2 = new EC2Client({ region: context.aws.region });

    // build command based on lookup method
    const command = (() => {
      if (input.by.primary)
        return new DescribeInstancesCommand({
          InstanceIds: [input.by.primary.id],
        });
      if (input.by.unique)
        return new DescribeInstancesCommand({
          Filters: [{ Name: 'tag:exid', Values: [input.by.unique.exid] }],
        });
      throw UnexpectedCodePathError.throw(
        'not referenced by primary nor unique. how not?',
        { input },
      );
    })();

    const response = await ec2.send(command);

    // extract instances from response
    const [instance, ...collisions] = response.Reservations?.flatMap((r) => r.Instances ?? []) ?? [];
    if (!instance) return null;

    // failfast if more than one instance found
    if (collisions.length)
      throw UnexpectedCodePathError.throw(
        'multiple ec2 instances found; expected exactly one',
        { input, count: collisions.length + 1 },
      );

    return castToDeclaredAwsEc2Instance(instance);
  },
);
```

### 2. `setEc2InstanceStatus`

```typescript
// src/domain.operations/ec2Instance/setEc2InstanceStatus.ts

import {
  EC2Client,
  StartInstancesCommand,
  StopInstancesCommand,
  waitUntilInstanceRunning,
  waitUntilInstanceStopped,
} from '@aws-sdk/client-ec2';
import { asProcedure } from 'as-procedure';
import { Ref } from 'domain-objects';
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsEc2Instance } from '../../domain.objects/DeclaredAwsEc2Instance';
import { getEc2Instance } from './getEc2Instance';

/**
 * .what = sets an EC2 instance status (running/stopped)
 * .why = enables declarative control of EC2 instance lifecycle
 */
export const setEc2InstanceStatus = asProcedure(
  async (
    input: {
      by: {
        instance: Ref<typeof DeclaredAwsEc2Instance>;
      };
      to: {
        status: 'running' | 'stopped';
      };
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance>> => {
    const ec2 = new EC2Client({ region: context.aws.region });

    // resolve the instance
    const instance = await getEc2Instance({ by: { ref: input.by.instance } }, context) ??
      BadRequestError.throw('cant find instance to set status of. does it exist?', { input });

    // skip if already in desired status
    if (instance.status === input.to.status) return instance;

    // failfast if instance has no id (should never happen after successful lookup)
    if (!instance.id)
      throw UnexpectedCodePathError.throw('instance found but has no id', { instance });

    // start or stop based on desired status
    await (async () => {
      if (input.to.status === 'running') {
        await ec2.send(new StartInstancesCommand({ InstanceIds: [instance.id!] }));
        await waitUntilInstanceRunning(
          { client: ec2, maxWaitTime: 300 },
          { InstanceIds: [instance.id!] },
        );
        return;
      }
      if (input.to.status === 'stopped') {
        await ec2.send(new StopInstancesCommand({ InstanceIds: [instance.id!] }));
        await waitUntilInstanceStopped(
          { client: ec2, maxWaitTime: 300 },
          { InstanceIds: [instance.id!] },
        );
        return;
      }
      throw UnexpectedCodePathError.throw('unsupported status', { input });
    })();

    // return updated instance
    const updated = await getEc2Instance({ by: { ref: input.by.instance } }, context) ??
      UnexpectedCodePathError.throw('how can instance not be found after status update?', { input, instance: { before: instance } });
    return updated;
  },
);
```

### 3. `getRdsCluster`

```typescript
// src/domain.operations/rdsCluster/getRdsCluster.ts

import {
  RDSClient,
  DescribeDBClustersCommand,
} from '@aws-sdk/client-rds';
import { asProcedure } from 'as-procedure';
import { RefByUnique } from 'domain-objects';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsRdsCluster } from '../../domain.objects/DeclaredAwsRdsCluster';
import { castToDeclaredAwsRdsCluster } from './castToDeclaredAwsRdsCluster';

/**
 * .what = gets an RDS cluster from AWS
 * .why = enables lookup of RDS cluster endpoints and metadata
 */
export const getRdsCluster = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsRdsCluster> };
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsRdsCluster> | null> => {
    const rds = new RDSClient({ region: context.aws.region });

    const command = new DescribeDBClustersCommand({
      DBClusterIdentifier: input.by.unique.name,
    });

    try {
      const response = await rds.send(command);
      const cluster = response.DBClusters?.[0];
      if (!cluster) return null;
      return castToDeclaredAwsRdsCluster(cluster);
    } catch (error) {
      if (error instanceof Error && error.name === 'DBClusterNotFoundFault')
        return null;
      throw error;
    }
  },
);
```

### 4. tunnel utilities

```typescript
// src/domain.operations/vpcTunnel/utils/getTunnelHash.ts

import * as crypto from 'crypto';
import { RefByUnique, serialize } from 'domain-objects';

import { DeclaredAwsVpcTunnel } from '../../../domain.objects/DeclaredAwsVpcTunnel';

/**
 * .what = generates a deterministic hash for a tunnel configuration
 * .why = enables consistent identification of tunnels across process restarts
 */
export const getTunnelHash = (
  input: {
    for: { tunnel: RefByUnique<typeof DeclaredAwsVpcTunnel> };
  },
): string => {
  // serialize the tunnel ref to create deterministic identity
  const serialized = serialize({
    via: input.for.tunnel.via,
    into: input.for.tunnel.into,
    from: input.for.tunnel.from,
  });

  return crypto
    .createHash('sha256')
    .update(serialized)
    .digest('hex')
    .slice(0, 16);
};
```

```typescript
// src/domain.operations/vpcTunnel/utils/isPortInUse.ts

import * as net from 'net';

/**
 * .what = checks if a local port is currently in use
 * .why = enables detection of existing tunnels or port conflicts
 */
export const isPortInUse = async (input: { port: number }): Promise<boolean> => {
  return new Promise((resolve, reject) => {
    const server = net.createServer();
    server.once('error', (err: NodeJS.ErrnoException) => {
      // port in use is the expected "positive" case
      if (err.code === 'EADDRINUSE') return resolve(true);

      // any other error is unexpected; failfast
      reject(err);
    });
    server.once('listening', () => {
      server.close();
      resolve(false);
    });
    server.listen(input.port, '127.0.0.1');
  });
};
```

```typescript
// src/domain.operations/vpcTunnel/utils/isTunnelHealthy.ts

import * as net from 'net';

/**
 * .what = checks if a tunnel is accepting connections
 * .why = verifies tunnel is functional beyond just port binding
 */
export const isTunnelHealthy = async (input: { port: number }): Promise<boolean> => {
  return new Promise((resolve) => {
    const socket = new net.Socket();
    socket.setTimeout(5000);
    socket.once('connect', () => {
      socket.destroy();
      resolve(true);
    });
    socket.once('error', () => resolve(false));
    socket.once('timeout', () => {
      socket.destroy();
      resolve(false);
    });
    socket.connect(input.port, '127.0.0.1');
  });
};
```

```typescript
// src/domain.operations/vpcTunnel/utils/isProcessAlive.ts

/**
 * .what = checks if a process with given pid is still running
 * .why = enables detection of crashed tunnel processes
 */
export const isProcessAlive = (input: { pid: number }): boolean => {
  try {
    process.kill(input.pid, 0); // signal 0 = check existence only
    return true;
  } catch {
    return false;
  }
};
```

```typescript
// src/domain.operations/vpcTunnel/utils/isFilePresent.ts

import * as fs from 'fs/promises';

/**
 * .what = checks if a file exists at the given path
 * .why = enables explicit file existence checks without try/catch
 */
export const isFilePresent = async (input: { path: string }): Promise<boolean> => {
  try {
    await fs.access(input.path);
    return true;
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') return false;
    throw err; // failfast on unexpected errors
  }
};
```

### 5. tunnel cache file schema

```typescript
// src/domain.operations/vpcTunnel/utils/TunnelCacheFile.ts

import { DeclaredAwsVpcTunnel } from '../../../domain.objects/DeclaredAwsVpcTunnel';

/**
 * .what = schema for tunnel cache file contents
 * .why = single file containing both pid and tunnel metadata
 */
export interface TunnelCacheFile {
  pid: number;
  tunnel: DeclaredAwsVpcTunnel;
}
```

### 6. `setVpcTunnel` (the main orchestrator)

```typescript
// src/domain.operations/vpcTunnel/setVpcTunnel.ts

import { spawn } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';
import { asProcedure } from 'as-procedure';
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsVpcTunnel } from '../../domain.objects/DeclaredAwsVpcTunnel';
import { getEc2Instance } from '../ec2Instance/getEc2Instance';
import { setEc2InstanceStatus } from '../ec2Instance/setEc2InstanceStatus';
import { getRdsCluster } from '../rdsCluster/getRdsCluster';
import { getTunnelHash } from './utils/getTunnelHash';
import { isPortInUse } from './utils/isPortInUse';
import { isTunnelHealthy } from './utils/isTunnelHealthy';
import { isProcessAlive } from './utils/isProcessAlive';
import { isFilePresent } from './utils/isFilePresent';
import { TunnelCacheFile } from './utils/TunnelCacheFile';

/**
 * .what = opens or closes a VPC tunnel
 * .why = enables declarative control of SSM port-forwarding tunnels
 */
export const setVpcTunnel = asProcedure(
  async (
    input: DeclaredAwsVpcTunnel & { status: 'OPEN' | 'CLOSED' },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsVpcTunnel>> => {
    // resolve cache path from context
    const tunnelsDir = context.aws.cache.DeclaredAwsVpcTunnel.processes.dir;
    await fs.mkdir(tunnelsDir, { recursive: true });

    // compute tunnel identity
    const tunnelHash = getTunnelHash({ for: { tunnel: input } });
    const cachePath = path.join(tunnelsDir, `${tunnelHash}.json`);

    // handle CLOSED status
    if (input.status === 'CLOSED') {
      // check if cache file exists
      const cacheFilePresent = await isFilePresent({ path: cachePath });
      if (cacheFilePresent) {
        const cacheContent = await fs.readFile(cachePath, 'utf-8');
        const cache: TunnelCacheFile = JSON.parse(cacheContent);
        if (isProcessAlive({ pid: cache.pid })) {
          process.kill(cache.pid, 'SIGTERM');
        }
      }

      // cleanup cache file
      await fs.rm(cachePath, { force: true });

      return new DeclaredAwsVpcTunnel({ ...input, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;
    }

    // handle OPEN status

    // resolve bastion and cluster
    const bastion = await getEc2Instance({ by: { unique: input.via.bastion } }, context) ??
      BadRequestError.throw('bastion not found', { input });

    const cluster = await getRdsCluster({ by: { unique: input.into.cluster } }, context) ??
      BadRequestError.throw('cluster not found', { input });

    if (!cluster.host?.writer || !cluster.port)
      BadRequestError.throw('cluster endpoint not found', { input, cluster });

    if (!bastion.id)
      throw UnexpectedCodePathError.throw('bastion found but has no id', { bastion });

    // check if port is in use
    const portInUse = await isPortInUse({ port: input.from.port });

    if (portInUse) {
      // check if cache file exists for this tunnel
      const cacheFilePresent = await isFilePresent({ path: cachePath });
      if (!cacheFilePresent)
        throw BadRequestError.throw('port is in use by another process', { port: input.from.port });

      // read cache file
      const cacheContent = await fs.readFile(cachePath, 'utf-8');
      const cache: TunnelCacheFile = JSON.parse(cacheContent);

      // return early if existing tunnel is alive and healthy
      if (isProcessAlive({ pid: cache.pid }) && await isTunnelHealthy({ port: input.from.port }))
        return new DeclaredAwsVpcTunnel({ ...input, status: 'OPEN', pid: cache.pid }) as HasMetadata<DeclaredAwsVpcTunnel>;

      // otherwise, cleanup stale tunnel; fallthrough to respawn
      if (isProcessAlive({ pid: cache.pid })) process.kill(cache.pid, 'SIGTERM');
      await fs.rm(cachePath, { force: true });
    }

    // start bastion if not running
    if (bastion.status !== 'running') {
      await setEc2InstanceStatus(
        { by: { instance: input.via.bastion }, to: { status: 'running' } },
        context,
      );
    }

    // spawn SSM tunnel subprocess
    const tunnelProcess = spawn('aws', [
      'ssm', 'start-session',
      '--target', bastion.id,
      '--document-name', 'AWS-StartPortForwardingSessionToRemoteHost',
      '--parameters', JSON.stringify({
        host: [cluster.host.writer],
        portNumber: [String(cluster.port)],
        localPortNumber: [String(input.from.port)],
      }),
      ...(context.aws.region ? ['--region', context.aws.region] : []),
    ], {
      stdio: 'pipe',
      detached: true,
    });

    // detach so tunnel survives parent process exit
    tunnelProcess.unref();

    // persist cache file immediately so recovery is possible if process exits mid-startup
    const cacheData: TunnelCacheFile = { pid: tunnelProcess.pid!, tunnel: input };
    await fs.writeFile(cachePath, JSON.stringify(cacheData, null, 2));

    // wait for tunnel to be ready
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('tunnel startup timeout')), 30_000);

      tunnelProcess.stdout?.on('data', (data: Buffer) => {
        if (data.toString().includes('Waiting for connections')) {
          clearTimeout(timeout);
          resolve();
        }
      });

      tunnelProcess.stderr?.on('data', (data: Buffer) => {
        context.log?.debug?.('tunnel stderr', { data: data.toString() });
      });

      tunnelProcess.on('error', (err) => {
        clearTimeout(timeout);
        reject(err);
      });

      tunnelProcess.on('exit', (code) => {
        if (code !== 0) {
          clearTimeout(timeout);
          reject(new Error(`tunnel exited with code ${code}`));
        }
      });
    });

    // verify tunnel is healthy (can reach database)
    const healthy = await isTunnelHealthy({ port: input.from.port });
    if (!healthy) {
      tunnelProcess.kill('SIGTERM');
      await fs.rm(cachePath, { force: true });
      throw UnexpectedCodePathError.throw('tunnel started but database not reachable', { input });
    }

    return new DeclaredAwsVpcTunnel({
      ...input,
      status: 'OPEN',
      pid: tunnelProcess.pid,
    }) as HasMetadata<DeclaredAwsVpcTunnel>;
  },
);
```

### 7. `getVpcTunnel`

```typescript
// src/domain.operations/vpcTunnel/getVpcTunnel.ts

import * as fs from 'fs/promises';
import * as path from 'path';
import { asProcedure } from 'as-procedure';
import { RefByUnique } from 'domain-objects';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsVpcTunnel } from '../../domain.objects/DeclaredAwsVpcTunnel';
import { getTunnelHash } from './utils/getTunnelHash';
import { isProcessAlive } from './utils/isProcessAlive';
import { isTunnelHealthy } from './utils/isTunnelHealthy';
import { isFilePresent } from './utils/isFilePresent';
import { TunnelCacheFile } from './utils/TunnelCacheFile';

/**
 * .what = gets the current status of a VPC tunnel
 * .why = enables checking if a tunnel is currently open and healthy
 */
export const getVpcTunnel = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsVpcTunnel> };
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsVpcTunnel>> => {
    // resolve cache path from context
    const tunnelsDir = context.aws.cache.DeclaredAwsVpcTunnel.processes.dir;

    // compute tunnel identity
    const tunnelHash = getTunnelHash({ for: { tunnel: input.by.unique } });
    const cachePath = path.join(tunnelsDir, `${tunnelHash}.json`);

    // check if cache file exists
    const cacheFilePresent = await isFilePresent({ path: cachePath });
    if (!cacheFilePresent)
      return new DeclaredAwsVpcTunnel({ ...input.by.unique, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;

    // read cache file
    const cacheContent = await fs.readFile(cachePath, 'utf-8');
    const cache: TunnelCacheFile = JSON.parse(cacheContent);

    // check if process is alive
    if (!isProcessAlive({ pid: cache.pid }))
      return new DeclaredAwsVpcTunnel({ ...input.by.unique, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;

    // verify tunnel is healthy
    const healthy = await isTunnelHealthy({ port: input.by.unique.from.port });
    if (!healthy)
      return new DeclaredAwsVpcTunnel({ ...input.by.unique, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;

    return new DeclaredAwsVpcTunnel({ ...input.by.unique, status: 'OPEN', pid: cache.pid }) as HasMetadata<DeclaredAwsVpcTunnel>;
  },
);
```

---

## dependencies to add

```bash
npm install @aws-sdk/client-ec2 @aws-sdk/client-rds
```

note: `@aws-sdk/client-ssm` is **not needed** since we spawn the AWS CLI directly

---

## usage example

```typescript
import { RefByUnique } from 'domain-objects';
import {
  DeclaredAwsEc2Instance,
  DeclaredAwsRdsCluster,
  DeclaredAwsVpcTunnel,
  setVpcTunnel,
  getVpcTunnel,
} from 'declastruct-aws';

// declare references
const bastion = RefByUnique<typeof DeclaredAwsEc2Instance>.as({
  exid: 'vpc-main-bastion',
});

const cluster = RefByUnique<typeof DeclaredAwsRdsCluster>.as({
  name: 'ahbodedb',
});

const tunnel = new DeclaredAwsVpcTunnel({
  via: { mechanism: 'aws.ssm', bastion },
  into: { cluster },
  from: { host: 'localhost', port: 7775432 },
});

// context with required cache config (default set in getContext factory)
const context = {
  aws: {
    region: 'us-east-1',
    cache: {
      DeclaredAwsVpcTunnel: {
        processes: { dir: '/home/user/.declastruct/tunnels' },
      },
    },
  },
  log: console,
};

// open the tunnel (starts bastion if needed, waits for db reachable)
await setVpcTunnel({ ...tunnel, status: 'OPEN' }, context);

// ... use database at localhost:7775432 ...
// tunnel persists even after this process exits

// check tunnel status later
const current = await getVpcTunnel({ by: { unique: tunnel } }, context);
console.log(current.status); // 'OPEN' or 'CLOSED'

// close the tunnel
await setVpcTunnel({ ...tunnel, status: 'CLOSED' }, context);
```

---

## tunnel tracking strategy

tunnels are tracked via a single JSON cache file:

1. **cache file**: `{tunnelsDir}/{tunnelHash}.json` — contains `{ pid, tunnel }`
2. **port check**: native `net.Server` to detect if port is in use
3. **process check**: `process.kill(pid, 0)` to verify process alive
4. **health probe**: TCP connect to verify tunnel is forwarding

**tunnel identity formula**:
```typescript
// uses serialize() from domain-objects for deterministic serialization
tunnelHash = sha256(serialize({ via, into, from })).slice(0, 16)
```

**edge cases handled**:
| case | resolution |
|------|------------|
| process crashes | cache file remains, but `isProcessAlive` fails → cleanup and respawn |
| port collision | cache file doesn't exist → fail with `BadRequestError` |
| tunnel alive but unhealthy | kill and respawn |
| tunnel already open | return existing tunnel info (idempotent) |
| process exits mid-startup | cache file written early → can recover on next call |

---

## files to create

| file | purpose |
|------|---------|
| `src/domain.objects/DeclaredAwsEc2Instance.ts` | EC2 instance domain object |
| `src/domain.objects/DeclaredAwsRdsCluster.ts` | RDS cluster domain object |
| `src/domain.objects/DeclaredAwsVpcTunnel.ts` | VPC tunnel domain object |
| `src/domain.objects/ContextAwsApi.ts` | update with required cache config |
| `src/domain.operations/ec2Instance/getEc2Instance.ts` | get EC2 by tag/id |
| `src/domain.operations/ec2Instance/setEc2InstanceStatus.ts` | start/stop EC2 |
| `src/domain.operations/ec2Instance/castToDeclaredAwsEc2Instance.ts` | AWS → domain cast |
| `src/domain.operations/rdsCluster/getRdsCluster.ts` | get RDS cluster |
| `src/domain.operations/rdsCluster/castToDeclaredAwsRdsCluster.ts` | AWS → domain cast |
| `src/domain.operations/vpcTunnel/setVpcTunnel.ts` | tunnel orchestrator |
| `src/domain.operations/vpcTunnel/getVpcTunnel.ts` | check tunnel status |
| `src/domain.operations/vpcTunnel/utils/getTunnelHash.ts` | tunnel identity hash |
| `src/domain.operations/vpcTunnel/utils/isPortInUse.ts` | port check |
| `src/domain.operations/vpcTunnel/utils/isTunnelHealthy.ts` | TCP health probe |
| `src/domain.operations/vpcTunnel/utils/isProcessAlive.ts` | process existence check |
| `src/domain.operations/vpcTunnel/utils/isFilePresent.ts` | file existence check |
| `src/domain.operations/vpcTunnel/utils/TunnelCacheFile.ts` | cache file schema |
| `src/contract/sdks/index.ts` | update exports |

---

## test strategy

- **unit tests**: mock AWS SDK clients, verify correct commands sent
- **integration tests**: require real AWS credentials, test against actual bastion/RDS
- **acceptance tests**: end-to-end tunnel open/close with database connectivity verification

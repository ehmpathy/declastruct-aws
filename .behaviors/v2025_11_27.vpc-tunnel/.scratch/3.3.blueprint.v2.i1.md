# blueprint: VPC tunnel implementation (v2)

## overview

implement a declarative VPC tunnel system following existing repo patterns, enabling:
1. declarative references to EC2 bastions and RDS clusters
2. `setVpcTunnel({ status: 'OPEN' | 'CLOSED' })` to manage tunnel lifecycle
3. persistent tunnel tracking via pidfiles
4. automatic bastion start/stop and SSM port forwarding

---

## directory structure

```
src/
├── domain.objects/
│   ├── DeclaredAwsEc2Instance.ts      # EC2 instance domain object
│   ├── DeclaredAwsRdsCluster.ts       # RDS cluster domain object
│   └── DeclaredAwsVpcTunnel.ts        # tunnel domain object (composite)
│
├── domain.operations/
│   ├── ec2Instance/
│   │   ├── getEc2Instance.ts          # find by tag or id
│   │   ├── setEc2InstanceStatus.ts    # start/stop instance
│   │   ├── castToDeclaredAwsEc2Instance.ts
│   │   └── *.test.ts
│   │
│   ├── rdsCluster/
│   │   ├── getRdsCluster.ts           # get cluster endpoint
│   │   ├── castToDeclaredAwsRdsCluster.ts
│   │   └── *.test.ts
│   │
│   └── vpcTunnel/
│       ├── setVpcTunnel.ts            # open/close tunnel orchestrator
│       ├── getVpcTunnel.ts            # check tunnel status
│       ├── utils/
│       │   ├── getTunnelHash.ts       # deterministic tunnel identity
│       │   ├── isPortInUse.ts         # local port check
│       │   ├── isTunnelHealthy.ts     # TCP health probe
│       │   └── isProcessAlive.ts      # process existence check
│       └── *.test.ts
│
└── contract/sdks/
    └── index.ts                        # export new domain objects + operations
```

---

## domain objects

### 1. `DeclaredAwsEc2Instance`

```typescript
// src/domain.objects/DeclaredAwsEc2Instance.ts

import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure which represents an AWS EC2 instance
 * .why = enables declarative control of AWS EC2 instances
 */
export interface DeclaredAwsEc2Instance {
  /**
   * .what = the instance id
   * .note = is @metadata when looked up by tag
   */
  instanceId?: string;

  /**
   * .what = the external id tag for declarative reference
   * .note = used for RefByUnique lookup
   */
  exid: string;

  /**
   * .what = the current status of the instance
   * .note = is @metadata -> may be undefined
   */
  status?: 'pending' | 'running' | 'stopping' | 'stopped' | 'shutting-down' | 'terminated';

  /**
   * .what = the private IP address
   * .note = is @metadata -> may be undefined
   */
  privateIp?: string;
}

export class DeclaredAwsEc2Instance
  extends DomainEntity<DeclaredAwsEc2Instance>
  implements DeclaredAwsEc2Instance
{
  public static primary = ['instanceId'] as const;
  public static unique = ['exid'] as const;
}
```

### 2. `DeclaredAwsRdsCluster`

```typescript
// src/domain.objects/DeclaredAwsRdsCluster.ts

import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure which represents an AWS RDS cluster
 * .why = enables declarative control of AWS RDS clusters
 */
export interface DeclaredAwsRdsCluster {
  /**
   * .what = the cluster identifier
   */
  name: string;

  /**
   * .what = the cluster ARN
   * .note = is @metadata -> may be undefined
   */
  arn?: string;

  /**
   * .what = the cluster hostnames
   * .note = is @metadata -> resolved from AWS
   */
  host?: {
    writer: string;
    reader: string;
  };

  /**
   * .what = the database port
   * .note = is @metadata -> typically 5432 for postgres
   */
  port?: number;

  /**
   * .what = the cluster status
   * .note = is @metadata
   */
  status?: string;
}

export class DeclaredAwsRdsCluster
  extends DomainEntity<DeclaredAwsRdsCluster>
  implements DeclaredAwsRdsCluster
{
  public static unique = ['name'] as const;
}
```

### 3. `DeclaredAwsVpcTunnel`

```typescript
// src/domain.objects/DeclaredAwsVpcTunnel.ts

import { DomainEntity, RefByUnique } from 'domain-objects';
import { DeclaredAwsEc2Instance } from './DeclaredAwsEc2Instance';
import { DeclaredAwsRdsCluster } from './DeclaredAwsRdsCluster';

/**
 * .what = a declarative structure representing a VPC tunnel
 * .why = enables declarative control of SSM port-forwarding tunnels to private resources
 */
export interface DeclaredAwsVpcTunnel {
  /**
   * .what = the bastion instance to tunnel through and the mechanism
   */
  via: {
    mechanism: 'aws.ssm';
    bastion: RefByUnique<typeof DeclaredAwsEc2Instance>;
  };

  /**
   * .what = the target resource to tunnel into
   */
  into: {
    cluster: RefByUnique<typeof DeclaredAwsRdsCluster>;
  };

  /**
   * .what = the local binding for the tunnel
   */
  from: {
    host: string;  // typically 'localhost'
    port: number;  // local port to bind
  };

  /**
   * .what = the current tunnel status
   * .note = 'OPEN' when tunnel is active, 'CLOSED' when not
   */
  status?: 'OPEN' | 'CLOSED';

  /**
   * .what = the process id of the tunnel subprocess
   * .note = is @metadata -> only present when tunnel is OPEN
   */
  pid?: number;
}

export class DeclaredAwsVpcTunnel
  extends DomainEntity<DeclaredAwsVpcTunnel>
  implements DeclaredAwsVpcTunnel
{
  public static unique = ['via', 'into', 'from'] as const;
}
```

---

## domain operations

### 1. `getEc2Instance`

```typescript
// src/domain.operations/ec2Instance/getEc2Instance.ts

import {
  EC2Client,
  DescribeInstancesCommand,
} from '@aws-sdk/client-ec2';
import { asProcedure } from 'as-procedure';
import { isUniqueKeyRef, Ref, RefByPrimary, RefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata, PickOne } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsEc2Instance } from '../../domain.objects/DeclaredAwsEc2Instance';
import { castToDeclaredAwsEc2Instance } from './castToDeclaredAwsEc2Instance';

/**
 * .what = gets an EC2 instance from AWS
 * .why = enables lookup of EC2 instances by tag or instance id
 */
export const getEc2Instance = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsEc2Instance>;
        unique: RefByUnique<typeof DeclaredAwsEc2Instance>;
        ref: Ref<typeof DeclaredAwsEc2Instance>;
      }>;
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance> | null> => {
    // handle by ref
    if (input.by.ref)
      return isUniqueKeyRef({ of: DeclaredAwsEc2Instance })(input.by.ref)
        ? getEc2Instance({ by: { unique: input.by.ref } }, context)
        : getEc2Instance({ by: { primary: input.by.ref } }, context);

    const ec2 = new EC2Client({ region: context.aws.region });

    // build filters based on lookup method
    const command = (() => {
      if (input.by.primary)
        return new DescribeInstancesCommand({
          InstanceIds: [input.by.primary.instanceId],
        });
      if (input.by.unique)
        return new DescribeInstancesCommand({
          Filters: [{ Name: 'tag:exid', Values: [input.by.unique.exid] }],
        });
      throw new UnexpectedCodePathError(
        'not referenced by primary nor unique. how not?',
        { input },
      );
    })();

    const response = await ec2.send(command);

    // extract instances from response
    const [instance, ...collisions] = response.Reservations?.flatMap((r) => r.Instances ?? []) ?? [];
    if (!instance) return null;

    // failfast if more than one instance found
    if (collisions.length)
      throw new UnexpectedCodePathError(
        'multiple ec2 instances found; expected exactly one',
        { input, count: collisions.length + 1 },
      );

    return castToDeclaredAwsEc2Instance(instance);
  },
);
```

### 2. `setEc2InstanceStatus`

```typescript
// src/domain.operations/ec2Instance/setEc2InstanceStatus.ts

import {
  EC2Client,
  StartInstancesCommand,
  StopInstancesCommand,
  waitUntilInstanceRunning,
  waitUntilInstanceStopped,
} from '@aws-sdk/client-ec2';
import { asProcedure } from 'as-procedure';
import { RefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsEc2Instance } from '../../domain.objects/DeclaredAwsEc2Instance';
import { getEc2Instance } from './getEc2Instance';

/**
 * .what = sets an EC2 instance status (running/stopped)
 * .why = enables declarative control of EC2 instance lifecycle
 */
export const setEc2InstanceStatus = asProcedure(
  async (
    input: {
      by: {
        instance: RefByUnique<typeof DeclaredAwsEc2Instance>;
      };
      to: {
        status: 'running' | 'stopped';
      };
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance>> => {
    const ec2 = new EC2Client({ region: context.aws.region });

    // resolve the instance
    const instance = await getEc2Instance({ by: { unique: input.by.instance } }, context);
    if (!instance?.instanceId)
      throw new UnexpectedCodePathError('ec2 instance not found', { input });

    // skip if already in desired status
    if (instance.status === input.to.status) return instance;

    // start or stop based on desired status
    if (input.to.status === 'running') {
      await ec2.send(new StartInstancesCommand({ InstanceIds: [instance.instanceId] }));
      await waitUntilInstanceRunning(
        { client: ec2, maxWaitTime: 300 },
        { InstanceIds: [instance.instanceId] },
      );
    } else {
      await ec2.send(new StopInstancesCommand({ InstanceIds: [instance.instanceId] }));
      await waitUntilInstanceStopped(
        { client: ec2, maxWaitTime: 300 },
        { InstanceIds: [instance.instanceId] },
      );
    }

    // return updated instance
    const updated = await getEc2Instance({ by: { unique: input.by.instance } }, context);
    if (!updated) throw new UnexpectedCodePathError('instance disappeared after status change', { input });
    return updated;
  },
);
```

### 3. `getRdsCluster`

```typescript
// src/domain.operations/rdsCluster/getRdsCluster.ts

import {
  RDSClient,
  DescribeDBClustersCommand,
} from '@aws-sdk/client-rds';
import { asProcedure } from 'as-procedure';
import { RefByUnique } from 'domain-objects';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsRdsCluster } from '../../domain.objects/DeclaredAwsRdsCluster';
import { castToDeclaredAwsRdsCluster } from './castToDeclaredAwsRdsCluster';

/**
 * .what = gets an RDS cluster from AWS
 * .why = enables lookup of RDS cluster endpoints and metadata
 */
export const getRdsCluster = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsRdsCluster> };
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsRdsCluster> | null> => {
    const rds = new RDSClient({ region: context.aws.region });

    const command = new DescribeDBClustersCommand({
      DBClusterIdentifier: input.by.unique.name,
    });

    try {
      const response = await rds.send(command);
      const cluster = response.DBClusters?.[0];
      if (!cluster) return null;
      return castToDeclaredAwsRdsCluster(cluster);
    } catch (error) {
      if (error instanceof Error && error.name === 'DBClusterNotFoundFault')
        return null;
      throw error;
    }
  },
);
```

### 4. tunnel utilities

```typescript
// src/domain.operations/vpcTunnel/utils/getTunnelHash.ts

import * as crypto from 'crypto';

/**
 * .what = generates a deterministic hash for a tunnel configuration
 * .why = enables consistent identification of tunnels across process restarts
 */
export const getTunnelHash = (input: {
  instanceId: string;
  remoteHost: string;
  remotePort: number;
  localPort: number;
}): string => {
  return crypto
    .createHash('sha256')
    .update(`${input.instanceId}:${input.remoteHost}:${input.remotePort}:${input.localPort}`)
    .digest('hex')
    .slice(0, 16);
};
```

```typescript
// src/domain.operations/vpcTunnel/utils/isPortInUse.ts

import * as net from 'net';

/**
 * .what = checks if a local port is currently in use
 * .why = enables detection of existing tunnels or port conflicts
 */
export const isPortInUse = async (input: { port: number }): Promise<boolean> => {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.once('error', (err: NodeJS.ErrnoException) => {
      resolve(err.code === 'EADDRINUSE');
    });
    server.once('listening', () => {
      server.close();
      resolve(false);
    });
    server.listen(input.port, '127.0.0.1');
  });
};
```

```typescript
// src/domain.operations/vpcTunnel/utils/isTunnelHealthy.ts

import * as net from 'net';

/**
 * .what = checks if a tunnel is accepting connections
 * .why = verifies tunnel is functional beyond just port binding
 */
export const isTunnelHealthy = async (input: { port: number }): Promise<boolean> => {
  return new Promise((resolve) => {
    const socket = new net.Socket();
    socket.setTimeout(5000);
    socket.once('connect', () => {
      socket.destroy();
      resolve(true);
    });
    socket.once('error', () => resolve(false));
    socket.once('timeout', () => {
      socket.destroy();
      resolve(false);
    });
    socket.connect(input.port, '127.0.0.1');
  });
};
```

```typescript
// src/domain.operations/vpcTunnel/utils/isProcessAlive.ts

/**
 * .what = checks if a process with given pid is still running
 * .why = enables detection of crashed tunnel processes
 */
export const isProcessAlive = (input: { pid: number }): boolean => {
  try {
    process.kill(input.pid, 0); // signal 0 = check existence only
    return true;
  } catch {
    return false;
  }
};
```

### 5. `setVpcTunnel` (the main orchestrator)

```typescript
// src/domain.operations/vpcTunnel/setVpcTunnel.ts

import { spawn } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import { asProcedure } from 'as-procedure';
import { UnexpectedCodePathError } from 'helpful-errors';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsVpcTunnel } from '../../domain.objects/DeclaredAwsVpcTunnel';
import { getEc2Instance } from '../ec2Instance/getEc2Instance';
import { setEc2InstanceStatus } from '../ec2Instance/setEc2InstanceStatus';
import { getRdsCluster } from '../rdsCluster/getRdsCluster';
import { getTunnelHash } from './utils/getTunnelHash';
import { isPortInUse } from './utils/isPortInUse';
import { isTunnelHealthy } from './utils/isTunnelHealthy';
import { isProcessAlive } from './utils/isProcessAlive';

const TUNNELS_DIR = path.join(os.homedir(), '.declastruct', 'tunnels');

/**
 * .what = opens or closes a VPC tunnel
 * .why = enables declarative control of SSM port-forwarding tunnels
 */
export const setVpcTunnel = asProcedure(
  async (
    input: DeclaredAwsVpcTunnel & { status: 'OPEN' | 'CLOSED' },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsVpcTunnel>> => {
    // ensure tunnels directory exists
    await fs.mkdir(TUNNELS_DIR, { recursive: true });

    // resolve bastion and cluster for tunnel hash
    const bastion = await getEc2Instance({ by: { unique: input.via.bastion } }, context);
    if (!bastion?.instanceId) throw new UnexpectedCodePathError('bastion not found', { input });

    const cluster = await getRdsCluster({ by: { unique: input.into.cluster } }, context);
    if (!cluster?.host?.writer || !cluster.port)
      throw new UnexpectedCodePathError('cluster endpoint not found', { input });

    // compute tunnel identity
    const tunnelHash = getTunnelHash({
      instanceId: bastion.instanceId,
      remoteHost: cluster.host.writer,
      remotePort: cluster.port,
      localPort: input.from.port,
    });
    const pidPath = path.join(TUNNELS_DIR, `${tunnelHash}.pid`);
    const metaPath = path.join(TUNNELS_DIR, `${tunnelHash}.meta`);

    // handle CLOSED status
    if (input.status === 'CLOSED') {
      try {
        const pidStr = await fs.readFile(pidPath, 'utf-8');
        const pid = parseInt(pidStr, 10);
        if (isProcessAlive({ pid })) {
          process.kill(pid, 'SIGTERM');
        }
      } catch {
        // pidfile doesn't exist or can't be read; tunnel already closed
      }

      // cleanup files
      await fs.rm(pidPath, { force: true });
      await fs.rm(metaPath, { force: true });

      return new DeclaredAwsVpcTunnel({ ...input, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;
    }

    // handle OPEN status

    // check if tunnel already exists
    const portInUse = await isPortInUse({ port: input.from.port });
    if (portInUse) {
      // check if it's our tunnel
      try {
        const pidStr = await fs.readFile(pidPath, 'utf-8');
        const pid = parseInt(pidStr, 10);
        if (isProcessAlive({ pid })) {
          // verify tunnel is healthy
          const healthy = await isTunnelHealthy({ port: input.from.port });
          if (healthy) {
            return new DeclaredAwsVpcTunnel({ ...input, status: 'OPEN', pid }) as HasMetadata<DeclaredAwsVpcTunnel>;
          }
          // tunnel process alive but not healthy; kill and respawn
          process.kill(pid, 'SIGTERM');
        }
      } catch {
        // pidfile doesn't exist; another process owns the port
        throw new UnexpectedCodePathError('port is in use by another process', {
          port: input.from.port,
        });
      }
    }

    // start bastion if not running
    if (bastion.status !== 'running') {
      await setEc2InstanceStatus(
        { by: { instance: input.via.bastion }, to: { status: 'running' } },
        context,
      );
    }

    // spawn SSM tunnel subprocess
    const tunnelProcess = spawn('aws', [
      'ssm', 'start-session',
      '--target', bastion.instanceId,
      '--document-name', 'AWS-StartPortForwardingSessionToRemoteHost',
      '--parameters', JSON.stringify({
        host: [cluster.host.writer],
        portNumber: [String(cluster.port)],
        localPortNumber: [String(input.from.port)],
      }),
      ...(context.aws.region ? ['--region', context.aws.region] : []),
    ], {
      stdio: 'pipe',
      detached: true,
    });

    // detach so tunnel survives parent process exit
    tunnelProcess.unref();

    // wait for tunnel to be ready
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('tunnel startup timeout')), 30_000);

      tunnelProcess.stdout?.on('data', (data: Buffer) => {
        if (data.toString().includes('Waiting for connections')) {
          clearTimeout(timeout);
          resolve();
        }
      });

      tunnelProcess.stderr?.on('data', (data: Buffer) => {
        context.log?.debug?.('tunnel stderr', { data: data.toString() });
      });

      tunnelProcess.on('error', (err) => {
        clearTimeout(timeout);
        reject(err);
      });

      tunnelProcess.on('exit', (code) => {
        if (code !== 0) {
          clearTimeout(timeout);
          reject(new Error(`tunnel exited with code ${code}`));
        }
      });
    });

    // verify tunnel is healthy (can reach database)
    const healthy = await isTunnelHealthy({ port: input.from.port });
    if (!healthy) {
      tunnelProcess.kill('SIGTERM');
      throw new UnexpectedCodePathError('tunnel started but database not reachable', { input });
    }

    // persist tunnel state
    await fs.writeFile(pidPath, String(tunnelProcess.pid));
    await fs.writeFile(metaPath, JSON.stringify(input, null, 2));

    return new DeclaredAwsVpcTunnel({
      ...input,
      status: 'OPEN',
      pid: tunnelProcess.pid,
    }) as HasMetadata<DeclaredAwsVpcTunnel>;
  },
);
```

### 6. `getVpcTunnel`

```typescript
// src/domain.operations/vpcTunnel/getVpcTunnel.ts

import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import { asProcedure } from 'as-procedure';
import { HasMetadata } from 'type-fns';
import { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsVpcTunnel } from '../../domain.objects/DeclaredAwsVpcTunnel';
import { getEc2Instance } from '../ec2Instance/getEc2Instance';
import { getRdsCluster } from '../rdsCluster/getRdsCluster';
import { getTunnelHash } from './utils/getTunnelHash';
import { isProcessAlive } from './utils/isProcessAlive';
import { isTunnelHealthy } from './utils/isTunnelHealthy';

const TUNNELS_DIR = path.join(os.homedir(), '.declastruct', 'tunnels');

/**
 * .what = gets the current status of a VPC tunnel
 * .why = enables checking if a tunnel is currently open and healthy
 */
export const getVpcTunnel = asProcedure(
  async (
    input: Omit<DeclaredAwsVpcTunnel, 'status' | 'pid'>,
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsVpcTunnel>> => {
    // resolve bastion and cluster
    const bastion = await getEc2Instance({ by: { unique: input.via.bastion } }, context);
    const cluster = await getRdsCluster({ by: { unique: input.into.cluster } }, context);

    // if either not found, tunnel is effectively closed
    if (!bastion?.instanceId || !cluster?.host?.writer || !cluster.port) {
      return new DeclaredAwsVpcTunnel({ ...input, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;
    }

    // compute tunnel identity
    const tunnelHash = getTunnelHash({
      instanceId: bastion.instanceId,
      remoteHost: cluster.host.writer,
      remotePort: cluster.port,
      localPort: input.from.port,
    });
    const pidPath = path.join(TUNNELS_DIR, `${tunnelHash}.pid`);

    // check pidfile and process
    try {
      const pidStr = await fs.readFile(pidPath, 'utf-8');
      const pid = parseInt(pidStr, 10);

      if (isProcessAlive({ pid })) {
        const healthy = await isTunnelHealthy({ port: input.from.port });
        if (healthy) {
          return new DeclaredAwsVpcTunnel({ ...input, status: 'OPEN', pid }) as HasMetadata<DeclaredAwsVpcTunnel>;
        }
      }
    } catch {
      // pidfile doesn't exist
    }

    return new DeclaredAwsVpcTunnel({ ...input, status: 'CLOSED' }) as HasMetadata<DeclaredAwsVpcTunnel>;
  },
);
```

---

## dependencies to add

```bash
npm install @aws-sdk/client-ec2 @aws-sdk/client-rds
```

note: `@aws-sdk/client-ssm` is **not needed** since we spawn the AWS CLI directly

---

## usage example

```typescript
import { RefByUnique } from 'domain-objects';
import {
  DeclaredAwsEc2Instance,
  DeclaredAwsRdsCluster,
  DeclaredAwsVpcTunnel,
  setVpcTunnel,
  getVpcTunnel,
} from 'declastruct-aws';

// declare references
const bastion = RefByUnique<typeof DeclaredAwsEc2Instance>.as({
  exid: 'vpc-main-bastion',
});

const cluster = RefByUnique<typeof DeclaredAwsRdsCluster>.as({
  name: 'ahbodedb',
});

const tunnel = new DeclaredAwsVpcTunnel({
  via: { mechanism: 'aws.ssm', bastion },
  into: { cluster },
  from: { host: 'localhost', port: 7775432 },
});

// open the tunnel (starts bastion if needed, waits for db reachable)
await setVpcTunnel(
  { ...tunnel, status: 'OPEN' },
  { aws: { region: 'us-east-1' }, log: console },
);

// ... use database at localhost:7775432 ...
// tunnel persists even after this process exits

// check tunnel status later
const current = await getVpcTunnel(tunnel, { aws: { region: 'us-east-1' }, log: console });
console.log(current.status); // 'OPEN' or 'CLOSED'

// close the tunnel
await setVpcTunnel(
  { ...tunnel, status: 'CLOSED' },
  { aws: { region: 'us-east-1' }, log: console },
);
```

---

## tunnel tracking strategy

per research (`3.1.research.v2.i1.md`), tunnels are tracked via:

1. **pidfile**: `~/.declastruct/tunnels/{tunnelHash}.pid` — contains subprocess pid
2. **metafile**: `~/.declastruct/tunnels/{tunnelHash}.meta` — contains tunnel config JSON
3. **port check**: native `net.Server` to detect if port is in use
4. **process check**: `process.kill(pid, 0)` to verify process alive
5. **health probe**: TCP connect to verify tunnel is forwarding

**tunnel identity formula**:
```typescript
tunnelHash = sha256(`${instanceId}:${remoteHost}:${remotePort}:${localPort}`).slice(0, 16)
```

**edge cases handled**:
| case | resolution |
|------|------------|
| process crashes | pidfile remains, but `isProcessAlive` fails → cleanup and respawn |
| port collision | pidfile doesn't exist → fail with clear error |
| tunnel alive but unhealthy | kill and respawn |
| tunnel already open | return existing tunnel info (idempotent) |

---

## files to create

| file | purpose |
|------|---------|
| `src/domain.objects/DeclaredAwsEc2Instance.ts` | EC2 instance domain object |
| `src/domain.objects/DeclaredAwsRdsCluster.ts` | RDS cluster domain object |
| `src/domain.objects/DeclaredAwsVpcTunnel.ts` | VPC tunnel domain object |
| `src/domain.operations/ec2Instance/getEc2Instance.ts` | get EC2 by tag/id |
| `src/domain.operations/ec2Instance/setEc2InstanceStatus.ts` | start/stop EC2 |
| `src/domain.operations/ec2Instance/castToDeclaredAwsEc2Instance.ts` | AWS → domain cast |
| `src/domain.operations/rdsCluster/getRdsCluster.ts` | get RDS cluster |
| `src/domain.operations/rdsCluster/castToDeclaredAwsRdsCluster.ts` | AWS → domain cast |
| `src/domain.operations/vpcTunnel/setVpcTunnel.ts` | tunnel orchestrator |
| `src/domain.operations/vpcTunnel/getVpcTunnel.ts` | check tunnel status |
| `src/domain.operations/vpcTunnel/utils/getTunnelHash.ts` | tunnel identity hash |
| `src/domain.operations/vpcTunnel/utils/isPortInUse.ts` | port check |
| `src/domain.operations/vpcTunnel/utils/isTunnelHealthy.ts` | TCP health probe |
| `src/domain.operations/vpcTunnel/utils/isProcessAlive.ts` | process existence check |
| `src/contract/sdks/index.ts` | update exports |

---

## test strategy

- **unit tests**: mock AWS SDK clients, verify correct commands sent
- **integration tests**: require real AWS credentials, test against actual bastion/RDS
- **acceptance tests**: end-to-end tunnel open/close with database connectivity verification

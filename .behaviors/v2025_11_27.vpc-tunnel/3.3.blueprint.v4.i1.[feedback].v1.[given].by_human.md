emit your response to the feedback into .behaviors/v2025_11_27.vpc-tunnel/3.3.blueprint.v4.i1.[feedback].v1.[taken].by_robot.md

emit your updated blueprint .behaviors/v2025_11_27.vpc-tunnel/3.3.blueprint.v5.i1.md

---

reboot your mechanics briefs first.

npx rhachet roles boot --repo ehmpathy --role mechanic

then address the blockers and nitpicks below

---

# blocker.1

use `serialize` from domain-objects instead of json.stringify

       464      // serialize the tunnel ref to create deterministic identity
       465 -    const serialized = JSON.stringify({
       465 +    const serialized = serialize({
       466        via: input.for.tunnel.via,
       467        into: input.for.tunnel.into,
       468        from: input.for.tunnel.from,

---

# blocker.2


/**
 * .what = schema for tunnel cache file contents
 * .why = single file containing both pid and tunnel metadata
 */
export interface TunnelCacheFile {
  pid: number;
  tunnel: DeclaredAwsVpcTunnel;
}
```

tunnel should only beRefByUnique

/**
 * .what = schema for tunnel cache file contents
 * .why = single file containing both pid and tunnel metadata
 */
export interface TunnelCacheFile {
  pid: number;
  tunnel: RefByUnique<typeof DeclaredAwsVpcTunnel>;
}
```

we dont care about mutable state; we only care about the reference (ref by unique)



----


# nitpick.3


    if (!bastion.id)
      throw UnexpectedCodePathError.throw('bastion found but has no id', { bastion });


no need for these checks, since getEc2Instance should return `HasMetadata<DeclaredAwsEc2Instance>`, which will already assure typescript that the id is present


----


# blocker.4

dont forget to create/update the getDeclastructAwsProvider factory which will instantiate the context with the default paths and etc

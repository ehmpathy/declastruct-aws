emit your response to the feedback into .behaviors/v2025_11_27.vpc-tunnel/3.3.blueprint.v1.i1.[feedback].v1.[taken].by_robot.md

emit your updated blueprint .behaviors/v2025_11_27.vpc-tunnel/3.3.blueprint.v2.i1.md

---

# blocker.1

dont track tunnels in memory; this process wont be active long. it'll terminate after operation immediately

we need a stateful way to track which tunnels are active on the caller machine

reference .behaviors/v2025_11_27.vpc-tunnel/3.1.research.v2.i1.md for how to do this best

----


# blocker.2

expect these resources to be generically useful

dont scope the "why" comments to just one usecase

e.g.,


 * .why = enables declarative reference to bastion hosts for VPC tunneling


----


# nitpick.3



  /**
   * .what = the writer endpoint hostname
   * .note = is @metadata -> resolved from AWS
   */
  endpoint?: string;

  /**
   * .what = the reader endpoint hostname
   * .note = is @metadata -> resolved from AWS
   */
  readerEndpoint?: string;


lets use term

`host?: {
  writer,
  reader,
}`

instead of endpoint and reader endpoint


----

# nitpick.4

lets add into


  /**
   * .what = the bastion instance to tunnel through
   */
  via: {
    bastion: RefByUnique<typeof DeclaredAwsEc2Instance>;
  };

the qualifier that its also via the mechanism of ssm

e.g.,


  /**
   * .what = the bastion instance to tunnel through
   */
  via: {
    mechanism: 'aws.ssm',
    bastion: RefByUnique<typeof DeclaredAwsEc2Instance>;
  };

to qualify that its specifically via the ssm mechanism, in case other forms of tunnels are establishable in the future


---

# blocker.5


export const getEc2Instance = asProcedure(
  async (
    input: {
      by: PickOne<{
        instanceId: string;
        unique: RefByUnique<typeof DeclaredAwsEc2Instance>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ):


  =>



export const getEc2Instance = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsEc2Instance>;
        unique: RefByUnique<typeof DeclaredAwsEc2Instance>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ):


----

# blocker.6

use `ContextLogTrail` from 'simple-log-methods' rather than VisualogicContext


----


# blocker.7


/**
 * .what = sets an EC2 instance state (start/stop)
 * .why = enables starting/stopping bastion hosts for VPC tunneling
 */
export const setEc2Instance = asProcedure(
  async (
    input: {
      ref: RefByUnique<typeof DeclaredAwsEc2Instance>;
      state: 'running' | 'stopped';
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance>> => {


=>


/**
 * .what = sets an EC2 instance state (start/stop)
 * .why = enables starting/stopping bastion hosts for VPC tunneling
 */
export const setEc2InstanceStatus = asProcedure(
  async (
    input: {
      by: {
        instance: RefByUnique<typeof DeclaredAwsEc2Instance>;
      },
      to: {
        status: DeclaredAwsEc2Instance['status']['running'] | DeclaredAwsEc2Instance['status']['stopped']
      }
    },
    context: ContextAwsApi & ContextLogTrail,
  ): Promise<HasMetadata<DeclaredAwsEc2Instance>> => {


that way, we keep `setEc2Instance` open for actual creation/updates of new instance structures
rather than their current operational status
and can use `setEc2InstanceStatus` in a way that guarantees we wont change anything except status; simpler scope


also, prefer DeclaredAwsEc2Instance.status over .state

.state is ambiguious


----


# blocker.8

upon open of tunnel, wait until we can ping that database too; we should be able to reach it through the tunnel to check our work

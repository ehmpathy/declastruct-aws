# feedback response: blueprint v2

## blocker.1 — BadRequestError + rename instanceId to id

**issue**:
- using `if (!instance?.instanceId)` with `UnexpectedCodePathError` instead of `BadRequestError`
- `instanceId` is redundant since domain entity name already implies "instance"

**resolution**:
- switched to `BadRequestError.throw()` with nullish coalescing for cleaner one-liner
- renamed `instanceId` to `id` throughout `DeclaredAwsEc2Instance`
- `getEc2Instance` now guarantees `id` is present in output (required field after cast)

---

## blocker.2 — support both Ref types

**issue**: `setEc2InstanceStatus` only accepts `RefByUnique`, not `RefByPrimary`

**resolution**: changed signature to accept `Ref<typeof DeclaredAwsEc2Instance>` which supports both

---

## blocker.3 — no if/else, use IIFE with early returns

**issue**: start/stop logic used `if/else` block

**resolution**: replaced with IIFE using early returns and failfast:
```typescript
await (async () => {
  if (input.to.status === 'running') {
    await ec2.send(new StartInstancesCommand(...));
    await waitUntilInstanceRunning(...);
    return;
  }
  if (input.to.status === 'stopped') {
    await ec2.send(new StopInstancesCommand(...));
    await waitUntilInstanceStopped(...);
    return;
  }
  throw UnexpectedCodePathError.throw('unsupported status', { input });
})();
```

---

## nitpick.4 — cleaner updated instance check

**issue**: verbose `if (!updated) throw` pattern

**resolution**: switched to nullish coalescing with `.throw()`:
```typescript
const updated = await getEc2Instance(...) ??
  UnexpectedCodePathError.throw('how can instance not be found after status update?', { input, instance: { before: instance } });
```

---

## blocker.5 — reject unexpected errors in isPortInUse

**issue**: `server.once('error', ...)` resolved for any error, potential failhide

**resolution**: only resolve `true` for `EADDRINUSE`, reject for any other error code

---

## blocker.6 — tunnels dir from context

**issue**: hardcoded `TUNNELS_DIR` path

**resolution**: moved to `ContextAwsApi.cache.DeclaredAwsVpcTunnel.processes.dir` with default fallback to `~/.declastruct/tunnels`

---

## blocker.7 — getTunnelHash with domain object input

**issue**: `getTunnelHash` accepted bag-of-words instead of domain object reference

**resolution**: changed signature to:
```typescript
getTunnelHash({ for: { tunnel: RefByUnique<typeof DeclaredAwsVpcTunnel> } }, context)
```
internally resolves bastion/cluster to compute hash

---

## blocker.8 — no failhide in CLOSED status handling

**issue**: bare `catch {}` swallowed all errors when reading pidfile

**resolution**: explicit error handling with allowlist:
- `ENOENT` (file not found) → tunnel already closed, proceed
- any other error → rethrow

---

## blocker.9 — eliminate try/catch in port-in-use check

**issue**: nested try/catch with implicit error handling for pidfile read

**resolution**:
- use explicit `fs.access()` or `fs.stat()` to check file existence
- linear narrative flow with early returns
- no failhide hazards

---

## blocker.10 — persist tunnel state earlier

**issue**: pidfile written after tunnel fully ready, causing recovery issues if process exits mid-startup

**resolution**: persist pidfile immediately after spawn, before waiting for "Waiting for connections"
- enables recovery: if port is in use and pidfile exists, can wait for tunnel to become healthy
- metafile still written after health check confirms tunnel is functional

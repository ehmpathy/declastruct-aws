# Implementation Blueprint: Lambda Log Trends

## Overview

This blueprint describes the implementation plan for fulfilling the wish declared in `0.wish.md` using the domain distillation from `3.2.distill.aws.domain.v1.i1.md`, following the patterns established in this repository.

---

## File Structure

```
src/
├── domain.objects/
│   ├── DeclaredAwsLogGroup.ts                           # Entity
│   ├── DeclaredAwsLogGroup.test.ts                      # Unit tests
│   ├── DeclaredAwsLogGroupReportDistOfPattern.ts        # Entity (readonly)
│   ├── DeclaredAwsLogGroupReportDistOfPattern.test.ts   # Unit tests
│   ├── DeclaredAwsLogGroupReportCostOfIngestion.ts      # Entity (readonly)
│   └── DeclaredAwsLogGroupReportCostOfIngestion.test.ts # Unit tests
│
├── domain.operations/
│   ├── logGroup/
│   │   ├── getOneLogGroup.ts                            # Get by primary/unique
│   │   ├── getOneLogGroup.test.ts                       # Unit tests
│   │   ├── getOneLogGroup.integration.test.ts           # Integration tests
│   │   ├── getAllLogGroups.ts                           # Get by prefix
│   │   ├── getAllLogGroups.test.ts                      # Unit tests
│   │   ├── getAllLogGroups.integration.test.ts          # Integration tests
│   │   └── castIntoDeclaredAwsLogGroup.ts               # AWS SDK → Domain Object
│   │
│   ├── logGroupReportDistOfPattern/
│   │   ├── getOneLogGroupReportDistOfPattern.ts                   # Main operation
│   │   ├── getOneLogGroupReportDistOfPattern.test.ts              # Unit tests
│   │   ├── getOneLogGroupReportDistOfPattern.integration.test.ts  # Integration tests
│   │   └── castIntoDeclaredAwsLogGroupReportDistOfPattern.ts      # Query results → Domain Object
│   │
│   └── logGroupReportCostOfIngestion/
│       ├── getOneLogGroupReportCostOfIngestion.ts                  # Main operation
│       ├── getOneLogGroupReportCostOfIngestion.test.ts             # Unit tests
│       ├── getOneLogGroupReportCostOfIngestion.integration.test.ts # Integration tests
│       └── castIntoDeclaredAwsLogGroupReportCostOfIngestion.ts     # Metrics → Domain Object
│
├── access/
│   └── daos/
│       ├── DeclaredAwsLogGroupDao.ts
│       ├── DeclaredAwsLogGroupReportDistOfPatternDao.ts
│       └── DeclaredAwsLogGroupReportCostOfIngestionDao.ts
│
└── contract/
    └── sdks/
        └── index.ts  # Add exports
```

---

## Implementation Steps

### Phase 1: Domain Objects

#### Step 1.1: Create `DeclaredAwsLogGroup.ts`

**File**: `src/domain.objects/DeclaredAwsLogGroup.ts`

```typescript
import { UniDateTime } from '@ehmpathy/uni-time';
import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure representing an AWS CloudWatch Log Group
 * .note = for lambda functions, automatically created as /aws/lambda/<function-name>
 */
export interface DeclaredAwsLogGroup {
  /**
   * .what = the arn of the log group
   * .note = @metadata — assigned by AWS
   */
  arn?: string;

  /**
   * .what = the name of the log group
   * .note = @unique
   * .example = '/aws/lambda/svc-chat-prod-getDisplayableMessages'
   */
  name: string;

  /**
   * .what = the log group class
   */
  class: 'STANDARD' | 'INFREQUENT_ACCESS' | 'DELIVERY';

  /**
   * .what = optional KMS key for encryption
   */
  kmsKeyId: string | null;

  /**
   * .what = retention period in days
   * .note = @readonly — null means never expire
   */
  retentionInDays?: number | null;

  /**
   * .what = when the log group was created
   * .note = @readonly
   */
  createdAt?: UniDateTime;

  /**
   * .what = total bytes stored in the log group
   * .note = @readonly — updates with ~24hr delay
   */
  storedBytes?: number;
}

export class DeclaredAwsLogGroup
  extends DomainEntity<DeclaredAwsLogGroup>
  implements DeclaredAwsLogGroup
{
  public static primary = ['arn'] as const;
  public static unique = ['name'] as const;
  public static metadata = ['arn'] as const;
  public static readonly = ['storedBytes', 'createdAt', 'retentionInDays'] as const;
}
```

#### Step 1.2: Create `DeclaredAwsLogGroupReportDistOfPattern.ts`

**File**: `src/domain.objects/DeclaredAwsLogGroupReportDistOfPattern.ts`

```typescript
import { UniDateTimeRange } from '@ehmpathy/uni-time';
import { DomainEntity, DomainLiteral, RefByUnique } from 'domain-objects';

import { DeclaredAwsLogGroup } from './DeclaredAwsLogGroup';

/**
 * .what = a single row in a pattern distribution report
 */
export interface DeclaredAwsLogGroupReportDistOfPatternRow {
  value: string;
  frequency: number;
  totalBytes: number;
  avgBytes: number;
  percentOfTotal: {
    frequency: number;
    bytes: number;
  };
}

export class DeclaredAwsLogGroupReportDistOfPatternRow
  extends DomainLiteral<DeclaredAwsLogGroupReportDistOfPatternRow>
  implements DeclaredAwsLogGroupReportDistOfPatternRow {}

/**
 * .what = distribution report of a pattern field for a set of log groups over a time range
 * .why = enables declarative analysis of log patterns and their sizes
 */
export interface DeclaredAwsLogGroupReportDistOfPattern {
  logGroups: RefByUnique<typeof DeclaredAwsLogGroup>[];
  range: UniDateTimeRange;
  pattern: string;
  filter: string | null;
  limit: number | null;
  scannedBytes?: number;
  matchedEvents?: number;
  entries?: DeclaredAwsLogGroupReportDistOfPatternRow[];
}

export class DeclaredAwsLogGroupReportDistOfPattern
  extends DomainEntity<DeclaredAwsLogGroupReportDistOfPattern>
  implements DeclaredAwsLogGroupReportDistOfPattern
{
  public static primary = [] as const;
  public static unique = ['logGroups', 'range', 'pattern', 'filter', 'limit'] as const;
  public static metadata = [] as const;
  public static readonly = ['entries', 'scannedBytes', 'matchedEvents'] as const;

  public static nested = {
    logGroups: RefByUnique<typeof DeclaredAwsLogGroup>,
    entries: DeclaredAwsLogGroupReportDistOfPatternRow,
  };
}
```

#### Step 1.3: Create `DeclaredAwsLogGroupReportCostOfIngestion.ts`

**File**: `src/domain.objects/DeclaredAwsLogGroupReportCostOfIngestion.ts`

```typescript
import { UniDateTimeRange } from '@ehmpathy/uni-time';
import { DomainEntity, DomainLiteral } from 'domain-objects';
import { PickOne } from 'type-fns';

/**
 * .what = a filter to select log groups by prefix or explicit names
 */
export type DeclaredAwsLogGroupFilter = PickOne<{
  prefix: string;
  names: string[];
}>;

/**
 * .what = a single row of log group ingestion cost data
 */
export interface DeclaredAwsLogGroupReportCostOfIngestionRow {
  logGroupName: string;
  ingestedBytes: number;
  logEvents: number;
  estimatedCostUsd: number;
  percentOfTotal: {
    bytes: number;
    events: number;
  };
}

export class DeclaredAwsLogGroupReportCostOfIngestionRow
  extends DomainLiteral<DeclaredAwsLogGroupReportCostOfIngestionRow>
  implements DeclaredAwsLogGroupReportCostOfIngestionRow {}

/**
 * .what = aggregated ingestion cost report for log groups over a time range
 * .why = enables declarative understanding of CloudWatch Logs costs
 */
export interface DeclaredAwsLogGroupReportCostOfIngestion {
  logGroupFilter: DeclaredAwsLogGroupFilter;
  range: UniDateTimeRange;
  totalIngestedBytes?: number;
  totalLogEvents?: number;
  totalEstimatedCostUsd?: number;
  entries?: DeclaredAwsLogGroupReportCostOfIngestionRow[];
}

export class DeclaredAwsLogGroupReportCostOfIngestion
  extends DomainEntity<DeclaredAwsLogGroupReportCostOfIngestion>
  implements DeclaredAwsLogGroupReportCostOfIngestion
{
  public static primary = [] as const;
  public static unique = ['logGroupFilter', 'range'] as const;
  public static metadata = [] as const;
  public static readonly = ['entries', 'totalIngestedBytes', 'totalLogEvents', 'totalEstimatedCostUsd'] as const;

  public static nested = {
    logGroupFilter: DomainLiteral,
    entries: DeclaredAwsLogGroupReportCostOfIngestionRow,
  };
}
```

---

### Phase 2: Domain Operations

#### Step 2.1: Create `getOneLogGroup.ts`

**File**: `src/domain.operations/logGroup/getOneLogGroup.ts`

**AWS SDK**: `@aws-sdk/client-cloudwatch-logs`
- `CloudWatchLogsClient`
- `DescribeLogGroupsCommand`

**Pattern**: Follow `getOneLambda.ts`
- Handle `by.primary`, `by.unique`, `by.ref`
- Use `DescribeLogGroupsCommand` with `logGroupNamePrefix` for exact match
- Return `null` if not found
- Cast via `castIntoDeclaredAwsLogGroup`

#### Step 2.2: Create `getAllLogGroups.ts`

**File**: `src/domain.operations/logGroup/getAllLogGroups.ts`

**AWS SDK**: `@aws-sdk/client-cloudwatch-logs`
- `CloudWatchLogsClient`
- `DescribeLogGroupsCommand`
- `paginateDescribeLogGroups` (for pagination)

**Pattern**: Follow `getAllLambdas.ts`
- Accept `by.prefix` filter
- Handle pagination
- Cast each result via `castIntoDeclaredAwsLogGroup`

#### Step 2.3: Create `castIntoDeclaredAwsLogGroup.ts`

**File**: `src/domain.operations/logGroup/castIntoDeclaredAwsLogGroup.ts`

**Input**: `LogGroup` from AWS SDK
**Output**: `HasReadonly<typeof DeclaredAwsLogGroup>`

**Mapping**:
```typescript
{
  arn: input.arn,
  name: input.logGroupName,
  class: input.logGroupClass ?? 'STANDARD',
  kmsKeyId: input.kmsKeyId ?? null,
  retentionInDays: input.retentionInDays ?? null,
  createdAt: input.creationTime ? new Date(input.creationTime).toISOString() : undefined,
  storedBytes: input.storedBytes,
}
```

#### Step 2.4: Create `getOneLogGroupReportDistOfPattern.ts`

**File**: `src/domain.operations/logGroupReportDistOfPattern/getOneLogGroupReportDistOfPattern.ts`

**AWS SDK**: `@aws-sdk/client-cloudwatch-logs`
- `CloudWatchLogsClient`
- `StartQueryCommand`
- `GetQueryResultsCommand`

**Implementation**:
1. Extract `logGroups`, `range`, `pattern`, `filter`, `limit` from unique key
2. Resolve log group names from refs
3. Build CloudWatch Logs Insights query:
   ```
   fields ${pattern}
   ${filter ? `| filter ${filter}` : ''}
   | stats count(*) as frequency,
           sum(strlen(${pattern})) as totalBytes,
           avg(strlen(${pattern})) as avgBytes
     by ${pattern}
   | sort frequency desc
   | limit ${limit ?? 1000}
   ```
4. Execute `StartQueryCommand`
5. Poll `GetQueryResultsCommand` until `status === 'Complete'`
6. Cast results via `castIntoDeclaredAwsLogGroupReportDistOfPattern`

**Error Handling**:
- Handle `status === 'Failed'` / `'Cancelled'` / `'Timeout'`
- Use exponential backoff for polling (start 1s, max 10s)

#### Step 2.5: Create `castIntoDeclaredAwsLogGroupReportDistOfPattern.ts`

**File**: `src/domain.operations/logGroupReportDistOfPattern/castIntoDeclaredAwsLogGroupReportDistOfPattern.ts`

**Input**:
- `input.by.unique` (the query parameters)
- `results` from `GetQueryResultsCommand`

**Output**: `HasReadonly<typeof DeclaredAwsLogGroupReportDistOfPattern>`

**Logic**:
1. Parse `results.results` array (each row is `Array<{ field: string, value: string }>`)
2. Extract `pattern`, `frequency`, `totalBytes`, `avgBytes` from each row
3. Calculate `percentOfTotal` for each row
4. Return domain object with readonly fields populated

#### Step 2.6: Create `getOneLogGroupReportCostOfIngestion.ts`

**File**: `src/domain.operations/logGroupReportCostOfIngestion/getOneLogGroupReportCostOfIngestion.ts`

**AWS SDK**:
- `@aws-sdk/client-cloudwatch-logs`: `CloudWatchLogsClient`, `DescribeLogGroupsCommand`
- `@aws-sdk/client-cloudwatch`: `CloudWatchClient`, `GetMetricDataCommand`

**Implementation**:
1. Extract `logGroupFilter`, `range` from unique key
2. Resolve target log groups:
   - If `prefix`: use `getAllLogGroups({ by: { prefix } })`
   - If `names`: use `Promise.all(names.map(getOneLogGroup))`
3. Build metric queries for each log group:
   - `IncomingBytes` (Sum)
   - `IncomingLogEvents` (Sum)
4. Execute `GetMetricDataCommand` (batch up to 500 metrics per request)
5. Cast results via `castIntoDeclaredAwsLogGroupReportCostOfIngestion`

**Cost Calculation**:
```typescript
const COST_PER_GB_USD = 0.50;
const estimatedCostUsd = (ingestedBytes / (1024 ** 3)) * COST_PER_GB_USD;
```

#### Step 2.7: Create `castIntoDeclaredAwsLogGroupReportCostOfIngestion.ts`

**File**: `src/domain.operations/logGroupReportCostOfIngestion/castIntoDeclaredAwsLogGroupReportCostOfIngestion.ts`

**Input**:
- `input.by.unique` (the query parameters)
- `logGroups` (resolved log group entities)
- `metrics` (response from `GetMetricDataCommand`)

**Output**: `HasReadonly<typeof DeclaredAwsLogGroupReportCostOfIngestion>`

**Logic**:
1. Match metric results to log groups by ID pattern
2. Calculate totals
3. Calculate `percentOfTotal` for each row
4. Sort by `ingestedBytes` descending
5. Return domain object with readonly fields populated

---

### Phase 3: Access DAOs

#### Step 3.1: Create `DeclaredAwsLogGroupDao.ts`

**File**: `src/access/daos/DeclaredAwsLogGroupDao.ts`

**Pattern**: Follow `DeclaredAwsLambdaDao.ts`

```typescript
export const DeclaredAwsLogGroupDao = new DeclastructDao<
  DeclaredAwsLogGroup,
  typeof DeclaredAwsLogGroup,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => getOneLogGroup({ by: { primary: input } }, context),
    byUnique: async (input, context) => getOneLogGroup({ by: { unique: input } }, context),
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // No set operations — log groups are created automatically by Lambda
});
```

#### Step 3.2: Create `DeclaredAwsLogGroupReportDistOfPatternDao.ts`

**File**: `src/access/daos/DeclaredAwsLogGroupReportDistOfPatternDao.ts`

```typescript
export const DeclaredAwsLogGroupReportDistOfPatternDao = new DeclastructDao<
  DeclaredAwsLogGroupReportDistOfPattern,
  typeof DeclaredAwsLogGroupReportDistOfPattern,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) =>
      getOneLogGroupReportDistOfPattern({ by: { unique: input } }, context),
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroupReportDistOfPattern })(input))
        return getOneLogGroupReportDistOfPattern({ by: { unique: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // No set operations — readonly derived entity
});
```

#### Step 3.3: Create `DeclaredAwsLogGroupReportCostOfIngestionDao.ts`

**File**: `src/access/daos/DeclaredAwsLogGroupReportCostOfIngestionDao.ts`

```typescript
export const DeclaredAwsLogGroupReportCostOfIngestionDao = new DeclastructDao<
  DeclaredAwsLogGroupReportCostOfIngestion,
  typeof DeclaredAwsLogGroupReportCostOfIngestion,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) =>
      getOneLogGroupReportCostOfIngestion({ by: { unique: input } }, context),
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroupReportCostOfIngestion })(input))
        return getOneLogGroupReportCostOfIngestion({ by: { unique: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // No set operations — readonly derived entity
});
```

---

### Phase 4: Exports & Provider

#### Step 4.1: Update `src/contract/sdks/index.ts`

Add exports:

```typescript
// aws log group domain objects
export { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';
export {
  DeclaredAwsLogGroupReportDistOfPattern,
  DeclaredAwsLogGroupReportDistOfPatternRow,
} from '../../domain.objects/DeclaredAwsLogGroupReportDistOfPattern';
export {
  DeclaredAwsLogGroupReportCostOfIngestion,
  DeclaredAwsLogGroupReportCostOfIngestionRow,
  DeclaredAwsLogGroupFilter,
} from '../../domain.objects/DeclaredAwsLogGroupReportCostOfIngestion';

// aws log group operations
export { getOneLogGroup } from '../../domain.operations/logGroup/getOneLogGroup';
export { getAllLogGroups } from '../../domain.operations/logGroup/getAllLogGroups';
export { getOneLogGroupReportDistOfPattern } from '../../domain.operations/logGroupReportDistOfPattern/getOneLogGroupReportDistOfPattern';
export { getOneLogGroupReportCostOfIngestion } from '../../domain.operations/logGroupReportCostOfIngestion/getOneLogGroupReportCostOfIngestion';

// aws log group daos
export { DeclaredAwsLogGroupDao } from '../../access/daos/DeclaredAwsLogGroupDao';
export { DeclaredAwsLogGroupReportDistOfPatternDao } from '../../access/daos/DeclaredAwsLogGroupReportDistOfPatternDao';
export { DeclaredAwsLogGroupReportCostOfIngestionDao } from '../../access/daos/DeclaredAwsLogGroupReportCostOfIngestionDao';
```

#### Step 4.2: Update `DeclastructAwsProvider` type

**File**: `src/domain.objects/DeclastructAwsProvider.ts`

Add the new DAOs to the provider type:

```typescript
export type DeclastructAwsProvider = DeclastructProvider<
  {
    // ... existing DAOs ...
    DeclaredAwsLogGroup: DeclastructDao<
      DeclaredAwsLogGroup,
      typeof DeclaredAwsLogGroup,
      ContextAwsApi & ContextLogTrail
    >;
    DeclaredAwsLogGroupReportDistOfPattern: DeclastructDao<
      DeclaredAwsLogGroupReportDistOfPattern,
      typeof DeclaredAwsLogGroupReportDistOfPattern,
      ContextAwsApi & ContextLogTrail
    >;
    DeclaredAwsLogGroupReportCostOfIngestion: DeclastructDao<
      DeclaredAwsLogGroupReportCostOfIngestion,
      typeof DeclaredAwsLogGroupReportCostOfIngestion,
      ContextAwsApi & ContextLogTrail
    >;
  },
  ContextAwsApi & ContextLogTrail
>;
```

---

### Phase 5: Testing

#### Step 5.1: Unit Tests

Each domain object and operation should have unit tests:

- `DeclaredAwsLogGroup.test.ts` - Test `.as()` and validation
- `DeclaredAwsLogGroupReportDistOfPattern.test.ts` - Test `.as()` and nested objects
- `DeclaredAwsLogGroupReportCostOfIngestion.test.ts` - Test `.as()` and nested objects
- `getOneLogGroup.test.ts` - Mock AWS SDK, test routing
- `getAllLogGroups.test.ts` - Mock AWS SDK, test pagination
- `getOneLogGroupReportDistOfPattern.test.ts` - Mock AWS SDK, test query building & polling
- `getOneLogGroupReportCostOfIngestion.test.ts` - Mock AWS SDK, test metric retrieval
- `castIntoDeclaredAwsLogGroup.test.ts` - Test mapping
- `castIntoDeclaredAwsLogGroupReportDistOfPattern.test.ts` - Test mapping
- `castIntoDeclaredAwsLogGroupReportCostOfIngestion.test.ts` - Test mapping & cost calculation

#### Step 5.2: Integration Tests

Integration tests should use real AWS credentials:

- `getOneLogGroup.integration.test.ts` - Test against real log group
- `getAllLogGroups.integration.test.ts` - Test with prefix filter
- `getOneLogGroupReportDistOfPattern.integration.test.ts` - Test full query flow
- `getOneLogGroupReportCostOfIngestion.integration.test.ts` - Test full metrics flow

---

## Dependencies

### New AWS SDK Packages

```bash
npm install @aws-sdk/client-cloudwatch-logs @aws-sdk/client-cloudwatch
```

### Existing Dependencies (Already in Package)

- `@ehmpathy/uni-time` - For `UniDateTime`, `UniDateTimeRange`
- `domain-objects` - For `DomainEntity`, `DomainLiteral`, `RefByUnique`
- `declastruct` - For `DeclastructDao`
- `type-fns` - For `PickOne`
- `helpful-errors` - For `HelpfulError`, `UnexpectedCodePathError`
- `as-procedure` - For `asProcedure`
- `visualogic` - For `VisualogicContext`

---

## Constraints & Considerations

### CloudWatch Logs Insights Limits

- Max 30 concurrent queries
- Query timeout: 60 minutes
- Max results: 10,000 rows per query
- Max log groups per query: 50

**Mitigation**: For large log group sets, batch queries and merge results.

### CloudWatch Metrics Limits

- Max 500 metrics per `GetMetricData` request
- Max 100,800 data points per request

**Mitigation**: Batch metric requests for large log group sets.

### Polling Strategy

For `StartQuery` + `GetQueryResults`:
- Initial delay: 1 second
- Max delay: 10 seconds
- Backoff multiplier: 1.5x
- Max attempts: 120 (for 60-minute timeout)

---

## Usage Example

Once implemented, the wish can be fulfilled:

```typescript
import {
  getDeclastructAwsProvider,
  DeclaredAwsLogGroupReportDistOfPattern,
  DeclaredAwsLogGroupReportCostOfIngestion,
} from 'declastruct-aws';

const provider = await getDeclastructAwsProvider({}, context);

// Get cost report for all lambda log groups
const costReport = await provider.get(DeclaredAwsLogGroupReportCostOfIngestion, {
  by: {
    unique: {
      logGroupFilter: { prefix: '/aws/lambda/' },
      range: { since: '2024-11-01T00:00:00Z', until: '2024-11-30T23:59:59Z' },
    },
  },
});

console.log('Top cost log groups:');
costReport.entries?.slice(0, 5).forEach((row) => {
  console.log(`  ${row.logGroupName}: $${row.estimatedCostUsd.toFixed(2)} (${row.percentOfTotal.bytes.toFixed(1)}%)`);
});

// Drill into the highest-cost log group for pattern distribution
const topLogGroup = costReport.entries?.[0];
if (topLogGroup) {
  const distribution = await provider.get(DeclaredAwsLogGroupReportDistOfPattern, {
    by: {
      unique: {
        logGroups: [{ name: topLogGroup.logGroupName }],
        range: { since: '2024-11-01T00:00:00Z', until: '2024-11-30T23:59:59Z' },
        pattern: '@message',
        filter: null,
        limit: 100,
      },
    },
  });

  console.log(`\nTop patterns in ${topLogGroup.logGroupName}:`);
  distribution.entries?.slice(0, 10).forEach((row) => {
    console.log(`  ${row.value.substring(0, 50)}...`);
    console.log(`    frequency: ${row.frequency}, bytes: ${row.totalBytes}, ${row.percentOfTotal.bytes.toFixed(1)}% of bytes`);
  });
}
```

---

## Summary

| Phase | Files | Effort |
|-------|-------|--------|
| 1. Domain Objects | 3 files + 3 test files | Medium |
| 2. Domain Operations | 7 files + 7 test files + 3 integration tests | High |
| 3. Access DAOs | 3 files | Low |
| 4. Exports & Provider | 2 files (modifications) | Low |
| 5. Testing | Integration test setup | Medium |

**Total new files**: ~26 files
**Key dependencies**: `@aws-sdk/client-cloudwatch-logs`, `@aws-sdk/client-cloudwatch`

emit your response to the feedback into
- .behaviors/v2025_11_30.lambda-log-trends/3.2.distill.aws.domain.v1.i1.md.[feedback].v1.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---


# nitpick.1

DeclaredAwsLogGroup.logGroupClass => DeclaredAwsLogGroup.class

no need to specify logGroupClass, given it's already namespaced within the domain entity name


# blocker.2

DeclaredAwsLogGroup.arn
1. is metadata => should be in public static metadata
2. is metadata => should be optional, since wont be known until read


# blocker.3

DeclaredAwsLogMessageHistogram.logGroupNames: string[]

=>

DeclaredAwsLogMessageHistogram.logGroups: RefByUnique<typeof DeclaredAwsLogGroup>[]

always use references to make the relationships explicit

add it to public static nested, too


# blocker.4


  timeRange: DeclaredAwsLogTimeRange;

  =>

  range: UniDateTimeRange;


use UniDateTimeRange from '@ehmpathy/uni-time'

# blocker.5

DeclaredAwsLogMessageHistogram.filter & limit should be defined or null; not optional

optional is allowed only for readonly/metadata attributes

everything else must be explicitly declared


# blocker.6


put entries at the bottom of the domain object's attributes for each domain object; that way, when we log the objects, the largest attribute is at the bottom, and we can scan the top


# blocker.7


  /**
   * .what = the query id from CloudWatch Logs Insights
   * .note = @metadata â€” used for polling/caching
   */
  queryId?: string;

  /**
   * .what = the query status
   * .note = @metadata
   */
  queryStatus?: 'Scheduled' | 'Running' | 'Complete' | 'Failed' | 'Cancelled' | 'Timeout';


these are not part of the domain objects;

they're infra level details of how to access the domain objects, and should not be considered part of the domain itself


# blocker.8


  /**
   * .what = the log group name prefix to filter by
   * .note = part of @unique
   * .example = '/aws/lambda/' to get all lambda log groups
   */
  logGroupNamePrefix?: string | null;

  /**
   * .what = explicit list of log group names (alternative to prefix)
   * .note = part of @unique
   */
  logGroupNames?: string[] | null;


turn this into one type called

export type DeclaredAwsLogGroupFilter = PickOne<{


  /**
   * .what = the log group name prefix to filter by
   * .example = '/aws/lambda/' to get all lambda log groups
   */
  logGroupNamePrefix: string

  /**
   * .what = explicit list of log group names (alternative to prefix)
   */
  logGroupNames: string[]
}>


then update DeclaredAwsLogIngestionCostReport

to leverage

DeclaredAwsLogIngestionCostReport.logGroupFilter: DeclaredAwsLogGroupFilter

and have use it in the unique key, instead of both options

the public static nested for logGroupFilter can just be a plain DomainLiteral

public static nested = {
  logGroupFilter: DomainLiteral
}



# blocker.9

drop the DeclaredAwsLogGroupFields concept; we dont need it after all

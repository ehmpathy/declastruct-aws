# Declastruct Domain Distillation for Lambda Log Trends

## Use Cases

Based on the wish, there are two primary use cases:

### UC1: Lambda Log Message Histogram
As a developer, I want to declaratively request a histogram of log messages for a set of lambda functions, so that I can understand:
- What are the common `.message` attributes?
- How often do they occur?
- How large are the messages?

### UC2: Lambda Log Ingestion Cost Report
As a developer, I want to declaratively request an ingestion cost report for lambda log groups, so that I can understand which lambdas are driving log costs.

---

## Envisioned Contract

### UC1: Log Message Histogram

```typescript
import { getLogMessageHistogram } from 'declastruct-aws';

// declare what we want
const histogram = await getLogMessageHistogram(
  {
    for: {
      lambdas: [
        { name: 'svc-chat-prod-getDisplayableMessages' },
        { name: 'svc-quotes-prod-executeTaskGuideClientToHireProExcl' },
      ],
    },
    within: {
      since: '2024-01-01T00:00:00Z',
      until: '2024-01-31T23:59:59Z',
    },
    limit: 100, // top N patterns
  },
  context,
);

// result: sorted by frequency desc
console.log(histogram.patterns);
// [
//   {
//     message: 'Processing request for user...',
//     frequency: 1234567,
//     totalBytes: 45678901,
//     avgBytes: 37,
//   },
//   ...
// ]
```

### UC2: Log Ingestion Cost Report

```typescript
import { getLogIngestionCostReport } from 'declastruct-aws';

// declare what we want
const report = await getLogIngestionCostReport(
  {
    for: {
      lambdas: [
        { name: 'svc-chat-prod-getDisplayableMessages' },
        { name: 'svc-quotes-prod-executeTaskGuideClientToHireProExcl' },
      ],
    },
    within: {
      since: '2024-01-01T00:00:00Z',
      until: '2024-01-31T23:59:59Z',
    },
  },
  context,
);

// result: sorted by ingestion cost desc
console.log(report.entries);
// [
//   {
//     logGroup: { name: '/aws/lambda/svc-chat-prod-getDisplayableMessages' },
//     dataIngestedBytes: 3339739750,
//     logEventCount: 6523133,
//     ingestionCostUsd: 1.67,
//   },
//   ...
// ]
```

---

## Domain Objects

### DeclaredAwsLogGroup

The log group entity - primarily read-only for our use cases.

```typescript
import type { LogGroupClass } from '@aws-sdk/client-cloudwatch-logs';
import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure representing an AWS CloudWatch Logs log group
 * .why = enables declarative access to log group information
 */
export interface DeclaredAwsLogGroup {
  /**
   * .what = the ARN of the log group
   * .note = is @metadata -> assigned by AWS
   */
  arn?: string;

  /**
   * .what = the name of the log group
   * .note = for lambda: `/aws/lambda/<function-name>`
   */
  name: string;

  /**
   * .what = the log class
   * .note = STANDARD | INFREQUENT_ACCESS | DELIVERY
   */
  logGroupClass?: LogGroupClass;

  /**
   * .what = retention period in days
   */
  retentionInDays?: number;

  /**
   * .what = total bytes currently stored
   * .note = is @readonly -> resolved from AWS with ~24hr delay
   */
  storedBytes?: number;
}

export class DeclaredAwsLogGroup
  extends DomainEntity<DeclaredAwsLogGroup>
  implements DeclaredAwsLogGroup
{
  public static primary = ['arn'] as const;
  public static unique = ['name'] as const;
  public static metadata = ['arn'] as const;
  public static readonly = ['storedBytes', 'logGroupClass', 'retentionInDays'] as const;
}
```

### DeclaredAwsLogMessagePattern

A value object representing a message pattern from the histogram.

```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = a log message pattern with aggregated statistics
 * .why = represents histogram entries from Logs Insights queries
 */
export interface DeclaredAwsLogMessagePattern {
  /**
   * .what = the log message content (or pattern)
   */
  message: string;

  /**
   * .what = number of times this message appeared
   */
  frequency: number;

  /**
   * .what = total bytes for all occurrences
   */
  totalBytes: number;

  /**
   * .what = average bytes per occurrence
   */
  avgBytes: number;
}

export class DeclaredAwsLogMessagePattern
  extends DomainLiteral<DeclaredAwsLogMessagePattern>
  implements DeclaredAwsLogMessagePattern {}
```

### DeclaredAwsLogMessageHistogram

The entity representing a histogram report - identified by the query parameters.

```typescript
import { UniDateTime } from '@ehmpathy/uni-time';
import { DomainEntity, DomainLiteral, RefByUnique } from 'domain-objects';

import { DeclaredAwsLambda } from './DeclaredAwsLambda';
import { DeclaredAwsLogMessagePattern } from './DeclaredAwsLogMessagePattern';

/**
 * .what = time range for the query
 */
export interface DeclaredAwsLogQueryTimeRange {
  since: UniDateTime;
  until: UniDateTime;
}

export class DeclaredAwsLogQueryTimeRange
  extends DomainLiteral<DeclaredAwsLogQueryTimeRange>
  implements DeclaredAwsLogQueryTimeRange {}

/**
 * .what = a histogram of log messages for a set of lambdas
 * .why = enables declarative, cacheable log analysis
 */
export interface DeclaredAwsLogMessageHistogram {
  /**
   * .what = the lambdas included in this histogram
   */
  lambdas: RefByUnique<typeof DeclaredAwsLambda>[];

  /**
   * .what = the time range queried
   */
  within: DeclaredAwsLogQueryTimeRange;

  /**
   * .what = max patterns to return
   */
  limit: number;

  /**
   * .what = the histogram patterns
   * .note = is @readonly -> resolved from CloudWatch Logs Insights
   */
  patterns?: DeclaredAwsLogMessagePattern[];

  /**
   * .what = total records scanned
   * .note = is @readonly -> from query statistics
   */
  recordsScanned?: number;

  /**
   * .what = total records matched
   * .note = is @readonly -> from query statistics
   */
  recordsMatched?: number;

  /**
   * .what = bytes scanned
   * .note = is @readonly -> from query statistics
   */
  bytesScanned?: number;
}

export class DeclaredAwsLogMessageHistogram
  extends DomainEntity<DeclaredAwsLogMessageHistogram>
  implements DeclaredAwsLogMessageHistogram
{
  public static unique = ['lambdas', 'within', 'limit'] as const;
  public static metadata = [] as const;
  public static readonly = ['patterns', 'recordsScanned', 'recordsMatched', 'bytesScanned'] as const;

  public static nested = {
    lambdas: [RefByUnique<typeof DeclaredAwsLambda>],
    within: DeclaredAwsLogQueryTimeRange,
    patterns: [DeclaredAwsLogMessagePattern],
  };
}
```

### DeclaredAwsLogIngestionCostEntry

A value object representing a single log group's ingestion cost.

```typescript
import { DomainLiteral, RefByUnique } from 'domain-objects';

import { DeclaredAwsLogGroup } from './DeclaredAwsLogGroup';

/**
 * .what = ingestion cost data for a single log group
 */
export interface DeclaredAwsLogIngestionCostEntry {
  /**
   * .what = reference to the log group
   */
  logGroup: RefByUnique<typeof DeclaredAwsLogGroup>;

  /**
   * .what = bytes ingested in the time range
   */
  dataIngestedBytes: number;

  /**
   * .what = number of log events ingested
   */
  logEventCount: number;

  /**
   * .what = estimated ingestion cost in USD
   * .note = calculated as bytes * $0.50/GB (standard) or $0.25/GB (IA)
   */
  ingestionCostUsd: number;
}

export class DeclaredAwsLogIngestionCostEntry
  extends DomainLiteral<DeclaredAwsLogIngestionCostEntry>
  implements DeclaredAwsLogIngestionCostEntry
{
  public static nested = {
    logGroup: RefByUnique<typeof DeclaredAwsLogGroup>,
  };
}
```

### DeclaredAwsLogIngestionCostReport

The entity representing an ingestion cost report.

```typescript
import { DomainEntity, RefByUnique } from 'domain-objects';

import { DeclaredAwsLambda } from './DeclaredAwsLambda';
import { DeclaredAwsLogIngestionCostEntry } from './DeclaredAwsLogIngestionCostEntry';
import { DeclaredAwsLogQueryTimeRange } from './DeclaredAwsLogMessageHistogram';

/**
 * .what = an ingestion cost report for lambda log groups
 * .why = enables declarative, cacheable cost analysis
 */
export interface DeclaredAwsLogIngestionCostReport {
  /**
   * .what = the lambdas included in this report
   */
  lambdas: RefByUnique<typeof DeclaredAwsLambda>[];

  /**
   * .what = the time range queried
   */
  within: DeclaredAwsLogQueryTimeRange;

  /**
   * .what = cost entries per log group
   * .note = is @readonly -> resolved from CloudWatch Metrics
   */
  entries?: DeclaredAwsLogIngestionCostEntry[];

  /**
   * .what = total bytes ingested across all log groups
   * .note = is @readonly -> aggregated from entries
   */
  totalDataIngestedBytes?: number;

  /**
   * .what = total ingestion cost in USD
   * .note = is @readonly -> aggregated from entries
   */
  totalIngestionCostUsd?: number;
}

export class DeclaredAwsLogIngestionCostReport
  extends DomainEntity<DeclaredAwsLogIngestionCostReport>
  implements DeclaredAwsLogIngestionCostReport
{
  public static unique = ['lambdas', 'within'] as const;
  public static metadata = [] as const;
  public static readonly = ['entries', 'totalDataIngestedBytes', 'totalIngestionCostUsd'] as const;

  public static nested = {
    lambdas: [RefByUnique<typeof DeclaredAwsLambda>],
    within: DeclaredAwsLogQueryTimeRange,
    entries: [DeclaredAwsLogIngestionCostEntry],
  };
}
```

---

## Domain Operations

### getOneLogGroup

```typescript
import {
  CloudWatchLogsClient,
  DescribeLogGroupsCommand,
} from '@aws-sdk/client-cloudwatch-logs';
import { asProcedure } from 'as-procedure';
import { HasReadonly, RefByPrimary, RefByUnique } from 'domain-objects';
import { PickOne } from 'type-fns';
import { VisualogicContext } from 'visualogic';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';

/**
 * .what = gets a single log group from aws
 * .why = enables lookup by primary (arn) or unique (name)
 */
export const getOneLogGroup = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsLogGroup>;
        unique: RefByUnique<typeof DeclaredAwsLogGroup>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogGroup> | null> => {
    const logs = new CloudWatchLogsClient({ region: context.aws.credentials.region });

    const logGroupName = input.by.unique?.name ?? input.by.primary?.arn;

    const response = await logs.send(
      new DescribeLogGroupsCommand({
        logGroupNamePrefix: logGroupName,
        limit: 1,
      }),
    );

    const logGroup = response.logGroups?.find(
      (lg) => lg.logGroupName === logGroupName,
    );

    if (!logGroup) return null;

    return castIntoDeclaredAwsLogGroup(logGroup);
  },
);
```

### getLogMessageHistogram

```typescript
import {
  CloudWatchLogsClient,
  StartQueryCommand,
  GetQueryResultsCommand,
} from '@aws-sdk/client-cloudwatch-logs';
import { asProcedure } from 'as-procedure';
import { HasReadonly, RefByUnique } from 'domain-objects';
import { VisualogicContext } from 'visualogic';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLambda } from '../../domain.objects/DeclaredAwsLambda';
import { DeclaredAwsLogMessageHistogram, DeclaredAwsLogQueryTimeRange } from '../../domain.objects/DeclaredAwsLogMessageHistogram';

/**
 * .what = gets a histogram of log messages for a set of lambdas
 * .why = enables declarative log message analysis
 */
export const getLogMessageHistogram = asProcedure(
  async (
    input: {
      for: {
        lambdas: RefByUnique<typeof DeclaredAwsLambda>[];
      };
      within: DeclaredAwsLogQueryTimeRange;
      limit?: number;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogMessageHistogram>> => {
    const logs = new CloudWatchLogsClient({ region: context.aws.credentials.region });

    // convert lambda refs to log group names
    const logGroupNames = input.for.lambdas.map(
      (lambda) => `/aws/lambda/${lambda.name}`,
    );

    // build the Logs Insights query
    const queryString = `
      fields @timestamp, @message
      | stats count(*) as frequency,
              sum(strlen(@message)) as totalBytes,
              avg(strlen(@message)) as avgBytes
        by @message
      | sort frequency desc
      | limit ${input.limit ?? 100}
    `;

    // start the query
    const startResponse = await logs.send(
      new StartQueryCommand({
        logGroupNames,
        startTime: Math.floor(new Date(input.within.since).getTime() / 1000),
        endTime: Math.floor(new Date(input.within.until).getTime() / 1000),
        queryString,
        limit: input.limit ?? 100,
      }),
    );

    // poll for results (simplified - real impl would use exponential backoff)
    let results;
    let status;
    do {
      await sleep(1000);
      const response = await logs.send(
        new GetQueryResultsCommand({ queryId: startResponse.queryId }),
      );
      results = response.results;
      status = response.status;
    } while (status === 'Running' || status === 'Scheduled');

    // transform results into patterns
    const patterns = (results ?? []).map((row) => {
      const fields = Object.fromEntries(
        row.map((field) => [field.field, field.value]),
      );
      return DeclaredAwsLogMessagePattern.as({
        message: fields['@message'] ?? '',
        frequency: parseInt(fields.frequency ?? '0', 10),
        totalBytes: parseInt(fields.totalBytes ?? '0', 10),
        avgBytes: parseFloat(fields.avgBytes ?? '0'),
      });
    });

    return DeclaredAwsLogMessageHistogram.as({
      lambdas: input.for.lambdas,
      within: input.within,
      limit: input.limit ?? 100,
      patterns,
    });
  },
);
```

### getLogIngestionCostReport

```typescript
import {
  CloudWatchClient,
  GetMetricStatisticsCommand,
} from '@aws-sdk/client-cloudwatch';
import { asProcedure } from 'as-procedure';
import { HasReadonly, RefByUnique } from 'domain-objects';
import { VisualogicContext } from 'visualogic';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLambda } from '../../domain.objects/DeclaredAwsLambda';
import { DeclaredAwsLogIngestionCostReport } from '../../domain.objects/DeclaredAwsLogIngestionCostReport';
import { DeclaredAwsLogQueryTimeRange } from '../../domain.objects/DeclaredAwsLogMessageHistogram';

const INGESTION_COST_PER_GB_USD = 0.50; // standard class, varies by region

/**
 * .what = gets an ingestion cost report for lambda log groups
 * .why = enables declarative cost analysis
 */
export const getLogIngestionCostReport = asProcedure(
  async (
    input: {
      for: {
        lambdas: RefByUnique<typeof DeclaredAwsLambda>[];
      };
      within: DeclaredAwsLogQueryTimeRange;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogIngestionCostReport>> => {
    const cloudwatch = new CloudWatchClient({ region: context.aws.credentials.region });

    const entries = await Promise.all(
      input.for.lambdas.map(async (lambda) => {
        const logGroupName = `/aws/lambda/${lambda.name}`;

        // get IncomingBytes metric
        const bytesResponse = await cloudwatch.send(
          new GetMetricStatisticsCommand({
            Namespace: 'AWS/Logs',
            MetricName: 'IncomingBytes',
            Dimensions: [{ Name: 'LogGroupName', Value: logGroupName }],
            StartTime: new Date(input.within.since),
            EndTime: new Date(input.within.until),
            Period: 2592000, // 30 days in seconds
            Statistics: ['Sum'],
          }),
        );

        // get IncomingLogEvents metric
        const eventsResponse = await cloudwatch.send(
          new GetMetricStatisticsCommand({
            Namespace: 'AWS/Logs',
            MetricName: 'IncomingLogEvents',
            Dimensions: [{ Name: 'LogGroupName', Value: logGroupName }],
            StartTime: new Date(input.within.since),
            EndTime: new Date(input.within.until),
            Period: 2592000,
            Statistics: ['Sum'],
          }),
        );

        const dataIngestedBytes = bytesResponse.Datapoints?.reduce(
          (sum, dp) => sum + (dp.Sum ?? 0),
          0,
        ) ?? 0;

        const logEventCount = eventsResponse.Datapoints?.reduce(
          (sum, dp) => sum + (dp.Sum ?? 0),
          0,
        ) ?? 0;

        const ingestionCostUsd =
          (dataIngestedBytes / (1024 * 1024 * 1024)) * INGESTION_COST_PER_GB_USD;

        return DeclaredAwsLogIngestionCostEntry.as({
          logGroup: { name: logGroupName },
          dataIngestedBytes,
          logEventCount,
          ingestionCostUsd,
        });
      }),
    );

    // sort by cost descending
    entries.sort((a, b) => b.ingestionCostUsd - a.ingestionCostUsd);

    const totalDataIngestedBytes = entries.reduce(
      (sum, e) => sum + e.dataIngestedBytes,
      0,
    );
    const totalIngestionCostUsd = entries.reduce(
      (sum, e) => sum + e.ingestionCostUsd,
      0,
    );

    return DeclaredAwsLogIngestionCostReport.as({
      lambdas: input.for.lambdas,
      within: input.within,
      entries,
      totalDataIngestedBytes,
      totalIngestionCostUsd,
    });
  },
);
```

---

## Access DAOs

### DeclaredAwsLogGroupDao

```typescript
import { DeclastructDao } from 'declastruct';
import { isRefByPrimary, isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLogGroup } from '../../domain.objects/DeclaredAwsLogGroup';
import { getOneLogGroup } from '../../domain.operations/logGroup/getOneLogGroup';

/**
 * .what = declastruct DAO for AWS CloudWatch Log Groups
 * .why = wraps log group operations to conform to declastruct interface
 * .note = read-only DAO - log groups are typically managed elsewhere
 */
export const DeclaredAwsLogGroupDao = new DeclastructDao<
  DeclaredAwsLogGroup,
  typeof DeclaredAwsLogGroup,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      return getOneLogGroup({ by: { primary: input } }, context);
    },
    byUnique: async (input, context) => {
      return getOneLogGroup({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // no set operations - log groups are read-only for this use case
});
```

### DeclaredAwsLogMessageHistogramDao

```typescript
import { DeclastructDao } from 'declastruct';
import type { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLogMessageHistogram } from '../../domain.objects/DeclaredAwsLogMessageHistogram';
import { getLogMessageHistogram } from '../../domain.operations/logAnalytics/getLogMessageHistogram';

/**
 * .what = declastruct DAO for log message histograms
 * .why = enables cacheable, declarative log analysis
 * .note = read-only DAO - histograms are computed on demand
 */
export const DeclaredAwsLogMessageHistogramDao = new DeclastructDao<
  DeclaredAwsLogMessageHistogram,
  typeof DeclaredAwsLogMessageHistogram,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) => {
      return getLogMessageHistogram(
        {
          for: { lambdas: input.lambdas },
          within: input.within,
          limit: input.limit,
        },
        context,
      );
    },
  },
  // no set operations - histograms are computed, not stored
});
```

### DeclaredAwsLogIngestionCostReportDao

```typescript
import { DeclastructDao } from 'declastruct';
import type { ContextLogTrail } from 'simple-log-methods';

import { ContextAwsApi } from '../../domain.objects/ContextAwsApi';
import { DeclaredAwsLogIngestionCostReport } from '../../domain.objects/DeclaredAwsLogIngestionCostReport';
import { getLogIngestionCostReport } from '../../domain.operations/logAnalytics/getLogIngestionCostReport';

/**
 * .what = declastruct DAO for log ingestion cost reports
 * .why = enables cacheable, declarative cost analysis
 * .note = read-only DAO - reports are computed on demand
 */
export const DeclaredAwsLogIngestionCostReportDao = new DeclastructDao<
  DeclaredAwsLogIngestionCostReport,
  typeof DeclaredAwsLogIngestionCostReport,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) => {
      return getLogIngestionCostReport(
        {
          for: { lambdas: input.lambdas },
          within: input.within,
        },
        context,
      );
    },
  },
  // no set operations - reports are computed, not stored
});
```

---

## File Structure

```
src/
├── domain.objects/
│   ├── DeclaredAwsLogGroup.ts
│   ├── DeclaredAwsLogMessagePattern.ts
│   ├── DeclaredAwsLogMessageHistogram.ts
│   ├── DeclaredAwsLogIngestionCostEntry.ts
│   └── DeclaredAwsLogIngestionCostReport.ts
├── domain.operations/
│   ├── logGroup/
│   │   ├── getOneLogGroup.ts
│   │   ├── getAllLogGroups.ts
│   │   └── castIntoDeclaredAwsLogGroup.ts
│   └── logAnalytics/
│       ├── getLogMessageHistogram.ts
│       └── getLogIngestionCostReport.ts
├── access/
│   └── daos/
│       ├── DeclaredAwsLogGroupDao.ts
│       ├── DeclaredAwsLogMessageHistogramDao.ts
│       └── DeclaredAwsLogIngestionCostReportDao.ts
└── contract/
    └── sdks/
        └── index.ts  # add exports
```

---

## Dependencies to Add

```json
{
  "dependencies": {
    "@aws-sdk/client-cloudwatch-logs": "3.940.0",
    "@aws-sdk/client-cloudwatch": "3.940.0"
  }
}
```

---

## Key Design Decisions

### 1. Unique Keys for Cacheability

The histogram and cost report entities use `unique = ['lambdas', 'within', 'limit']` as their identity. This means:
- Same query parameters = same entity = cacheable
- Different time ranges = different entities

### 2. Read-Only Patterns

Both histogram and cost report are "computed views" rather than stored entities:
- No `set` operations on the DAOs
- All data fields are `@readonly`
- Fresh data is fetched on each `get`

### 3. Lambda-Centric API

The API takes lambda references rather than log group names directly:
- More intuitive for developers
- Automatically converts to log group names (`/aws/lambda/{name}`)
- Composable with existing `DeclaredAwsLambda` entities

### 4. Time Range as Domain Literal

`DeclaredAwsLogQueryTimeRange` is a reusable value object:
- Encapsulates `since` and `until`
- Used by both histogram and cost report
- Enables consistent time handling

---

## Cacheability Strategy

For intelligent cacheability (as mentioned in the wish):

```typescript
// example cache key derivation
const cacheKey = DeclaredAwsLogMessageHistogram.getUniqueKey({
  lambdas: input.lambdas,
  within: input.within,
  limit: input.limit,
});

// cache could be implemented at DAO level
const cached = await cache.get(cacheKey);
if (cached && !isStale(cached)) return cached;

const fresh = await getLogMessageHistogram(input, context);
await cache.set(cacheKey, fresh, { ttl: '1h' });
return fresh;
```

This enables the "subsequent composability" mentioned in the wish - once computed, results can be reused.

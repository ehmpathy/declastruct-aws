# Distillation: Lambda Log Trends Domain Objects & Operations

## Use Cases

### Use Case 1: Pattern Distribution Report

**Goal**: Get a distribution report of log patterns for a set of lambdas to understand what patterns are being emitted, how frequently, and how large they are.

**Contract Envisioned**:
```typescript
const report = await provider.get(DeclaredAwsLogGroupReportDistOfPattern, {
  by: {
    unique: {
      logGroups: [{ name: '/aws/lambda/svc-chat-prod-getDisplayableMessages' }],
      range: { since: '2024-11-01T00:00:00Z', until: '2024-11-30T23:59:59Z' },
      pattern: '@message',
      filter: null,
      limit: null,
    },
  },
});

// Result:
// {
//   logGroups: [{ name: '...' }],
//   range: {...},
//   pattern: '@message',
//   filter: null,
//   limit: null,
//   scannedBytes: 3110000000,
//   matchedEvents: 6523133,
//   entries: [
//     { value: 'START RequestId: ...', frequency: 6523133, totalBytes: 521850640, avgBytes: 80, percentOfTotal: { frequency: 25, bytes: 17 } },
//     { value: 'END RequestId: ...', frequency: 6523133, totalBytes: 456625310, avgBytes: 70, percentOfTotal: { frequency: 25, bytes: 15 } },
//     { value: 'REPORT RequestId: ...', frequency: 6523133, totalBytes: 1304626600, avgBytes: 200, percentOfTotal: { frequency: 25, bytes: 42 } },
//     { value: '{"level":"info",...}', frequency: 3261566, totalBytes: 652313300, avgBytes: 200, percentOfTotal: { frequency: 12.5, bytes: 21 } },
//     ...
//   ],
// }
```

### Use Case 2: Ingestion Cost Report

**Goal**: Get a report of ingestion costs per log group to understand where costs are coming from.

**Contract Envisioned**:
```typescript
const costReport = await provider.get(DeclaredAwsLogGroupReportCostOfIngestion, {
  by: {
    unique: {
      logGroupFilter: { prefix: '/aws/lambda/' },
      range: { since: '2024-11-01T00:00:00Z', until: '2024-11-30T23:59:59Z' },
    },
  },
});

// Result:
// {
//   logGroupFilter: { prefix: '/aws/lambda/' },
//   range: {...},
//   totalIngestedBytes: 5340000000,
//   totalLogEvents: 10523819,
//   totalEstimatedCostUsd: 28.62,
//   entries: [
//     { logGroupName: '/aws/lambda/svc-chat-prod-getDisplayableMessages', ingestedBytes: 3338813440, logEvents: 6523133, estimatedCostUsd: 11.42, percentOfTotal: { bytes: 62.5, events: 62.0 } },
//     { logGroupName: '/aws/lambda/svc-quotes-prod-executeTaskGuideClientToHireProExcl', ingestedBytes: 1175389184, logEvents: 2297174, estimatedCostUsd: 4.02, percentOfTotal: { bytes: 22.0, events: 21.8 } },
//     ...
//   ],
// }
```

---

## Domain Objects

### Entities

#### DeclaredAwsLogGroup

**Purpose**: Represents an AWS CloudWatch Log Group. Primarily for discovery of log groups to query.

```typescript
/**
 * .what = a declarative structure representing an AWS CloudWatch Log Group
 * .note = for lambda functions, automatically created as /aws/lambda/<function-name>
 */
export interface DeclaredAwsLogGroup {
  /**
   * .what = the arn of the log group
   * .note = @metadata — assigned by AWS
   */
  arn?: string;

  /**
   * .what = the name of the log group
   * .note = @unique
   * .example = '/aws/lambda/svc-chat-prod-getDisplayableMessages'
   */
  name: string;

  /**
   * .what = the log group class
   */
  class: 'STANDARD' | 'INFREQUENT_ACCESS' | 'DELIVERY';

  /**
   * .what = optional KMS key for encryption
   */
  kmsKeyId: string | null;

  /**
   * .what = retention period in days
   * .note = @readonly — null means never expire
   */
  retentionInDays?: number | null;

  /**
   * .what = when the log group was created
   * .note = @readonly
   */
  createdAt?: UniDateTime;

  /**
   * .what = total bytes stored in the log group
   * .note = @readonly — updates with ~24hr delay
   */
  storedBytes?: number;
}

export class DeclaredAwsLogGroup
  extends DomainEntity<DeclaredAwsLogGroup>
  implements DeclaredAwsLogGroup
{
  public static primary = ['arn'] as const;
  public static unique = ['name'] as const;
  public static metadata = ['arn'] as const;
  public static readonly = ['storedBytes', 'createdAt', 'retentionInDays'] as const;
}
```

---

#### DeclaredAwsLogGroupReportDistOfPattern

**Purpose**: A readonly, derived entity representing distribution analysis of a pattern field across log groups. The unique key is the query parameters; the data is computed by CloudWatch Logs Insights.

```typescript
/**
 * .what = distribution report of a pattern field for a set of log groups over a time range
 * .why = enables declarative analysis of log patterns and their sizes
 *
 * .identity
 *   - @unique = [logGroups, range, pattern, filter, limit] — defined by query parameters
 *   - no @primary — this is a computed/derived entity, not persisted
 *
 * .note
 *   - this is a readonly entity — data comes from CloudWatch Logs Insights
 *   - cacheability is determined by range (historical ranges are stable)
 */
export interface DeclaredAwsLogGroupReportDistOfPattern {
  /**
   * .what = the log groups queried
   * .note = part of @unique
   */
  logGroups: RefByUnique<typeof DeclaredAwsLogGroup>[];

  /**
   * .what = the time range queried
   * .note = part of @unique
   */
  range: UniDateTimeRange;

  /**
   * .what = the pattern field to analyze frequency of
   * .note = part of @unique — e.g., '@message', 'level', 'requestId'
   * .example = '@message' to get frequency of unique messages
   */
  pattern: string;

  /**
   * .what = query filter (e.g., exclude REPORT, START, END)
   * .note = part of @unique — Logs Insights filter pattern; null means no filter
   */
  filter: string | null;

  /**
   * .what = max number of unique pattern values to return
   * .note = part of @unique — null means use default (1000)
   */
  limit: number | null;

  /**
   * .what = total bytes scanned by the query
   * .note = @readonly
   */
  scannedBytes?: number;

  /**
   * .what = total log events matched
   * .note = @readonly
   */
  matchedEvents?: number;

  /**
   * .what = the distribution rows sorted by frequency descending
   * .note = @readonly — computed by CloudWatch Logs Insights
   */
  entries?: DeclaredAwsLogGroupReportDistOfPatternRow[];
}

export class DeclaredAwsLogGroupReportDistOfPattern
  extends DomainEntity<DeclaredAwsLogGroupReportDistOfPattern>
  implements DeclaredAwsLogGroupReportDistOfPattern
{
  public static primary = [] as const; // no primary — derived entity
  public static unique = ['logGroups', 'range', 'pattern', 'filter', 'limit'] as const;
  public static metadata = [] as const;
  public static readonly = ['entries', 'scannedBytes', 'matchedEvents'] as const;

  public static nested = {
    logGroups: RefByUnique<typeof DeclaredAwsLogGroup>,
    entries: DeclaredAwsLogGroupReportDistOfPatternRow,
  };
}
```

---

#### DeclaredAwsLogGroupReportCostOfIngestion

**Purpose**: A readonly, derived entity representing ingestion costs per log group. Uses CloudWatch Metrics (IncomingBytes, IncomingLogEvents).

```typescript
/**
 * .what = aggregated ingestion cost report for log groups over a time range
 * .why = enables declarative understanding of CloudWatch Logs costs
 *
 * .identity
 *   - @unique = [logGroupFilter, range] — defined by query parameters
 *   - no @primary — this is a computed/derived entity
 *
 * .note
 *   - uses CloudWatch Metrics (AWS/Logs namespace, IncomingBytes metric)
 *   - cost calculation: ingestedBytes * $0.50/GB (varies by region)
 */
export interface DeclaredAwsLogGroupReportCostOfIngestion {
  /**
   * .what = filter to select which log groups to include
   * .note = part of @unique
   */
  logGroupFilter: DeclaredAwsLogGroupFilter;

  /**
   * .what = the time range for the cost report
   * .note = part of @unique
   */
  range: UniDateTimeRange;

  /**
   * .what = total bytes ingested across all log groups
   * .note = @readonly
   */
  totalIngestedBytes?: number;

  /**
   * .what = total log events ingested
   * .note = @readonly
   */
  totalLogEvents?: number;

  /**
   * .what = total estimated cost in USD
   * .note = @readonly — uses $0.50/GB ingestion rate
   */
  totalEstimatedCostUsd?: number;

  /**
   * .what = the cost entries per log group, sorted by ingested bytes descending
   * .note = @readonly — computed from CloudWatch Metrics
   */
  entries?: DeclaredAwsLogGroupReportCostOfIngestionRow[];
}

export class DeclaredAwsLogGroupReportCostOfIngestion
  extends DomainEntity<DeclaredAwsLogGroupReportCostOfIngestion>
  implements DeclaredAwsLogGroupReportCostOfIngestion
{
  public static primary = [] as const;
  public static unique = ['logGroupFilter', 'range'] as const;
  public static metadata = [] as const;
  public static readonly = ['entries', 'totalIngestedBytes', 'totalLogEvents', 'totalEstimatedCostUsd'] as const;

  public static nested = {
    logGroupFilter: DomainLiteral,
    entries: DeclaredAwsLogGroupReportCostOfIngestionRow,
  };
}
```

---

### Literals

#### DeclaredAwsLogGroupFilter

```typescript
/**
 * .what = a filter to select log groups by prefix or explicit names
 */
export type DeclaredAwsLogGroupFilter = PickOne<{
  /**
   * .what = the log group name prefix to filter by
   * .example = '/aws/lambda/' to get all lambda log groups
   */
  prefix: string;

  /**
   * .what = explicit list of log group names
   */
  names: string[];
}>;
```

---

#### DeclaredAwsLogGroupReportDistOfPatternRow

```typescript
/**
 * .what = a single row in a pattern distribution report
 */
export interface DeclaredAwsLogGroupReportDistOfPatternRow {
  /**
   * .what = the pattern value
   * .note = the actual value of the pattern field (e.g., the message content)
   */
  value: string;

  /**
   * .what = how many times this pattern value appeared
   */
  frequency: number;

  /**
   * .what = total bytes for all occurrences of this pattern value
   */
  totalBytes: number;

  /**
   * .what = average size in bytes per occurrence
   */
  avgBytes: number;

  /**
   * .what = percentage of total (by frequency and bytes)
   */
  percentOfTotal: {
    /**
     * .what = percentage of total log events by frequency
     */
    frequency: number;

    /**
     * .what = percentage of total bytes
     */
    bytes: number;
  };
}

export class DeclaredAwsLogGroupReportDistOfPatternRow
  extends DomainLiteral<DeclaredAwsLogGroupReportDistOfPatternRow>
  implements DeclaredAwsLogGroupReportDistOfPatternRow {}
```

---

#### DeclaredAwsLogGroupReportCostOfIngestionRow

```typescript
/**
 * .what = a single row of log group ingestion cost data
 */
export interface DeclaredAwsLogGroupReportCostOfIngestionRow {
  /**
   * .what = the log group name
   */
  logGroupName: string;

  /**
   * .what = bytes ingested during the time range
   */
  ingestedBytes: number;

  /**
   * .what = number of log events ingested
   */
  logEvents: number;

  /**
   * .what = estimated cost in USD
   * .note = calculated as ingestedBytes * $0.50/GB
   */
  estimatedCostUsd: number;

  /**
   * .what = percentage of total (by bytes and events)
   */
  percentOfTotal: {
    /**
     * .what = percentage of total ingested bytes
     */
    bytes: number;

    /**
     * .what = percentage of total log events
     */
    events: number;
  };
}

export class DeclaredAwsLogGroupReportCostOfIngestionRow
  extends DomainLiteral<DeclaredAwsLogGroupReportCostOfIngestionRow>
  implements DeclaredAwsLogGroupReportCostOfIngestionRow {}
```

---

## Domain Operations

### Log Group Operations

| Operation | Type | AWS API | Description |
|-----------|------|---------|-------------|
| `getOneLogGroup` | getOne | `DescribeLogGroups` | Get a single log group by name or ARN |
| `getAllLogGroups` | getAll | `DescribeLogGroups` | List log groups, optionally filtered by prefix |

```typescript
// getOneLogGroup
export const getOneLogGroup = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsLogGroup>;
        unique: RefByUnique<typeof DeclaredAwsLogGroup>;
        ref: Ref<typeof DeclaredAwsLogGroup>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogGroup> | null> => {
    // Uses DescribeLogGroups with logGroupNamePrefix or logGroupIdentifier
  },
);

// getAllLogGroups
export const getAllLogGroups = asProcedure(
  async (
    input: {
      by: {
        prefix?: string;
      };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogGroup>[]> => {
    // Uses DescribeLogGroups with pagination
  },
);
```

---

### Pattern Distribution Report Operations

| Operation | Type | AWS API | Description |
|-----------|------|---------|-------------|
| `getOneLogGroupReportDistOfPattern` | getOne | `StartQuery` + `GetQueryResults` | Get pattern distribution report for given parameters |

```typescript
export const getOneLogGroupReportDistOfPattern = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsLogGroupReportDistOfPattern> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogGroupReportDistOfPattern>> => {
    const { logGroups, range, pattern, filter, limit } = input.by.unique;

    // resolve log group names from refs
    const logGroupNames = logGroups.map((ref) => ref.name);

    // build Logs Insights query
    const query = `
      fields ${pattern}
      ${filter ? `| filter ${filter}` : ''}
      | stats count(*) as frequency,
              sum(strlen(${pattern})) as totalBytes,
              avg(strlen(${pattern})) as avgBytes
        by ${pattern}
      | sort frequency desc
      | limit ${limit ?? 1000}
    `;

    // start query
    const logs = new CloudWatchLogsClient({ region: context.aws.credentials.region });
    const startResponse = await logs.send(new StartQueryCommand({
      logGroupNames,
      startTime: new Date(range.since).getTime() / 1000,
      endTime: new Date(range.until).getTime() / 1000,
      queryString: query,
    }));

    // poll for results
    let results;
    while (true) {
      results = await logs.send(new GetQueryResultsCommand({ queryId: startResponse.queryId }));
      if (results.status === 'Complete') break;
      if (results.status === 'Failed' || results.status === 'Cancelled') {
        throw new HelpfulError(`Query failed with status: ${results.status}`, { queryId: startResponse.queryId });
      }
      await sleep(1000);
    }

    // cast into domain object
    return castIntoDeclaredAwsLogGroupReportDistOfPattern({ input, results });
  },
);
```

---

### Ingestion Cost Report Operations

| Operation | Type | AWS API | Description |
|-----------|------|---------|-------------|
| `getOneLogGroupReportCostOfIngestion` | getOne | `DescribeLogGroups` + `GetMetricData` | Get ingestion cost report |

```typescript
export const getOneLogGroupReportCostOfIngestion = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsLogGroupReportCostOfIngestion> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogGroupReportCostOfIngestion>> => {
    const { logGroupFilter, range } = input.by.unique;

    // resolve log groups from filter
    const targetLogGroups = await (async () => {
      if ('prefix' in logGroupFilter)
        return getAllLogGroups({ by: { prefix: logGroupFilter.prefix } }, context);
      if ('names' in logGroupFilter)
        return Promise.all(logGroupFilter.names.map((name) =>
          getOneLogGroup({ by: { unique: { name } } }, context)
        )).then((results) => results.filter(Boolean));
      throw UnexpectedCodePathError.throw('invalid logGroupFilter', { logGroupFilter });
    })();

    // get metrics for each log group
    const cloudwatch = new CloudWatchClient({ region: context.aws.credentials.region });
    const periodSeconds = Math.ceil((new Date(range.until).getTime() - new Date(range.since).getTime()) / 1000);
    const metricQueries = targetLogGroups.flatMap((lg, i) => [
      {
        Id: `bytes_${i}`,
        MetricStat: {
          Metric: {
            Namespace: 'AWS/Logs',
            MetricName: 'IncomingBytes',
            Dimensions: [{ Name: 'LogGroupName', Value: lg.name }],
          },
          Period: periodSeconds,
          Stat: 'Sum',
        },
      },
      {
        Id: `events_${i}`,
        MetricStat: {
          Metric: {
            Namespace: 'AWS/Logs',
            MetricName: 'IncomingLogEvents',
            Dimensions: [{ Name: 'LogGroupName', Value: lg.name }],
          },
          Period: periodSeconds,
          Stat: 'Sum',
        },
      },
    ]);

    const metricsResponse = await cloudwatch.send(new GetMetricDataCommand({
      MetricDataQueries: metricQueries,
      StartTime: new Date(range.since),
      EndTime: new Date(range.until),
    }));

    // cast into domain object with cost calculations
    return castIntoDeclaredAwsLogGroupReportCostOfIngestion({ input, logGroups: targetLogGroups, metrics: metricsResponse });
  },
);
```

---

## Access DAOs

### DeclaredAwsLogGroupDao

```typescript
export const DeclaredAwsLogGroupDao = new DeclastructDao<
  DeclaredAwsLogGroup,
  typeof DeclaredAwsLogGroup,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      return getOneLogGroup({ by: { primary: input } }, context);
    },
    byUnique: async (input, context) => {
      return getOneLogGroup({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // Note: set operations not needed — log groups are created automatically by Lambda
});
```

---

### DeclaredAwsLogGroupReportDistOfPatternDao

```typescript
export const DeclaredAwsLogGroupReportDistOfPatternDao = new DeclastructDao<
  DeclaredAwsLogGroupReportDistOfPattern,
  typeof DeclaredAwsLogGroupReportDistOfPattern,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) => {
      return getOneLogGroupReportDistOfPattern({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroupReportDistOfPattern })(input))
        return getOneLogGroupReportDistOfPattern({ by: { unique: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // Note: set operations not supported — this is a readonly/derived entity
});
```

---

### DeclaredAwsLogGroupReportCostOfIngestionDao

```typescript
export const DeclaredAwsLogGroupReportCostOfIngestionDao = new DeclastructDao<
  DeclaredAwsLogGroupReportCostOfIngestion,
  typeof DeclaredAwsLogGroupReportCostOfIngestion,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) => {
      return getOneLogGroupReportCostOfIngestion({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroupReportCostOfIngestion })(input))
        return getOneLogGroupReportCostOfIngestion({ by: { unique: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // Note: set operations not supported — this is a readonly/derived entity
});
```

---

## Summary

### Domain Objects

| Object | Type | Purpose | Primary | Unique |
|--------|------|---------|---------|--------|
| `DeclaredAwsLogGroup` | Entity | Log group discovery | `[arn]` | `[name]` |
| `DeclaredAwsLogGroupReportDistOfPattern` | Entity (readonly) | Pattern distribution analysis | — | `[logGroups, range, pattern, filter, limit]` |
| `DeclaredAwsLogGroupReportCostOfIngestion` | Entity (readonly) | Cost analysis | — | `[logGroupFilter, range]` |
| `DeclaredAwsLogGroupFilter` | Literal (PickOne) | Log group selection | — | — |
| `DeclaredAwsLogGroupReportDistOfPatternRow` | Literal | Distribution row | — | — |
| `DeclaredAwsLogGroupReportCostOfIngestionRow` | Literal | Cost row | — | — |

### Key Patterns Applied

1. **Readonly Entities**: `DeclaredAwsLogGroupReportDistOfPattern` and `DeclaredAwsLogGroupReportCostOfIngestion` are readonly/derived entities with no primary key — their unique key is the query parameters, and their data is computed from AWS APIs.

2. **Cacheability**: Historical time ranges produce stable results, enabling intelligent caching. The unique key (including range) serves as the cache key.

3. **Composability**: These entities can be composed together. For example, a `DeclaredAwsLogGroupReportCostOfIngestion` could be used to identify high-cost log groups, then `DeclaredAwsLogGroupReportDistOfPattern` queries could drill into specific groups.

4. **No Set Operations**: These entities are read-only views of AWS data. Unlike `DeclaredAwsLambda` which can be created/updated, log analytics entities are purely derived.

5. **Explicit References**: `logGroups` uses `RefByUnique<typeof DeclaredAwsLogGroup>[]` to make relationships explicit rather than raw strings.

6. **PickOne for Filters**: `DeclaredAwsLogGroupFilter` uses `PickOne<{ prefix, names }>` to enforce exactly one selection method.

7. **Configurable Pattern**: `DeclaredAwsLogGroupReportDistOfPattern.pattern` allows analyzing frequency of any log field (e.g., `@message`, `level`, `requestId`), not just messages.

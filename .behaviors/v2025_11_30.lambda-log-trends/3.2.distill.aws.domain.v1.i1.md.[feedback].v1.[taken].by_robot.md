# Feedback Response: 3.2.distill.aws.domain.v1.i1.md

## Response Checklist

- [ ] nitpick.1: `DeclaredAwsLogGroup.logGroupClass` => `DeclaredAwsLogGroup.class`
- [ ] blocker.2: `DeclaredAwsLogGroup.arn` is metadata => add to `public static metadata`, make optional
- [ ] blocker.3: `DeclaredAwsLogMessageHistogram.logGroupNames: string[]` => `logGroups: RefByUnique<typeof DeclaredAwsLogGroup>[]` + add to `public static nested`
- [ ] blocker.4: `timeRange: DeclaredAwsLogTimeRange` => `range: UniDateTimeRange` from `@ehmpathy/uni-time`
- [ ] blocker.5: `filter` & `limit` must be `T | null`, not optional (only readonly/metadata can be optional)
- [ ] blocker.6: Move `entries` to bottom of each domain object's attributes
- [ ] blocker.7: Remove `queryId` and `queryStatus` from domain objects (infra-level details, not domain)
- [ ] blocker.8: Create `DeclaredAwsLogGroupFilter = PickOne<{ prefix: string, names: string[] }>` and use `logGroupFilter: DeclaredAwsLogGroupFilter` in `DeclaredAwsLogIngestionCostReport`
- [ ] blocker.9: Drop `DeclaredAwsLogGroupFields` concept entirely

---

## Updated Domain Objects

### Entities

#### DeclaredAwsLogGroup

```typescript
/**
 * .what = a declarative structure representing an AWS CloudWatch Log Group
 * .note = for lambda functions, automatically created as /aws/lambda/<function-name>
 */
export interface DeclaredAwsLogGroup {
  /**
   * .what = the arn of the log group
   * .note = @metadata — assigned by AWS
   */
  arn?: string;

  /**
   * .what = the name of the log group
   * .note = @unique
   * .example = '/aws/lambda/svc-chat-prod-getDisplayableMessages'
   */
  name: string;

  /**
   * .what = the log group class
   */
  class: 'STANDARD' | 'INFREQUENT_ACCESS' | 'DELIVERY';

  /**
   * .what = optional KMS key for encryption
   */
  kmsKeyId: string | null;

  /**
   * .what = retention period in days
   * .note = @readonly — null means never expire
   */
  retentionInDays?: number | null;

  /**
   * .what = when the log group was created
   * .note = @readonly
   */
  createdAt?: UniDateTime;

  /**
   * .what = total bytes stored in the log group
   * .note = @readonly — updates with ~24hr delay
   */
  storedBytes?: number;
}

export class DeclaredAwsLogGroup
  extends DomainEntity<DeclaredAwsLogGroup>
  implements DeclaredAwsLogGroup
{
  public static primary = ['arn'] as const;
  public static unique = ['name'] as const;
  public static metadata = ['arn'] as const;
  public static readonly = ['storedBytes', 'createdAt', 'retentionInDays'] as const;
}
```

---

#### DeclaredAwsLogMessageHistogram

```typescript
/**
 * .what = aggregated histogram of log messages for a set of log groups over a time range
 * .why = enables declarative analysis of log message patterns and sizes
 *
 * .identity
 *   - @unique = [logGroups, range, filter, limit] — defined by query parameters
 *   - no @primary — this is a computed/derived entity, not persisted
 *
 * .note
 *   - this is a readonly entity — data comes from CloudWatch Logs Insights
 *   - cacheability is determined by range (historical ranges are stable)
 */
export interface DeclaredAwsLogMessageHistogram {
  /**
   * .what = the log groups queried
   * .note = part of @unique
   */
  logGroups: RefByUnique<typeof DeclaredAwsLogGroup>[];

  /**
   * .what = the time range queried
   * .note = part of @unique
   */
  range: UniDateTimeRange;

  /**
   * .what = query filter (e.g., exclude REPORT, START, END)
   * .note = part of @unique — Logs Insights filter pattern; null means no filter
   */
  filter: string | null;

  /**
   * .what = max number of unique messages to return
   * .note = part of @unique — null means use default (1000)
   */
  limit: number | null;

  /**
   * .what = total bytes scanned by the query
   * .note = @readonly
   */
  scannedBytes?: number;

  /**
   * .what = total log events matched
   * .note = @readonly
   */
  matchedEvents?: number;

  /**
   * .what = the histogram entries sorted by frequency descending
   * .note = @readonly — computed by CloudWatch Logs Insights
   */
  entries?: DeclaredAwsLogMessageHistogramEntry[];
}

export class DeclaredAwsLogMessageHistogram
  extends DomainEntity<DeclaredAwsLogMessageHistogram>
  implements DeclaredAwsLogMessageHistogram
{
  public static primary = [] as const; // no primary — derived entity
  public static unique = ['logGroups', 'range', 'filter', 'limit'] as const;
  public static metadata = [] as const;
  public static readonly = ['entries', 'scannedBytes', 'matchedEvents'] as const;

  public static nested = {
    logGroups: RefByUnique<typeof DeclaredAwsLogGroup>,
    entries: DeclaredAwsLogMessageHistogramEntry,
  };
}
```

---

#### DeclaredAwsLogIngestionCostReport

```typescript
/**
 * .what = aggregated ingestion cost report for log groups over a time range
 * .why = enables declarative understanding of CloudWatch Logs costs
 *
 * .identity
 *   - @unique = [logGroupFilter, range] — defined by query parameters
 *   - no @primary — this is a computed/derived entity
 *
 * .note
 *   - uses CloudWatch Metrics (AWS/Logs namespace, IncomingBytes metric)
 *   - cost calculation: ingestedBytes * $0.50/GB (varies by region)
 */
export interface DeclaredAwsLogIngestionCostReport {
  /**
   * .what = filter to select which log groups to include
   * .note = part of @unique
   */
  logGroupFilter: DeclaredAwsLogGroupFilter;

  /**
   * .what = the time range for the cost report
   * .note = part of @unique
   */
  range: UniDateTimeRange;

  /**
   * .what = total bytes ingested across all log groups
   * .note = @readonly
   */
  totalIngestedBytes?: number;

  /**
   * .what = total log events ingested
   * .note = @readonly
   */
  totalLogEvents?: number;

  /**
   * .what = total estimated cost in USD
   * .note = @readonly — uses $0.50/GB ingestion rate
   */
  totalEstimatedCostUsd?: number;

  /**
   * .what = the cost entries per log group, sorted by ingested bytes descending
   * .note = @readonly — computed from CloudWatch Metrics
   */
  entries?: DeclaredAwsLogIngestionCostEntry[];
}

export class DeclaredAwsLogIngestionCostReport
  extends DomainEntity<DeclaredAwsLogIngestionCostReport>
  implements DeclaredAwsLogIngestionCostReport
{
  public static primary = [] as const;
  public static unique = ['logGroupFilter', 'range'] as const;
  public static metadata = [] as const;
  public static readonly = ['entries', 'totalIngestedBytes', 'totalLogEvents', 'totalEstimatedCostUsd'] as const;

  public static nested = {
    logGroupFilter: DomainLiteral,
    entries: DeclaredAwsLogIngestionCostEntry,
  };
}
```

---

### Literals

#### DeclaredAwsLogGroupFilter

```typescript
/**
 * .what = a filter to select log groups by prefix or explicit names
 */
export type DeclaredAwsLogGroupFilter = PickOne<{
  /**
   * .what = the log group name prefix to filter by
   * .example = '/aws/lambda/' to get all lambda log groups
   */
  prefix: string;

  /**
   * .what = explicit list of log group names
   */
  names: string[];
}>;
```

---

#### DeclaredAwsLogMessageHistogramEntry

```typescript
/**
 * .what = a single entry in a log message histogram
 */
export interface DeclaredAwsLogMessageHistogramEntry {
  /**
   * .what = the log message pattern
   * .note = may be exact message or pattern-matched
   */
  message: string;

  /**
   * .what = how many times this message appeared
   */
  frequency: number;

  /**
   * .what = total bytes for all occurrences of this message
   */
  totalBytes: number;

  /**
   * .what = average message size in bytes
   */
  avgBytes: number;

  /**
   * .what = percentage of total log events
   */
  percentOfTotal: number;
}

export class DeclaredAwsLogMessageHistogramEntry
  extends DomainLiteral<DeclaredAwsLogMessageHistogramEntry>
  implements DeclaredAwsLogMessageHistogramEntry {}
```

---

#### DeclaredAwsLogIngestionCostEntry

```typescript
/**
 * .what = a single log group's ingestion cost data
 */
export interface DeclaredAwsLogIngestionCostEntry {
  /**
   * .what = the log group name
   */
  logGroupName: string;

  /**
   * .what = bytes ingested during the time range
   */
  ingestedBytes: number;

  /**
   * .what = number of log events ingested
   */
  logEvents: number;

  /**
   * .what = estimated cost in USD
   * .note = calculated as ingestedBytes * $0.50/GB
   */
  estimatedCostUsd: number;

  /**
   * .what = percentage of total ingested bytes
   */
  percentOfTotal: number;
}

export class DeclaredAwsLogIngestionCostEntry
  extends DomainLiteral<DeclaredAwsLogIngestionCostEntry>
  implements DeclaredAwsLogIngestionCostEntry {}
```

---

## Updated Use Case Contracts

### Use Case 1: Log Message Histogram

```typescript
const histogram = await provider.get(DeclaredAwsLogMessageHistogram, {
  by: {
    unique: {
      logGroups: [{ name: '/aws/lambda/svc-chat-prod-getDisplayableMessages' }],
      range: { since: '2024-11-01T00:00:00Z', until: '2024-11-30T23:59:59Z' },
      filter: null,
      limit: null,
    },
  },
});

// Result:
// {
//   logGroups: [{ name: '...' }],
//   range: {...},
//   filter: null,
//   limit: null,
//   scannedBytes: 3110000000,
//   matchedEvents: 6523133,
//   entries: [
//     { message: 'START RequestId: ...', frequency: 6523133, totalBytes: 521850640, avgBytes: 80, percentOfTotal: 100 },
//     ...
//   ],
// }
```

### Use Case 2: Log Ingestion Cost Report

```typescript
const costReport = await provider.get(DeclaredAwsLogIngestionCostReport, {
  by: {
    unique: {
      logGroupFilter: { prefix: '/aws/lambda/' },
      range: { since: '2024-11-01T00:00:00Z', until: '2024-11-30T23:59:59Z' },
    },
  },
});

// Result:
// {
//   logGroupFilter: { prefix: '/aws/lambda/' },
//   range: {...},
//   totalIngestedBytes: 5340000000,
//   totalLogEvents: 10523819,
//   totalEstimatedCostUsd: 28.62,
//   entries: [
//     { logGroupName: '/aws/lambda/svc-chat-prod-getDisplayableMessages', ingestedBytes: 3338813440, logEvents: 6523133, estimatedCostUsd: 11.42, percentOfTotal: 62.5 },
//     ...
//   ],
// }
```

---

## Updated Domain Operations

### Log Message Histogram Operations

```typescript
export const getOneLogMessageHistogram = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsLogMessageHistogram> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogMessageHistogram>> => {
    const { logGroups, range, filter, limit } = input.by.unique;

    // resolve log group names from refs
    const logGroupNames = logGroups.map((ref) => ref.name);

    // build Logs Insights query
    const query = `
      fields @message
      ${filter ? `| filter ${filter}` : ''}
      | stats count(*) as frequency,
              sum(strlen(@message)) as totalBytes,
              avg(strlen(@message)) as avgBytes
        by @message
      | sort frequency desc
      | limit ${limit ?? 1000}
    `;

    // start query
    const logs = new CloudWatchLogsClient({ region: context.aws.credentials.region });
    const startResponse = await logs.send(new StartQueryCommand({
      logGroupNames,
      startTime: new Date(range.since).getTime() / 1000,
      endTime: new Date(range.until).getTime() / 1000,
      queryString: query,
    }));

    // poll for results
    let results;
    while (true) {
      results = await logs.send(new GetQueryResultsCommand({ queryId: startResponse.queryId }));
      if (results.status === 'Complete') break;
      if (results.status === 'Failed' || results.status === 'Cancelled') {
        throw new HelpfulError(`Query failed with status: ${results.status}`, { queryId: startResponse.queryId });
      }
      await sleep(1000);
    }

    // cast into domain object
    return castIntoDeclaredAwsLogMessageHistogram({ input, results });
  },
);
```

### Log Ingestion Cost Report Operations

```typescript
export const getOneLogIngestionCostReport = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsLogIngestionCostReport> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLogIngestionCostReport>> => {
    const { logGroupFilter, range } = input.by.unique;

    // resolve log groups from filter
    const targetLogGroups = await (async () => {
      if ('prefix' in logGroupFilter)
        return getAllLogGroups({ by: { prefix: logGroupFilter.prefix } }, context);
      if ('names' in logGroupFilter)
        return Promise.all(logGroupFilter.names.map((name) =>
          getOneLogGroup({ by: { unique: { name } } }, context)
        )).then((results) => results.filter(Boolean));
      throw UnexpectedCodePathError.throw('invalid logGroupFilter', { logGroupFilter });
    })();

    // get metrics for each log group
    const cloudwatch = new CloudWatchClient({ region: context.aws.credentials.region });
    const periodSeconds = Math.ceil((new Date(range.until).getTime() - new Date(range.since).getTime()) / 1000);
    const metricQueries = targetLogGroups.flatMap((lg, i) => [
      {
        Id: `bytes_${i}`,
        MetricStat: {
          Metric: {
            Namespace: 'AWS/Logs',
            MetricName: 'IncomingBytes',
            Dimensions: [{ Name: 'LogGroupName', Value: lg.name }],
          },
          Period: periodSeconds,
          Stat: 'Sum',
        },
      },
      {
        Id: `events_${i}`,
        MetricStat: {
          Metric: {
            Namespace: 'AWS/Logs',
            MetricName: 'IncomingLogEvents',
            Dimensions: [{ Name: 'LogGroupName', Value: lg.name }],
          },
          Period: periodSeconds,
          Stat: 'Sum',
        },
      },
    ]);

    const metricsResponse = await cloudwatch.send(new GetMetricDataCommand({
      MetricDataQueries: metricQueries,
      StartTime: new Date(range.since),
      EndTime: new Date(range.until),
    }));

    // cast into domain object with cost calculations
    return castIntoDeclaredAwsLogIngestionCostReport({ input, logGroups: targetLogGroups, metrics: metricsResponse });
  },
);
```

---

## Updated Access DAOs

### DeclaredAwsLogGroupDao

```typescript
export const DeclaredAwsLogGroupDao = new DeclastructDao<
  DeclaredAwsLogGroup,
  typeof DeclaredAwsLogGroup,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => {
      return getOneLogGroup({ by: { primary: input } }, context);
    },
    byUnique: async (input, context) => {
      return getOneLogGroup({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsLogGroup })(input))
        return getOneLogGroup({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // Note: set operations not needed — log groups are created automatically by Lambda
});
```

### DeclaredAwsLogMessageHistogramDao

```typescript
export const DeclaredAwsLogMessageHistogramDao = new DeclastructDao<
  DeclaredAwsLogMessageHistogram,
  typeof DeclaredAwsLogMessageHistogram,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) => {
      return getOneLogMessageHistogram({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogMessageHistogram })(input))
        return getOneLogMessageHistogram({ by: { unique: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // Note: set operations not supported — this is a readonly/derived entity
});
```

### DeclaredAwsLogIngestionCostReportDao

```typescript
export const DeclaredAwsLogIngestionCostReportDao = new DeclastructDao<
  DeclaredAwsLogIngestionCostReport,
  typeof DeclaredAwsLogIngestionCostReport,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byUnique: async (input, context) => {
      return getOneLogIngestionCostReport({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsLogIngestionCostReport })(input))
        return getOneLogIngestionCostReport({ by: { unique: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  // Note: set operations not supported — this is a readonly/derived entity
});
```

---

## Updated Summary

### Domain Objects

| Object | Type | Purpose | Primary | Unique |
|--------|------|---------|---------|--------|
| `DeclaredAwsLogGroup` | Entity | Log group discovery | `[arn]` | `[name]` |
| `DeclaredAwsLogMessageHistogram` | Entity (readonly) | Message pattern analysis | — | `[logGroups, range, filter, limit]` |
| `DeclaredAwsLogIngestionCostReport` | Entity (readonly) | Cost analysis | — | `[logGroupFilter, range]` |
| `DeclaredAwsLogGroupFilter` | Literal (PickOne) | Log group selection | — | — |
| `DeclaredAwsLogMessageHistogramEntry` | Literal | Histogram entry | — | — |
| `DeclaredAwsLogIngestionCostEntry` | Literal | Cost entry | — | — |

### Dropped

- ~~`DeclaredAwsLogGroupFields`~~ — removed per blocker.9
- ~~`DeclaredAwsLogField`~~ — removed (was only used by dropped entity)
- ~~`DeclaredAwsLogTimeRange`~~ — replaced with `UniDateTimeRange` from `@ehmpathy/uni-time`

---

## Response Checkoffs

- [x] nitpick.1: `DeclaredAwsLogGroup.logGroupClass` => `DeclaredAwsLogGroup.class`
- [x] blocker.2: `DeclaredAwsLogGroup.arn` is metadata => add to `public static metadata`, make optional
- [x] blocker.3: `DeclaredAwsLogMessageHistogram.logGroupNames: string[]` => `logGroups: RefByUnique<typeof DeclaredAwsLogGroup>[]` + add to `public static nested`
- [x] blocker.4: `timeRange: DeclaredAwsLogTimeRange` => `range: UniDateTimeRange` from `@ehmpathy/uni-time`
- [x] blocker.5: `filter` & `limit` must be `T | null`, not optional (only readonly/metadata can be optional)
- [x] blocker.6: Move `entries` to bottom of each domain object's attributes
- [x] blocker.7: Remove `queryId` and `queryStatus` from domain objects (infra-level details, not domain)
- [x] blocker.8: Create `DeclaredAwsLogGroupFilter = PickOne<{ prefix: string, names: string[] }>` and use `logGroupFilter: DeclaredAwsLogGroupFilter` in `DeclaredAwsLogIngestionCostReport`
- [x] blocker.9: Drop `DeclaredAwsLogGroupFields` concept entirely

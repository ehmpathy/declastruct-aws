# blueprint: lambda with alias deployment

## overview

this blueprint describes how to implement the wish:
- deploy lambdas via declastruct with alias qualifiers (`expect=LIVE|IDLE`, `commit=$hash`, `pr=XYZ`)

using the domain objects distilled in:
- `.behaviors/v2025_11_29.lambda-with-alias/3.2.distill.v1.i1.ts`

following the patterns established in this repository.

---

## domain objects to implement

| domain object                   | location                                              | purpose                           |
| ------------------------------- | ----------------------------------------------------- | --------------------------------- |
| `DeclaredAwsIamPrincipal`       | `src/domain.objects/DeclaredAwsIamPrincipal.ts`       | principal spec for trust policies |
| `DeclaredAwsIamPolicyStatement` | `src/domain.objects/DeclaredAwsIamPolicyStatement.ts` | permission/trust policy statement |
| `DeclaredAwsIamRole`            | `src/domain.objects/DeclaredAwsIamRole.ts`            | iam execution role                |
| `DeclaredAwsIamRolePolicy`      | `src/domain.objects/DeclaredAwsIamRolePolicy.ts`      | inline policy attached to role    |
| `DeclaredAwsLambdaVersion`      | `src/domain.objects/DeclaredAwsLambdaVersion.ts`      | immutable published version       |
| `DeclaredAwsLambdaAlias`        | `src/domain.objects/DeclaredAwsLambdaAlias.ts`        | named pointer to version          |

note: `DeclaredAwsLambda` already exists at `src/domain.objects/DeclaredAwsLambda.ts` but needs updates to:
- add `role: RefByUnique<typeof DeclaredAwsIamRole>` (currently `role: string`)
- add `codeZipUri: string` (currently exists)
- update identity keys as needed

---

## domain operations to implement

### 1. iam role operations

#### files

```
src/domain.operations/iamRole/
├── castToDeclaredAwsIamRole.ts
├── castToDeclaredAwsIamRole.test.ts
├── getIamRole.ts
├── getIamRole.test.ts
├── setIamRole.ts
├── setIamRole.test.ts
└── setIamRole.integration.test.ts
```

#### castToDeclaredAwsIamRole

```ts
/**
 * .what = transforms aws sdk Role response to DeclaredAwsIamRole
 * .why = ensures type safety and readonly field enforcement
 */
export const castToDeclaredAwsIamRole = (
  input: { role: Role; trustPolicy: PolicyDocument },
): HasReadonly<typeof DeclaredAwsIamRole> => {
  // extract role name, arn, path, description from Role
  // parse trust policy document to extract statements
  // map Principal -> DeclaredAwsIamPrincipal format
  // assure readonly fields present
};
```

#### getIamRole

```ts
/**
 * .what = retrieves an iam role from aws
 * .why = enables lookup by primary (arn) or unique (name)
 */
export const getIamRole = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsIamRole>;
        unique: RefByUnique<typeof DeclaredAwsIamRole>;
        ref: Ref<typeof DeclaredAwsIamRole>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamRole> | null> => {
    // use GetRoleCommand
    // parse AssumeRolePolicyDocument (url-encoded json)
    // return null on NoSuchEntityException
  },
);
```

#### setIamRole

```ts
/**
 * .what = creates or updates an iam role
 * .why = enables declarative role management with trust policy
 *
 * .note
 *   - polls until role is assumable after creation (iam eventual consistency)
 *   - uses GetRole in a loop with exponential backoff until role is ready
 */
export const setIamRole = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredAwsIamRole;
      upsert: DeclaredAwsIamRole;
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamRole>> => {
    // 1. get existing role
    // 2. if exists + findsert: return existing
    // 3. if exists + upsert:
    //    - UpdateRoleCommand (description, maxSessionDuration)
    //    - UpdateAssumeRolePolicyCommand (trust policy)
    //    - TagRoleCommand if tags changed
    // 4. if not exists: CreateRoleCommand
    // 5. poll until role is assumable (waitUntilRoleExists or custom retry loop)
    // 6. return cast result
  },
);
```

---

### 2. iam role policy operations

#### files

```
src/domain.operations/iamRolePolicy/
├── castToDeclaredAwsIamRolePolicy.ts
├── castToDeclaredAwsIamRolePolicy.test.ts
├── getIamRolePolicy.ts
├── getIamRolePolicy.test.ts
├── setIamRolePolicy.ts
├── setIamRolePolicy.test.ts
└── setIamRolePolicy.integration.test.ts
```

#### getIamRolePolicy

```ts
/**
 * .what = retrieves an inline policy from an iam role
 * .why = enables lookup by unique key (role + policyName)
 */
export const getIamRolePolicy = asProcedure(
  async (
    input: {
      by: { unique: RefByUnique<typeof DeclaredAwsIamRolePolicy> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsIamRolePolicy> | null> => {
    // use GetRolePolicyCommand
    // parse PolicyDocument (url-encoded json)
    // return null on NoSuchEntityException
  },
);
```

#### setIamRolePolicy

```ts
/**
 * .what = creates or updates an inline policy on an iam role
 * .why = enables declarative permission management
 */
export const setIamRolePolicy = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredAwsIamRolePolicy;
      upsert: DeclaredAwsIamRolePolicy;
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<DeclaredAwsIamRolePolicy> => {
    // 1. resolve role reference to get roleName
    // 2. get existing policy
    // 3. if exists + findsert: return existing
    // 4. PutRolePolicyCommand (upsert behavior built-in)
    // 5. return result
  },
);
```

---

### 3. lambda operations (updates)

#### files to update

```
src/domain.operations/lambda/
├── castToDeclaredAwsLambda.ts        # update to handle role ref
├── getLambda.ts                       # no changes needed
├── setLambda.ts                       # update to resolve role ref
└── setLambda.test.ts                  # update tests
```

#### setLambda updates

```ts
/**
 * .what = creates or updates a lambda function
 * .why = enables declarative lambda management
 *
 * .note
 *   - reads code zip from codeZipUri (local path) and uploads directly to lambda
 *   - resolves role ref to arn before create/update
 *   - existing behavior already handles code upload via fs.readFileSync
 */

// add role resolution before create/update
const role = await DeclaredAwsIamRoleDao.get.byRef(input.role, context);
if (!role) UnexpectedCodePathError.throw('role not found', { role: input.role });

// use role.arn in CreateFunctionCommand and UpdateFunctionConfigurationCommand
// code upload already handled: fs.readFileSync(input.codeZipUri) -> ZipFile parameter
```

---

### 4. lambda version operations

#### files

```
src/domain.operations/lambdaVersion/
├── castToDeclaredAwsLambdaVersion.ts
├── castToDeclaredAwsLambdaVersion.test.ts
├── getLambdaVersion.ts
├── getLambdaVersion.test.ts
├── getLambdaVersions.ts
├── getLambdaVersions.test.ts
├── setLambdaVersion.ts
├── setLambdaVersion.test.ts
├── setLambdaVersion.integration.test.ts
├── delLambdaVersion.ts
├── delLambdaVersion.test.ts
└── utils/
    ├── calcConfigSha256.ts
    ├── calcConfigSha256.test.ts
    └── findVersionByFingerprint.ts
```

#### calcConfigSha256

```ts
/**
 * .what = computes sha256 hash of lambda configuration
 * .why = aws does not expose config hash; we compute it for version identity
 *
 * .includes
 *   - Handler, Runtime, MemorySize, Timeout
 *   - Environment.Variables, Role
 *   - VpcConfig, Layers, DeadLetterConfig
 *   - TracingConfig, EphemeralStorage, Architectures
 *   - LoggingConfig, SnapStart, FileSystemConfigs
 */
export const calcConfigSha256 = (
  input: { of: DeclaredAwsLambda },
): string => {
  const configState = {
    handler: input.of.handler,
    runtime: input.of.runtime,
    memorySize: input.of.memory,
    timeout: input.of.timeout,
    environment: input.of.envars,
    role: input.of.role, // the ref, not resolved arn
    // ... other locked attributes
  };
  return sha256(JSON.stringify(sortKeysDeep(configState)));
};
```

#### getLambdaVersion

```ts
/**
 * .what = retrieves a lambda version by primary (arn) or unique (lambda + hashes)
 * .why = enables lookup by content fingerprint for idempotent publishing
 */
export const getLambdaVersion = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsLambdaVersion>;
        unique: RefByUnique<typeof DeclaredAwsLambdaVersion>;
        ref: Ref<typeof DeclaredAwsLambdaVersion>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLambdaVersion> | null> => {
    // if by primary (arn): GetFunctionCommand with qualifier
    // if by unique (lambda + hashes):
    //   1. resolve lambda ref to get function name
    //   2. ListVersionsByFunctionCommand (paginate all)
    //   3. for each version, compute configSha256
    //   4. find match by codeSha256 + configSha256
    //   5. return matching version or null
  },
);
```

#### setLambdaVersion

```ts
/**
 * .what = publishes a new lambda version
 * .why = creates immutable snapshot for alias targeting
 *
 * .note
 *   - PublishVersion is idempotent — returns existing if code+config unchanged
 *   - we verify by fingerprint before and after to ensure correctness
 */
export const setLambdaVersion = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredAwsLambdaVersion;
      upsert: DeclaredAwsLambdaVersion;
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLambdaVersion>> => {
    const version = input.findsert ?? input.upsert;

    // 1. check if version already exists by fingerprint
    const existing = await getLambdaVersion({
      by: { unique: { lambda: version.lambda, codeSha256: version.codeSha256, configSha256: version.configSha256 } },
    }, context);

    // 2. if exists: return existing (both findsert and upsert are no-op for immutable versions)
    if (existing) return existing;

    // 3. resolve lambda ref to get function name
    const lambda = await DeclaredAwsLambdaDao.get.byRef(version.lambda, context);
    if (!lambda) UnexpectedCodePathError.throw('lambda not found', { lambda: version.lambda });

    // 4. publish version
    const client = new LambdaClient({ region: context.aws.credentials.region });
    const result = await client.send(new PublishVersionCommand({
      FunctionName: lambda.name,
      CodeSha256: version.codeSha256, // precondition: fail if code changed
      Description: version.description ?? undefined,
    }));

    // 5. verify published version matches expected fingerprint
    const publishedConfigSha256 = calcConfigSha256({ of: lambda });
    if (publishedConfigSha256 !== version.configSha256) {
      UnexpectedCodePathError.throw('config hash mismatch after publish', {
        expected: version.configSha256,
        actual: publishedConfigSha256,
      });
    }

    // 6. cast and return
    return castToDeclaredAwsLambdaVersion({ ...result, lambda: version.lambda, configSha256: version.configSha256 });
  },
);
```

#### delLambdaVersion

```ts
/**
 * .what = deletes a lambda version
 * .why = enables cleanup of old versions to free storage quota (75GB regional limit)
 *
 * .note
 *   - cannot delete $LATEST
 *   - cannot delete versions referenced by aliases (must delete alias first)
 *   - idempotent: returns success if version already deleted
 */
export const delLambdaVersion = asProcedure(
  async (
    input: {
      version: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsLambdaVersion>;
        unique: RefByUnique<typeof DeclaredAwsLambdaVersion>;
        ref: Ref<typeof DeclaredAwsLambdaVersion>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<{ deleted: true }> => {
    // 1. resolve version ref to get function name + version number
    const version = await getLambdaVersion({ by: input.version }, context);
    if (!version) return { deleted: true }; // already gone, idempotent

    // 2. resolve lambda ref
    const lambda = await DeclaredAwsLambdaDao.get.byRef(version.lambda, context);

    // 3. delete version
    const client = new LambdaClient({ region: context.aws.credentials.region });
    await client.send(new DeleteFunctionCommand({
      FunctionName: lambda.name,
      Qualifier: version.version,
    }));

    return { deleted: true };
  },
);
```

---

### 5. lambda alias operations

#### files

```
src/domain.operations/lambdaAlias/
├── castToDeclaredAwsLambdaAlias.ts
├── castToDeclaredAwsLambdaAlias.test.ts
├── getLambdaAlias.ts
├── getLambdaAlias.test.ts
├── getLambdaAliases.ts
├── getLambdaAliases.test.ts
├── setLambdaAlias.ts
├── setLambdaAlias.test.ts
├── setLambdaAlias.integration.test.ts
├── delLambdaAlias.ts
└── delLambdaAlias.test.ts
```

#### getLambdaAlias

```ts
/**
 * .what = retrieves a lambda alias by primary (arn) or unique (lambda + name)
 * .why = enables lookup for alias management
 */
export const getLambdaAlias = asProcedure(
  async (
    input: {
      by: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsLambdaAlias>;
        unique: RefByUnique<typeof DeclaredAwsLambdaAlias>;
        ref: Ref<typeof DeclaredAwsLambdaAlias>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLambdaAlias> | null> => {
    // use GetAliasCommand
    // return null on ResourceNotFoundException
  },
);
```

#### setLambdaAlias

```ts
/**
 * .what = creates or updates a lambda alias
 * .why = enables declarative alias management for version targeting
 *
 * .note
 *   - findsert: create only if not exists, error if exists with different version
 *   - upsert: create or update to point to specified version
 */
export const setLambdaAlias = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredAwsLambdaAlias;
      upsert: DeclaredAwsLambdaAlias;
    }>,
    context: ContextAwsApi & VisualogicContext,
  ): Promise<HasReadonly<typeof DeclaredAwsLambdaAlias>> => {
    const alias = input.findsert ?? input.upsert;

    // 1. resolve refs
    const lambda = await DeclaredAwsLambdaDao.get.byRef(alias.lambda, context);
    const version = await DeclaredAwsLambdaVersionDao.get.byRef(alias.version, context);

    // 2. get existing alias
    const existing = await getLambdaAlias({
      by: { unique: { lambda: alias.lambda, name: alias.name } },
    }, context);

    // 3. if exists + findsert:
    if (existing && input.findsert) {
      // verify points to same version, else error
      if (existing.version !== version.version) {
        BadRequestError.throw('alias exists with different version', {
          alias: alias.name,
          existingVersion: existing.version,
          requestedVersion: version.version,
        });
      }
      return existing;
    }

    // 4. if exists + upsert: UpdateAliasCommand
    // 5. if not exists: CreateAliasCommand
    const client = new LambdaClient({ region: context.aws.credentials.region });
    const command = existing
      ? new UpdateAliasCommand({
          FunctionName: lambda.name,
          Name: alias.name,
          FunctionVersion: version.version,
          Description: alias.description,
          RoutingConfig: alias.routingConfig,
        })
      : new CreateAliasCommand({
          FunctionName: lambda.name,
          Name: alias.name,
          FunctionVersion: version.version,
          Description: alias.description,
          RoutingConfig: alias.routingConfig,
        });

    const result = await client.send(command);
    return castToDeclaredAwsLambdaAlias({ ...result, lambda: alias.lambda, version: alias.version });
  },
);
```

#### delLambdaAlias

```ts
/**
 * .what = deletes a lambda alias
 * .why = enables cleanup of old aliases (e.g., stale pr-X aliases after merge)
 *
 * .note
 *   - idempotent: returns success if alias already deleted
 *   - deleting alias does not delete the version it points to
 */
export const delLambdaAlias = asProcedure(
  async (
    input: {
      alias: PickOne<{
        primary: RefByPrimary<typeof DeclaredAwsLambdaAlias>;
        unique: RefByUnique<typeof DeclaredAwsLambdaAlias>;
        ref: Ref<typeof DeclaredAwsLambdaAlias>;
      }>;
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<{ deleted: true }> => {
    // 1. resolve alias ref to get function name + alias name
    const alias = await getLambdaAlias({ by: input.alias }, context);
    if (!alias) return { deleted: true }; // already gone, idempotent

    // 2. resolve lambda ref
    const lambda = await DeclaredAwsLambdaDao.get.byRef(alias.lambda, context);

    // 3. delete alias
    const client = new LambdaClient({ region: context.aws.credentials.region });
    await client.send(new DeleteAliasCommand({
      FunctionName: lambda.name,
      Name: alias.name,
    }));

    return { deleted: true };
  },
);
```

---

## daos to implement

### files

```
src/access/daos/
├── DeclaredAwsIamRoleDao.ts
├── DeclaredAwsIamRolePolicyDao.ts
├── DeclaredAwsLambdaVersionDao.ts
└── DeclaredAwsLambdaAliasDao.ts
```

### pattern

each dao follows the established pattern:

```ts
export const DeclaredAwsXxxDao = new DeclastructDao<
  DeclaredAwsXxx,
  typeof DeclaredAwsXxx,
  ContextAwsApi & ContextLogTrail
>({
  get: {
    byPrimary: async (input, context) => getXxx({ by: { primary: input } }, context),
    byUnique: async (input, context) => getXxx({ by: { unique: input } }, context),
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredAwsXxx })(input))
        return getXxx({ by: { unique: input } }, context);
      if (isRefByPrimary({ of: DeclaredAwsXxx })(input))
        return getXxx({ by: { primary: input } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    findsert: async (input, context) => setXxx({ findsert: input }, context),
    upsert: async (input, context) => setXxx({ upsert: input }, context),
    delete: async (input, context) => { await delXxx({ xxx: { ref: input } }, context); },
  },
});
```

note: `set.delete` is added for `DeclaredAwsLambdaVersionDao` and `DeclaredAwsLambdaAliasDao` only. iam roles and policies typically should not be deleted via dao (requires explicit cleanup command).

---

## sdk exports

### files

update `src/contract/sdks/index.ts` to export:

```ts
// domain objects
export { DeclaredAwsIamPrincipal } from '../../domain.objects/DeclaredAwsIamPrincipal';
export { DeclaredAwsIamPolicyStatement } from '../../domain.objects/DeclaredAwsIamPolicyStatement';
export { DeclaredAwsIamRole } from '../../domain.objects/DeclaredAwsIamRole';
export { DeclaredAwsIamRolePolicy } from '../../domain.objects/DeclaredAwsIamRolePolicy';
export { DeclaredAwsLambdaVersion } from '../../domain.objects/DeclaredAwsLambdaVersion';
export { DeclaredAwsLambdaAlias } from '../../domain.objects/DeclaredAwsLambdaAlias';

// daos
export { DeclaredAwsIamRoleDao } from '../../access/daos/DeclaredAwsIamRoleDao';
export { DeclaredAwsIamRolePolicyDao } from '../../access/daos/DeclaredAwsIamRolePolicyDao';
export { DeclaredAwsLambdaVersionDao } from '../../access/daos/DeclaredAwsLambdaVersionDao';
export { DeclaredAwsLambdaAliasDao } from '../../access/daos/DeclaredAwsLambdaAliasDao';

// operations
export { getIamRole, setIamRole } from '../../domain.operations/iamRole';
export { getIamRolePolicy, setIamRolePolicy } from '../../domain.operations/iamRolePolicy';
export { getLambdaVersion, getLambdaVersions, setLambdaVersion, delLambdaVersion } from '../../domain.operations/lambdaVersion';
export { getLambdaAlias, getLambdaAliases, setLambdaAlias, delLambdaAlias } from '../../domain.operations/lambdaAlias';

// utilities
export { calcConfigSha256 } from '../../domain.operations/lambdaVersion/utils/calcConfigSha256';
```

---

## implementation order

the following order respects dependencies:

1. **domain objects** (no dependencies)
   - `DeclaredAwsIamPrincipal`
   - `DeclaredAwsIamPolicyStatement`
   - `DeclaredAwsIamRole`
   - `DeclaredAwsIamRolePolicy`
   - `DeclaredAwsLambdaVersion`
   - `DeclaredAwsLambdaAlias`

2. **iam role operations** (depends on: domain objects)
   - `castToDeclaredAwsIamRole`
   - `getIamRole`
   - `setIamRole`
   - `DeclaredAwsIamRoleDao`

3. **iam role policy operations** (depends on: iam role)
   - `castToDeclaredAwsIamRolePolicy`
   - `getIamRolePolicy`
   - `setIamRolePolicy`
   - `DeclaredAwsIamRolePolicyDao`

4. **lambda updates** (depends on: iam role)
   - update `DeclaredAwsLambda` to use role ref
   - update `castToDeclaredAwsLambda`
   - update `setLambda` to resolve role ref

5. **lambda version operations** (depends on: lambda)
   - `calcConfigSha256`
   - `castToDeclaredAwsLambdaVersion`
   - `getLambdaVersion`
   - `getLambdaVersions`
   - `setLambdaVersion`
   - `DeclaredAwsLambdaVersionDao`

6. **lambda alias operations** (depends on: lambda version)
   - `castToDeclaredAwsLambdaAlias`
   - `getLambdaAlias`
   - `getLambdaAliases`
   - `setLambdaAlias`
   - `DeclaredAwsLambdaAliasDao`

7. **sdk exports** (depends on: all above)
   - update `src/contract/sdks/index.ts`

8. **acceptance tests** (depends on: all above)
   - end-to-end deployment flow test

---

## key design decisions

### 1. version identity by content fingerprint

versions are identified by `(lambda, codeSha256, configSha256)` rather than just version number because:
- enables idempotent "find or publish" semantics
- allows declaring desired state without knowing version number
- matches aws PublishVersion idempotency behavior

### 2. configSha256 computed by declastruct

aws does not expose a config hash, so we compute it from the locked attributes:
- deterministic ordering via `sortKeysDeep`
- includes all attributes frozen at publish time
- excludes description (metadata) and version (output)

### 3. alias findsert vs upsert semantics

- **findsert**: find or insert — if alias exists pointing to different version, error (prevents accidental overwrites)
- **upsert**: update or insert — always point to specified version (for intentional cutover)

### 4. role reference in lambda

the lambda's `role` field uses `RefByUnique<typeof DeclaredAwsIamRole>` rather than raw arn string:
- enables declarative composition (declare role, reference it in lambda)
- role arn resolved at set time from the dao
- supports both pre-existing roles (by name) and newly created roles

---

## wish fulfillment mapping

| wish requirement                         | implementation                                               |
| ---------------------------------------- | ------------------------------------------------------------ |
| deploy lambdas given path to zip + privs | `setIamRole` + `setIamRolePolicy` + `setLambda`              |
| attach alias `expect=LIVE\|IDLE`         | `setLambdaAlias({ name: 'expect-LIVE', ... })`               |
| attach alias `commit=$hash`              | `setLambdaAlias({ name: 'commit-abc1234', ... })`            |
| attach alias `pr=XYZ`                    | `setLambdaAlias({ name: 'pr-42', ... })`                     |
| multiple aliases per version             | multiple `setLambdaAlias` calls pointing to same version ref |

---

## example usage (from vision)

```ts
// declare role
const role = new DeclaredAwsIamRole({
  name: 'svc-home-services.dev.execution-role',
  description: 'execution role for svc-home-services in dev',
  policies: [
    { effect: 'Allow', principal: { Service: 'lambda.amazonaws.com' }, action: 'sts:AssumeRole', resource: '*' },
  ],
});
await DeclaredAwsIamRoleDao.set.upsert(role, context);

// declare permissions
const rolePolicy = new DeclaredAwsIamRolePolicy({
  name: 'permissions',
  role: RefByUnique.from(role),
  statements: [
    { effect: 'Allow', action: 'ssm:GetParameters', resource: 'arn:aws:ssm:*:*:parameter/*' },
    { effect: 'Allow', action: ['lambda:InvokeFunction', 'lambda:InvokeAsync'], resource: '*' },
  ],
});
await DeclaredAwsIamRolePolicyDao.set.upsert(rolePolicy, context);

// declare lambda
const lambda = new DeclaredAwsLambda({
  name: 'svc-home-services.dev.getServiceBySlug',
  role: RefByUnique.from(role),
  runtime: 'nodejs20.x',
  handler: 'dist/contract/apis/getServiceBySlug.handler',
  codeZipUri: '.artifact/contents.zip',
  timeout: 30,
  memory: 1024,
  envars: { TZ: 'UTC', NODE_ENV: 'production' },
});
const lambdaResult = await DeclaredAwsLambdaDao.set.upsert(lambda, context);

// declare version
const version = new DeclaredAwsLambdaVersion({
  lambda: RefByUnique.from(lambda),
  codeSha256: lambdaResult.codeSha256,
  configSha256: calcConfigSha256({ of: lambda }),
  description: null,
});
const versionResult = await DeclaredAwsLambdaVersionDao.set.upsert(version, context);

// declare aliases
const aliases = ['expect-LIVE', 'commit-abc1234', 'pr-42'].map(name =>
  new DeclaredAwsLambdaAlias({
    name,
    lambda: RefByUnique.from(lambda),
    version: RefByUnique.from(versionResult),
  })
);
await Promise.all(aliases.map(alias => DeclaredAwsLambdaAliasDao.set.upsert(alias, context)));
```

---

## resolved decisions

1. **pruning**: ✅ added `delLambdaVersion` and `delLambdaAlias` operations for cleanup

2. **version description encoding**: ❌ not using — aliases are the mechanism for commit/pr labeling, not version descriptions

3. **code upload**: ✅ `setLambda` handles code upload — reads zip from `codeZipUri` (local path) and uploads to lambda directly

4. **role waiting**: ✅ `setIamRole` polls until role is assumable after creation (iam eventual consistency handling)

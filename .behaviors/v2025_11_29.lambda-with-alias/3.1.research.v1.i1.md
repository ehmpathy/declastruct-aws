# research: aws lambda attributes + aliases

## summary

this research covers:
1. what attributes are controllable via aws-sdk on aws-lambdas at function vs version grain
2. how lambda qualifiers/aliases work and whether multiple can be attached per version

---

## 1. lambda attributes: function-level vs version-level

### core principle

aws lambda has two conceptual levels:
- **$LATEST (unpublished)**: mutable, receives all code + config updates
- **published versions**: immutable snapshots of code + configuration

when you publish a version, lambda **locks** the code and most configuration. this creates an immutable snapshot that can be referenced by ARN or alias.

### attributes controllable at function-level ($LATEST)

these are set via `CreateFunction` and `UpdateFunctionConfiguration`:

| attribute | description | create | update |
|-----------|-------------|--------|--------|
| **FunctionName** | function identifier | ✅ required | ❌ |
| **Role** | execution role ARN | ✅ required | ✅ |
| **Code** | deployment package (S3, zip, image) | ✅ required | ❌ (use UpdateFunctionCode) |
| **Handler** | entry point method | ✅ required for zip | ✅ |
| **Runtime** | language runtime (nodejs22.x, python3.14, etc) | ✅ required for zip | ✅ |
| **MemorySize** | RAM in MB (128-10,240) | ✅ | ✅ |
| **Timeout** | max execution seconds (1-900) | ✅ | ✅ |
| **Environment** | key-value env vars | ✅ | ✅ |
| **VpcConfig** | security groups + subnets | ✅ | ✅ |
| **Layers** | function layer ARNs | ✅ | ✅ |
| **Architectures** | x86_64 or arm64 | ✅ | ❌ |
| **EphemeralStorage** | /tmp size (512-10,240 MB) | ✅ | ✅ |
| **Description** | function description (0-256 chars) | ✅ | ✅ |
| **DeadLetterConfig** | DLQ target ARN | ✅ | ✅ |
| **TracingConfig** | X-Ray tracing mode | ✅ | ✅ |
| **KMSKeyArn** | encryption key | ✅ | ✅ |
| **LoggingConfig** | CloudWatch logs settings | ✅ | ✅ |
| **FileSystemConfigs** | EFS mount config | ✅ | ✅ |
| **ImageConfig** | container overrides | ✅ | ✅ |
| **SnapStart** | cold start optimization | ✅ | ✅ |
| **PackageType** | "Zip" or "Image" | ✅ | ❌ |
| **CodeSigningConfigArn** | code signing | ✅ | ❌ |
| **Tags** | metadata labels | ✅ | ❌ (use TagResource) |

### attributes locked when version is published

when you call `PublishVersion`, these become **immutable** for that version:
- function code
- handler
- runtime
- memory size
- timeout
- environment variables
- vpc configuration
- dead letter queue
- iam role
- description
- architecture
- ephemeral storage
- layers
- file system configuration
- snapstart
- tracing configuration
- logging configuration
- package type

### attributes that remain configurable per-version (post-publish)

only these can be modified on a published version:
1. **triggers** (event source mappings)
2. **destinations** (async invocation destinations)
3. **provisioned concurrency**
4. **asynchronous invocation settings**
5. **database proxies**

### code update flow

to deploy new code:
1. `UpdateFunctionCode` - updates $LATEST with new code (S3 or zip)
2. `PublishVersion` - creates immutable snapshot from $LATEST
3. `CreateAlias` or `UpdateAlias` - point alias to new version

note: `UpdateFunctionCode` accepts a `Publish: true` parameter to atomically publish after code update.

---

## 2. terminology: version vs qualifier vs alias

### definitions

| term | what it is | example |
|------|------------|---------|
| **version** | immutable snapshot of function code + config, identified by numeric ID | `1`, `2`, `3`, ... |
| **qualifier** | the suffix on a function ARN that specifies which version/alias to invoke | `:1`, `:LIVE`, `:$LATEST` |
| **alias** | a named pointer to a version (a type of qualifier) | `LIVE`, `prod`, `pr-42` |

### relationship

```
qualifier (generic term)
├── $LATEST        → always points to unpublished mutable version
├── version number → numeric ID of a published immutable snapshot (e.g., "1", "2")
└── alias name     → named pointer that can be updated to target different versions (e.g., "LIVE")
```

### key distinctions

- **version**: a thing (immutable snapshot)
- **qualifier**: a way to reference a thing (suffix on ARN)
- **alias**: a mutable pointer to a version (named qualifier that can be retargeted)

versions are **immutable** — once published, version `5` always refers to the same code.
aliases are **mutable** — `LIVE` can point to version `5` today and version `6` tomorrow.

### ARN examples

```
# unqualified (defaults to $LATEST)
arn:aws:lambda:us-east-1:123456789012:function:my-function

# qualified with $LATEST (explicit)
arn:aws:lambda:us-east-1:123456789012:function:my-function:$LATEST

# qualified with version number
arn:aws:lambda:us-east-1:123456789012:function:my-function:5

# qualified with alias
arn:aws:lambda:us-east-1:123456789012:function:my-function:LIVE
```

### natural keys for versions

a version can be identified by several keys:

| key | what it identifies | example | readonly? |
|-----|-------------------|---------|-----------|
| **Version** | numeric ID assigned sequentially by lambda | `1`, `2`, `42` | ✅ yes — assigned by lambda, never settable |
| **CodeSha256** | SHA256 hash of the deployment package (base64-encoded) | `abc123...=` | ✅ yes — computed from zip contents |
| **RevisionId** | tracks configuration state at publish time | uuid-like string | ✅ yes — assigned by lambda on each update |

all three are **readonly** — they are computed/assigned by lambda, not settable by the caller.

however, they can be used as **precondition constraints**:
- `CodeSha256` → pass to `PublishVersion` to ensure code hasn't changed
- `RevisionId` → pass to `UpdateFunctionCode`, `UpdateFunctionConfiguration`, `PublishVersion`, `UpdateAlias` to ensure state hasn't changed

### writable field: Description

the only writable field on `PublishVersion` that could store a custom identifier is **Description**:

```ts
await lambda.publishVersion({
  FunctionName: 'my-function',
  Description: 'commit=abc1234 pr=42'  // 0-256 chars, writable
});
```

**limitations**:
- max 256 characters
- **not queryable** — `ListVersionsByFunction` returns all versions, no filtering by description
- to find a version by description, you must paginate through all versions and filter client-side

**implication for wish**:
- could encode `commit=abc1234 pr=42` in Description
- but aliases are better for lookup (direct ARN reference vs pagination + filter)
- Description is useful for human-readable metadata, not as a primary key

**CodeSha256** is the most useful natural key because:
- it's deterministic — same code = same hash
- you can calculate it locally before upload: `openssl dgst -sha256 -binary code.zip | openssl enc -base64`
- lambda won't publish a new version if code+config haven't changed (see below)

### PublishVersion API inputs

```ts
await lambda.publishVersion({
  FunctionName: 'my-function',      // required — function name or ARN
  Description: 'commit=abc1234',    // optional — override description (0-256 chars), writable
  CodeSha256: 'abc123...=',         // optional — precondition: only publish if code hash matches
  RevisionId: 'uuid-string'         // optional — precondition: only publish if revision matches
});
```

| parameter | required | purpose |
|-----------|----------|---------|
| `FunctionName` | ✅ | identifies the function |
| `Description` | ❌ | custom metadata for this version (only writable field) |
| `CodeSha256` | ❌ | precondition — fail if code changed since you read it |
| `RevisionId` | ❌ | precondition — fail if config changed since you read it |

### PublishVersion idempotency mechanics

**behavior**: `PublishVersion` is idempotent — if code+config haven't changed since the last published version, lambda returns the existing version instead of creating a new one.

```ts
// first call: publishes version 5
const v1 = await lambda.publishVersion({ FunctionName: 'my-fn' });
// v1.Version = "5"

// second call without any changes: returns version 5 again (no new version created)
const v2 = await lambda.publishVersion({ FunctionName: 'my-fn' });
// v2.Version = "5" (same as v1, not "6")
```

**what counts as "changed"**:
- code changes (different zip → different CodeSha256)
- config changes (memory, timeout, env vars, etc)

**how lambda detects changes internally**:

| aspect | detection mechanism | observable key |
|--------|---------------------|----------------|
| **code** | SHA256 hash of deployment package | `CodeSha256` |
| **config** | internal comparison (not documented) | `RevisionId` changes on any config update |

for **code**: lambda compares the `CodeSha256` of `$LATEST` against the last published version. if identical, no new version.

for **config**: the internal mechanism is not documented. what we know:
- `RevisionId` changes whenever you call `UpdateFunctionConfiguration`
- lambda compares the full config state of `$LATEST` vs last published version
- any difference in: memory, timeout, handler, runtime, env vars, vpc, layers, etc → new version eligible

**note**: there is no "config hash" exposed by the API. you cannot pre-compute whether config has changed — you can only observe that `RevisionId` changed after an update.

**what does NOT trigger a new version**:
- calling `PublishVersion` multiple times without changes
- updating aliases
- changing triggers, destinations, provisioned concurrency (these are version-independent)

**implications**:
- safe to call `PublishVersion` in CI/CD without worrying about duplicate versions
- to force a new version, you must first call `UpdateFunctionCode` or `UpdateFunctionConfiguration`
- version numbers are never reused — if you delete version 5 and publish again, you get version 6

**edge case — Description**:
the `Description` parameter on `PublishVersion` does NOT affect idempotency. if only the description differs, lambda still returns the existing version (description is metadata on the version, not part of the code+config fingerprint).

### lookup by unique key: CodeSha256 + ConfigSha256

there's no API to query versions by `CodeSha256` or config. available options:

| API | can filter? | returns |
|-----|-------------|---------|
| `ListVersionsByFunction` | ❌ no filter params | all versions for one function |
| `GetFunction` | ❌ no | single function/version by name or ARN |
| `GetFunctionConfiguration` | ❌ no | config for single function/version |

**declastruct approach**: list all versions + filter client-side using composite key `(CodeSha256, ConfigSha256)`:

```ts
// 1. list all versions (small set due to pruning)
const versions = await lambda.listVersionsByFunction({ FunctionName });

// 2. compute ConfigSha256 for each and match
const match = versions.Versions.find(v =>
  v.CodeSha256 === targetCodeSha256 &&
  computeConfigSha256(v) === targetConfigSha256
);
```

**ConfigSha256 — what to include** (attributes locked when version is published):

```ts
const computeConfigSha256 = (version: FunctionConfiguration): string => {
  const configState = {
    Handler: version.Handler,
    Runtime: version.Runtime,
    MemorySize: version.MemorySize,
    Timeout: version.Timeout,
    Environment: version.Environment?.Variables ?? {},
    VpcConfig: version.VpcConfig,
    Layers: version.Layers?.map(l => l.Arn),
    Role: version.Role,
    DeadLetterConfig: version.DeadLetterConfig,
    TracingConfig: version.TracingConfig,
    FileSystemConfigs: version.FileSystemConfigs,
    EphemeralStorage: version.EphemeralStorage,
    Architectures: version.Architectures,
    LoggingConfig: version.LoggingConfig,
    SnapStart: version.SnapStart,
    // exclude: Description (metadata), Version (output), CodeSha256 (separate key)
  };
  return sha256(JSON.stringify(sortKeysDeep(configState)));
};
```

**key points**:
- `CodeSha256` = intrinsic (from lambda)
- `ConfigSha256` = computed (by declastruct)
- composite key: `(FunctionName, CodeSha256, ConfigSha256)` uniquely identifies a version
- pruning keeps version list small → O(n) scan is acceptable

**important**: CodeSha256 only covers the **code** (zip contents), not the configuration. two versions with the same code but different memory/timeout settings will have the same CodeSha256 but different RevisionIds.

### RevisionId deep dive

**what it is**: a UUID-like string that changes whenever you update a function or alias. represents "the latest updated revision" state.

**purpose**: optimistic locking to prevent concurrent modifications.

**how it works**:
```ts
// 1. read current state
const current = await lambda.getFunctionConfiguration({ FunctionName: 'my-fn' });
// current.RevisionId = "0894d3c1-2a3d-4d48-bf7f-abade99f3c15"

// 2. update with RevisionId constraint
await lambda.updateFunctionConfiguration({
  FunctionName: 'my-fn',
  MemorySize: 512,
  RevisionId: current.RevisionId  // only update if unchanged
});
// if someone else modified in between, this throws PreconditionFailedException
```

**where RevisionId applies**:
- `UpdateFunctionCode` — pass RevisionId to ensure code hasn't changed since read
- `UpdateFunctionConfiguration` — pass RevisionId to ensure config hasn't changed
- `PublishVersion` — pass RevisionId to ensure state matches before publishing
- `UpdateAlias` — pass RevisionId to ensure alias hasn't been modified

**known limitation**: when `UpdateFunctionCode` returns, the RevisionId in the response corresponds to an "in progress" update. this RevisionId is unstable until the function becomes `Active`. this creates a race condition:
- you call `UpdateFunctionCode` → get RevisionId X
- you immediately call `PublishVersion` with RevisionId X → may fail because state is still `Pending`
- workaround: use `CodeSha256` instead of `RevisionId` for the `PublishVersion` constraint

**RevisionId vs CodeSha256**:
| aspect | RevisionId | CodeSha256 |
|--------|------------|------------|
| changes when | any update (code or config) | only code changes |
| stability | unstable during pending updates | stable once upload completes |
| use case | optimistic locking for config | content-addressable code identity |

**implication for wish**:
- `commit=$hash` alias can be created, but git commit hash ≠ CodeSha256
- git commit hash is a **deployment-time label** (external to lambda)
- CodeSha256 is a **code artifact fingerprint** (intrinsic to lambda)
- to map commit → version: store the mapping externally or encode commit in alias name

---

### code package vs version

**important distinction**: the code package (zip or image) is **not** the same as a version.

| concept | what it is | lifecycle |
|---------|------------|-----------|
| **code package** | the artifact containing function code (zip file or container image) | uploaded to S3 or ECR, can be overwritten |
| **$LATEST** | the unpublished function state that receives code updates | mutable, always exists |
| **version** | immutable snapshot created from $LATEST at a point in time | immutable, identified by number |

the relationship:

```
code.zip (artifact)
    ↓ UpdateFunctionCode
$LATEST (mutable working copy)
    ↓ PublishVersion
version 5 (immutable snapshot)
    ↑
aliases point here (LIVE, pr-42, commit-abc123)
```

**key insight**: when you upload a new zip, you're updating `$LATEST`. this does **not** affect any published versions. versions are frozen snapshots — they retain the code that existed when they were published, regardless of subsequent uploads.

this means:
- you can upload code 10 times without publishing any versions
- each `PublishVersion` call creates a new immutable snapshot
- old versions remain unchanged and invocable
- aliases let you control which version receives traffic

---

## 3. aliases in depth

### what is an alias?

an alias is a **named pointer** to a specific function version. it provides:
- stable ARN for clients to invoke
- ability to update the target version without client changes
- traffic splitting between two versions (weighted routing)

### alias ARN format

```
arn:aws:lambda:{region}:{account}:function:{function-name}:{alias-name}
```

example:
```
arn:aws:lambda:us-east-1:123456789012:function:my-function:LIVE
```

### qualifiers

a qualifier is the suffix appended to a function ARN:
- `$LATEST` - always points to unpublished version
- `1`, `2`, `3`... - numeric version identifiers
- `LIVE`, `DEV`, `prod` - alias names

unqualified ARN = `$LATEST`:
```
arn:aws:lambda:us-east-1:123456789012:function:my-function
# equivalent to:
arn:aws:lambda:us-east-1:123456789012:function:my-function:$LATEST
```

### can you have multiple aliases per version? ✅ YES

**yes** - you can create multiple aliases pointing to the same version.

this is the key enabler for the wish requirements:
- `expect=LIVE` alias → version 5
- `commit=abc123` alias → version 5
- `pr=42` alias → version 5

each alias is independent. they can all point to the same version.

### CreateAlias API

```ts
// sdk call structure
const response = await lambda.createAlias({
  FunctionName: 'my-function',        // required
  Name: 'LIVE',                       // required, 1-128 chars, pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
  FunctionVersion: '5',               // required, version number or $LATEST
  Description: 'production traffic',  // optional, 0-256 chars
  RoutingConfig: {                    // optional, for weighted routing
    AdditionalVersionWeights: {
      '6': 0.1  // 10% to version 6
    }
  }
});
```

### alias naming constraints

- 1-128 characters
- pattern: `(?!^[0-9]+$)([a-zA-Z0-9-_]+)`
- **cannot be purely numeric** (to avoid confusion with version numbers)

valid: `LIVE`, `pr-42`, `commit_abc123`, `expect-IDLE`
invalid: `123`, `42`

### UpdateAlias API

```ts
await lambda.updateAlias({
  FunctionName: 'my-function',
  Name: 'LIVE',
  FunctionVersion: '6',  // point to new version
  Description: 'updated to v6'
});
```

### traffic splitting

aliases support weighted routing between two versions:

```ts
await lambda.updateAlias({
  FunctionName: 'my-function',
  Name: 'LIVE',
  FunctionVersion: '5',
  RoutingConfig: {
    AdditionalVersionWeights: {
      '6': 0.2  // 20% to version 6, 80% to version 5
    }
  }
});
```

---

## 4. quotas and limits

### aliases per function

**no explicit limit found** — aws does not document a maximum number of aliases per function. you can create as many aliases as needed.

### versions per function

**no explicit limit found** — aws does not document a maximum number of versions per function. lambda assigns monotonically increasing version numbers and never reuses them, even after deletion.

### the real constraint: 75 GB regional storage

the practical limit is the **75 GB regional storage quota** for all lambda deployment packages (code zips) across all functions in a region.

this matters because:
- every published version stores a copy of the deployment package
- frequent deployments × large bundles = storage exhaustion
- old versions must be cleaned up periodically

**cleanup strategies**:
- delete old versions not referenced by any alias
- use `lambda-janitor` from AWS SAR (scans and deletes unreferenced versions)
- serverless-prune-plugin for serverless framework
- custom cleanup via `ListVersionsByFunction` + `DeleteFunction` with qualifier

**implication for wish**:
- creating aliases (`commit-X`, `pr-Y`, `expect-Z`) has no practical limit
- the constraint is versions (each deployment = new version = stored zip)
- implement version cleanup to avoid hitting 75 GB limit

---

## 5. tags limitation ⚠️

**important**: tags apply at function-level only. they cannot be applied to versions or aliases.

from aws docs:
> "Tags apply at the function level, not to versions or aliases. Tags are not part of the version-specific configuration that AWS Lambda creates a snapshot of when you publish a version."

**implication for wish**:
- cannot use tags for `commit=$hash`, `pr=XYZ` metadata
- must use **aliases** as the mechanism for labeling deployments

---

## 6. proposed approach for wish

given the constraints, here's how to satisfy the wish:

### for `expect=LIVE|IDLE`
- create alias named `expect-LIVE` or `expect-IDLE`
- only one of these points to the current version at a time

### for `commit=$commitHash`
- create alias named `commit-{shortHash}` (e.g., `commit-abc1234`)
- alias name constraint: 128 chars max, so use short hash (7-8 chars)

### for `pr=XYZ`
- create alias named `pr-{number}` (e.g., `pr-42`)
- easy to lookup and target

### deployment flow
1. `UpdateFunctionCode` with new zip
2. `PublishVersion` → get version number
3. `CreateAlias` for each label:
   - `commit-abc1234` → version N
   - `pr-42` → version N
   - `expect-IDLE` → version N (new deployments start idle)
4. when promoting: `UpdateAlias` for `expect-LIVE` → version N

---

## sources

- [Lambda Versions](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
- [Lambda Aliases](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html)
- [CreateFunction API](https://docs.aws.amazon.com/lambda/latest/api/API_CreateFunction.html)
- [UpdateFunctionConfiguration API](https://docs.aws.amazon.com/lambda/latest/api/API_UpdateFunctionConfiguration.html)
- [UpdateFunctionCode API](https://docs.aws.amazon.com/lambda/latest/api/API_UpdateFunctionCode.html)
- [PublishVersion API](https://docs.aws.amazon.com/lambda/latest/api/API_PublishVersion.html)
- [CreateAlias API](https://docs.aws.amazon.com/lambda/latest/api/API_CreateAlias.html)
- [Lambda Tags](https://docs.aws.amazon.com/lambda/latest/dg/configuration-tags.html)

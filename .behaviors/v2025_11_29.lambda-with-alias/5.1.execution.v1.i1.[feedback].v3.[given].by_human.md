emit your response to the feedback into .behaviors/v2025_11_29.lambda-with-alias/5.1.execution.v1.i1.[feedback].v3.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---


# blocker.1

> AwsSdk*Raw => SdkAws*

---

# blocker.2

/**
 * .what = aws sdk policy statement shape (raw from api)
 * .why = defines the shape received from iam api responses
 */
export interface AwsSdkPolicyStatementRaw {
  Sid?: string;
  Effect: string;
  Principal?: unknown;
  Action: string | string[];
  Resource?: string | string[];
  Condition?: Record<string, Record<string, string | string[]>>;
}

why are we declaring the typ4e ourselves? cant we reuse one or more of the aws sdk types directly?

---

# blocker.3

export const castIntoDeclaredAwsIamPrincipal = (
  principal: unknown,
):

forbid unknown. we should know exactly what types we need to support, since we know exactly all of the callers of this procedure

---

# blocker.4


export const castIntoDeclaredAwsIamRole = (
  role: Role,
): HasReadonly<typeof DeclaredAwsIamRole> => {

  =>

export const castIntoDeclaredAwsIamRole = (
  role: SdkAwsRole,
): HasReadonly<typeof DeclaredAwsIamRole> => {

always qualify the type source with the appropriate prefix

---

# blocker.5

as RefByUnique<typeof DeclaredAwsIamRole>,


eliminate ALL `as RefByUnique` `as` casts from prodcode

the types should always fit


---

# blocker.6

why doesn't this set all of the lambda attributes? (e.g., all of the tags?)

what else is missed?


    // otherwise, declare the desired attributes in aws's schema
    const setRequest: CreateFunctionRequest & UpdateFunctionCodeRequest = {
      FunctionName: lambdaDesired.name,
      Timeout: lambdaDesired.timeout,
      MemorySize: lambdaDesired.memory,
      Role: lambdaDesired.role,
      Handler: lambdaDesired.handler,
      Runtime: lambdaDesired.runtime,
      Environment: lambdaDesired.envars
        ? { Variables: lambdaDesired.envars }
        : undefined,
      Code: {
        ZipFile: codeZipBuffer,
      },
      Tags: {
        codeZipUri: lambdaDesired.codeZipUri,
      },
      Publish: true,
    };

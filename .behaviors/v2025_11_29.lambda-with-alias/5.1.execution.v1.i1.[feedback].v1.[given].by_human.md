emit your response to the feedback into .behaviors/v2025_11_29.lambda-with-alias/5.1.execution.v1.i1.[feedback].v1.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---


# blocker.1


the contract of delXYZ should be by: { ref }

not by: { alias} / by:{version}

e.g.,

 delete: async (input, context) => {
      await delLambdaAlias({ alias: { ref: input } }, context);
    },

fix delLambdaVersion and fixLambdaAlias


=====

# blocker.2

getLambdaVersions => getAllLambdaVersions
getLambdaAliases => getAllLambdaAliases
getLambdaVersion => getOneLambdaVersion
getLambdaAlias => getOneLambdaAlias

we should always use the getOne/getAll pattern

=====


# blocker.3

the get operations should always use contract of { by: X }


export const getLambdaAliases = asProcedure(
  async (
    input: {
      lambda: RefByUnique<typeof DeclaredAwsLambda>;
    },

    =>


export const getLambdaAliases = asProcedure(
  async (
    input: {
      by: { lambda: RefByUnique<typeof DeclaredAwsLambda>; }
    },


check each get operation. they should all follow that standard




=====


# blocker.4

use camel case everywhere for domain object attributes

violation =


export interface DeclaredAwsIamPrincipal {
  /**
   * .what = aws account, user, or role arns
   * .example = 'arn:aws:iam::123456789012:root' or '*'
   */
  AWS?: string | string[];

  /**
   * .what = aws service principals
   * .example = 'lambda.amazonaws.com'
   */
  Service?: string | string[];

  /**
   * .what = federated identity provider arns
   * .example = 'arn:aws:iam::123456789012:saml-provider/MyProvider'
   */
  Federated?: string | string[];
}


why are these capitalized?


also, is this better for principal?

```ts
type DeclaredAwsIamPrincipal = PickOne<{ aws?: string | string[], service: string | string[], federated: string | string[] }>
```
or can we really choose multiple keys at the same time?

====

# blocker.5


 * .what = an iam role for lambda execution
 * .why = defines the identity and permissions a lambda assumes at runtime
 *

 iam role is a generic resource that is applicable to many useceases, not just lambdas

 update the comments to reflect that


===

# blocker.6

if type of attribute is a RefByUnique<typeof X>

then the nested { x: } declaration should also be RefByUnique<typeof X>
not just X

e.g.,


  public static nested = {
    role: DeclaredAwsIamRole,
  =>


  public static nested = {
    role: RefByUnique<DeclaredAwsIamRole>,

in src/domain.objects/DeclaredAwsIamRolePolicy.ts

ensure to fix it everywhere

===

# blocker.7

you did not update the DeclaredAwsLambda domain entity based on the blueprint. we know for a fact that it needs significant updates

e.g., qualifier is not an attribute of a lambda

update all of the getter and setters for lambda on its own too

===

# blocker.8

all csating needs to be done via `castToDeclaredAws*` procedures

never in the getters and setters directly

e.g.,

```
 // normalize aws Statement format to our domain format
      const trustPolicy = {
        Statement: trustPolicyDoc.Statement.map(
          (stmt: {
            Sid?: string;
            Effect: string;
            Principal?: unknown;
            Action: string | string[];
            Resource: string | string[];
            Condition?: Record<string, Record<string, string | string[]>>;
          }) => ({
            sid: stmt.Sid,
            effect: stmt.Effect as 'Allow' | 'Deny',
            principal: stmt.Principal,
            action: stmt.Action,
            resource: stmt.Resource,
            condition: stmt.Condition,
          }),
        ),
      };
```

# blocker.9

never use random index files; unless they're explicitly requested, eliminate them

e.g.,

export { castToDeclaredAwsIamRole } from './castToDeclaredAwsIamRole';
export { getIamRole } from './getIamRole';
export { setIamRole } from './setIamRole';


no point


# blocker.10

never cast from our domain objects into Sdk types within the getters directly

create

`castFromDeclaredAwsXyz` casters instead

e.g.,

```

    // build trust policy document from policy statements
    const trustPolicyDocument = JSON.stringify({
      Version: '2012-10-17',
      Statement: roleDesired.policies.map((stmt) => ({
        Sid: stmt.sid,
        Effect: stmt.effect,
        Principal: stmt.principal,
        Action: stmt.action,
        Resource: stmt.resource,
        Condition: stmt.condition,
      })),
    });

```

---

# blocker.11

castToXyz => castIntoXyz

always Into instead of just To


---

# blocker.12

 throw new Error('role disappeared after update');

 never use plain errors

 MUST use UnexpectedCodePathError or BadRequestError always

 in this case, UnexpectedCodePath


---

# blocker.13

create a castIntoXyz per domain object

never copypasta

e.g., done for the DeclaredAwsIamPolicyStatement


---

# blocker.14


      by: { unique: RefByUnique<typeof DeclaredAwsIamRolePolicy> };
    },
    context: ContextAwsApi & VisualogicContext,
  ): Promise<DeclaredAwsIamRolePolicy | null> => {
    // resolve role reference to get role name
    const role = await DeclaredAwsIamRoleDao.get.byRef(
      input.by.unique.role as RefByUnique<typeof DeclaredAwsIamRole>,


why is `as RefByUnique<typeof DeclaredAwsIamRole>,` included here?

the type should be declared already on `input.by.unique.role`. there should be no need for `as`


check each spot that `as RefByUnique` is called; this is a code reak and is a huge hazard; our types should flow through and compose directly

---

# blocker.15

same here


      if (isRefByUnique({ of: DeclaredAwsLambdaAlias })(input.by.ref))
        return {
          unique: input.by.ref as RefByUnique<typeof DeclaredAwsLambdaAlias>,
        };

    isRefByUnique is a type guard; typescript already knows that if the condition was satisfied, its of that type

    that's its whole purpose!

  never use `as RefByUnique` or `as RefByPrimary`; the types should work!


# blocker.16


    // if lambda not found, alias can't exist either
    if (!functionName || !aliasName) return null;

in src/domain.operations/lambdaAlias/getLambdaAlias.ts

makes no sense and is a massive hazard

instead,

 const { functionName, aliasName } =
 =>
 const names: null | { functionName, aliasName }

and if null, return null

otherwise, the hazard is we dont parse out the attributes correctly and hide that error!

...

also, why are we even checking getLambda?


      // if by unique, resolve lambda ref
      if (by.unique) {
        const lambda = await getLambda(
          { by: { ref: by.unique.lambda as RefByUnique<typeof DeclaredAwsLambda> } },
          context,
        );
        if (!lambda) return { functionName: null, aliasName: null };
        return { functionName: lambda.name, aliasName: by.unique.name };
      }

->


      // if by unique, resolve lambda ref
      if (by.unique) {
        return { functionName: lambda.name, aliasName: by.unique.name };
      }


# blocker.17


      // build version ref from the response
      const versionRef = {
        lambda: by.unique?.lambda ?? { name: functionName, qualifier: null },
        codeSha256: '', // we don't have this from GetAlias response
        configSha256: '', // we don't have this from GetAlias response
      } as RefByUnique<typeof DeclaredAwsLambdaVersion>;

  lookup the version from the alias response; never just `as RefByUnique` and never make things up; dont be a liar


# blocker.18

scope try catches as narrowly as possible

e.g., in getLambdaAlias


    } catch (error) {
      // return null if alias not found
      if (error instanceof Error && error.name === 'ResourceNotFoundException') return null;
      throw error;
    }

  only needs to be around

      const response = await lambdaClient.send(
        new GetAliasCommand({
          FunctionName: functionName,
          Name: aliasName,
        }),
      );

  just `.catch(error => {
      // return null if alias not found
      if (error instanceof Error && error.name === 'ResourceNotFoundException') return null;
      throw error;
    }
  })` instead and avoid the try catch


# blocker.19


    // convert to domain objects
    return aliasList.map((alias) => {
      // build version ref (partial, we don't have full fingerprint from ListAliases)
      const versionRef = {
        lambda: input.lambda,
        codeSha256: '',
        configSha256: '',
      } as RefByUnique<typeof DeclaredAwsLambdaVersion>;

stop lying!

lookup the codeSha256 and configSha256 and get a full reference

this is so scary and such a huge hazard!

how could you! :cry:


# blocker.20

      lambda: aliasDesired.lambda as RefByUnique<typeof DeclaredAwsLambda>,
      version: aliasDesired.version as RefByUnique<typeof DeclaredAwsLambdaVersion>,

stop doing `as RefByUnique`!

that is mega forbidden

# blocker.21

      await lambdaClient.send(
        new DeleteFunctionCommand({
          FunctionName: lambda.name,
          Qualifier: version.version,

add some guards that guarantee version is declared, so we dont accidentally delete latest

should not be able to delete latest via `delLambdaVersion`


# blocker.22

shouldn't castToDeclaredAwsLambdaVersion compute the configSha256 itself?



      // build a lambda-like object to compute config hash
      const configHash = calcConfigSha256({
        of: {
          ...lambda,
          handler: versionConfig.Handler!,
          runtime: versionConfig.Runtime!,
          memory: versionConfig.MemorySize!,
          timeout: versionConfig.Timeout!,
          role: versionConfig.Role!,
          envars: versionConfig.Environment?.Variables ?? {},
        },
      });

      versions.push(
        castToDeclaredAwsLambdaVersion({
          functionConfig: versionConfig,
          lambda: input.lambda,
          configSha256: configHash,
        }),
      );

thats literally part of casting!


# blocker.23

term `existing` => `foundBefore`

i never want to see the term `existing` ever again, anywhere in the repo

`foundBefore` and `foundAfter` are the blessed terms

# blocker.24


      // check if ref looks like unique ref (has name field)
      const refAsUnique = input.by.ref as { name?: string; qualifier?: string | null };
      const looksLikeUnique = 'name' in refAsUnique && refAsUnique.name !== undefined;

      return looksLikeUnique

  never do something like this again

  always use isRefByUnique/Primary({ of: X })(input.by.ref) instead
